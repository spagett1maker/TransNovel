# PRD: TransNovel 번역 시스템 개선

**작성일**: 2026년 2월 3일
**버전**: 1.0
**상태**: Draft

---

## 1. 개요

### 1.1 배경
설정집 생성 시스템을 최적화하여 **856회차 기준 11시간 → 2시간**으로 단축했습니다. 이제 번역 시스템에도 유사한 최적화를 적용하여 대규모 작품의 번역 효율성과 안정성을 개선하고자 합니다.

### 1.2 현재 상태 요약

| 항목 | 현재 값 |
|------|---------|
| AI 모델 | Gemini 2.5 Flash |
| Rate Limit | 10 RPM |
| 타임아웃 | 180초 |
| maxOutputTokens | 65,536 |
| 병렬 처리 | 없음 (순차) |
| 청크 분할 | 동적 (토큰 기반) |

### 1.3 주요 문제점

1. **속도**: 500회차 번역 시 50분+ 소요 (순차 처리)
2. **프롬프트 비효율**: 용어집 전체 포함 → 토큰 낭비
3. **청크 실패 처리**: 실패 시 원문으로 대체 → 품질 저하
4. **자동 복구 부재**: 실패한 챕터는 수동 재시도 필요

---

## 2. 목표

### 2.1 정량적 목표

| 지표 | 현재 | 목표 | 개선율 |
|------|------|------|--------|
| 500회차 번역 시간 | 50분 | **20분** | 60% 단축 |
| 토큰 사용량 | 기준 | **30% 감소** | 비용 절감 |
| 청크 실패율 | 가끔 발생 | **자동 재시도** | 품질 향상 |
| 수동 개입 필요 | 실패 시 | **자동 복구** | UX 개선 |

### 2.2 정성적 목표

- 번역 품질 유지하면서 속도 향상
- 대규모 작품(5000회차+) 안정적 처리
- 운영 부담 최소화 (자동 모니터링, 자동 복구)

---

## 3. 개선 항목

### 3.1 병렬 번역 처리 (우선순위: 높음)

#### 현재
```
챕터1 → 챕터2 → 챕터3 → ... (순차)
```

#### 개선
```
[챕터1, 챕터2, 챕터3] 동시 처리 (병렬 3개)
```

#### 구현 방안
- 설정집 생성과 동일한 `Promise.allSettled` 패턴 적용
- `PARALLEL_CHAPTER_COUNT = 3` 설정
- 부분 성공 처리: 성공한 챕터는 저장, 실패는 재시도 큐

#### 예상 효과
- 500회차: 50분 → **17분** (3배 빠름)

#### 위험 요소
- Gemini Rate Limit (1500 RPM) - 3 병렬은 충분히 여유
- DB 동시 쓰기 - 챕터 ID가 다르므로 충돌 없음

---

### 3.2 Gemini JSON Mode 적용 (우선순위: 높음)

#### 현재
- 텍스트 출력 → 파싱
- 에러 시 복구 로직 필요

#### 개선
```typescript
generationConfig: {
  responseMimeType: "application/json",
}
```

#### 적용 대상
- `improveExpression()` - 3가지 대안 JSON 출력
- 향후 구조화된 출력이 필요한 기능

#### 주의
- 기본 번역(`translateText`)은 텍스트 출력 유지 (자연스러운 번역문)

---

### 3.3 프롬프트 최적화 (우선순위: 중간)

#### 3.3.1 용어집 동적 필터링

**현재**: 모든 용어(1000+개)를 프롬프트에 포함

**개선**: 해당 챕터에 등장하는 용어만 포함

```typescript
// 챕터 원문에서 용어 매칭
const relevantTerms = allTerms.filter(term =>
  chapterContent.includes(term.original)
);
```

**예상 효과**: 토큰 30-50% 절감

#### 3.3.2 인물 정보 필터링

**현재**: 모든 인물 정보 포함

**개선**: 해당 챕터에 등장하는 인물만 포함

```typescript
const relevantCharacters = allCharacters.filter(char =>
  chapterContent.includes(char.nameOriginal)
);
```

#### 3.3.3 장르 가이드 분리

**현재**: 14개 장르 하드코딩

**개선**: DB 또는 설정 파일로 분리
- 유지보수 용이
- A/B 테스트 가능
- 사용자 커스터마이징 가능

---

### 3.4 maxOutputTokens 최적화 (우선순위: 낮음)

#### 분석 필요
- 실제 번역 출력 길이 측정
- 원문 길이 대비 번역문 길이 비율 (한중: ~0.7배)

#### 예상 설정
```typescript
// 청크 기준 8000자 × 0.7 × 1.5(여유) = ~8400자 ≈ 4000토큰
maxOutputTokens: 8192  // 현재 65536에서 대폭 축소 가능
```

---

### 3.5 청크 실패 자동 재시도 (우선순위: 높음)

#### 현재
```typescript
// 청크 실패 시 원문으로 대체
if (failedChunks.length > 0) {
  result += originalChunk; // 품질 저하
}
```

#### 개선
```typescript
// 청크별 재시도 (최대 3회)
for (let retry = 0; retry < 3; retry++) {
  try {
    result = await translateChunk(chunk);
    break;
  } catch (e) {
    if (retry === 2) throw e;
    await delay(5000 * (retry + 1));
  }
}
```

---

### 3.6 자동 실패 복구 (우선순위: 중간)

#### 현재
- 실패한 챕터는 `failedChapterNums` 배열에 저장
- 사용자가 수동으로 선택하여 재시도

#### 개선
- 번역 작업 완료 후 실패 챕터 자동 재시도 (최대 2회)
- 모든 재시도 실패 시에만 사용자 알림

```typescript
// 자동 복구 로직
if (failedChapterNums.length > 0 && autoRetryCount < 2) {
  await retryFailedChapters(failedChapterNums);
  autoRetryCount++;
}
```

---

### 3.7 진행률 예측 개선 (우선순위: 낮음)

#### 현재
- 완료 챕터 수 / 전체 챕터 수 = 진행률
- 남은 시간 표시 없음

#### 개선
```typescript
interface ProgressEstimate {
  completedChapters: number;
  totalChapters: number;
  averageTimePerChapter: number;  // 실측 기반
  estimatedRemainingTime: number; // 분
  estimatedCompletion: Date;
}
```

---

## 4. 구현 우선순위

| 순위 | 항목 | 효과 | 복잡도 | 예상 시간 |
|------|------|------|--------|----------|
| 1 | 병렬 번역 (3개) | 속도 3배 | 중간 | 2시간 |
| 2 | 청크 재시도 강화 | 품질 향상 | 낮음 | 1시간 |
| 3 | 용어집 필터링 | 토큰 30% 절감 | 낮음 | 1시간 |
| 4 | 인물 필터링 | 토큰 20% 절감 | 낮음 | 1시간 |
| 5 | 자동 실패 복구 | UX 개선 | 중간 | 2시간 |
| 6 | JSON Mode (개선) | 안정성 | 낮음 | 30분 |
| 7 | 진행률 예측 | UX | 낮음 | 1시간 |
| 8 | maxOutputTokens | 비용 | 분석필요 | 1시간 |

---

## 5. 성공 지표

### 5.1 속도
- [ ] 500회차 번역 20분 이내 완료
- [ ] 5000회차 번역 4시간 이내 완료

### 5.2 품질
- [ ] 청크 실패로 인한 원문 노출 0건
- [ ] 자동 복구 성공률 95% 이상

### 5.3 비용
- [ ] 토큰 사용량 30% 절감

### 5.4 안정성
- [ ] 1000회차 연속 번역 중단 없음
- [ ] Circuit Breaker 발동 시 자동 복구

---

## 6. 리스크 및 대응

| 리스크 | 영향 | 대응 |
|--------|------|------|
| 병렬 처리로 Rate Limit 초과 | 번역 실패 | 병렬 수 동적 조정 |
| 용어 필터링으로 누락 | 번역 품질 저하 | 빈도 높은 용어는 항상 포함 |
| 자동 재시도 무한 루프 | 리소스 낭비 | 최대 재시도 횟수 제한 |

---

## 7. 향후 고려사항

### 7.1 Cron 기반 백그라운드 전환
- 설정집 생성과 동일한 구조
- 브라우저 종료해도 번역 계속
- 복잡도 높음 → Phase 2에서 고려

### 7.2 번역 품질 평가 자동화
- AI 기반 번역 품질 점수
- 낮은 품질 챕터 자동 재번역

### 7.3 번역 메모리 (TM)
- 반복되는 문장/표현 캐싱
- 일관성 향상 + 비용 절감

---

## 8. 참고

- 설정집 생성 최적화: 병렬 3개 + JSON Mode + 프롬프트 50% 축소
- 결과: 11시간 → 2시간 (5.5배 개선)
- 동일 패턴을 번역에 적용

---

## Appendix: 현재 아키텍처

```
[클라이언트]
    ↓ POST /api/translation
[API Route]
    ↓ after() 백그라운드 실행
[translateChapter()]
    ↓ 청크 분할 (동적)
[translateChunks()]
    ↓ 순차 처리 (현재)
[Gemini API]
    ↓ 응답
[DB 저장]
    ↓ SSE 진행률
[클라이언트]
```
