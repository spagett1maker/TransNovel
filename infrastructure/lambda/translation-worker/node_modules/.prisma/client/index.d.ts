
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Work
 * 
 */
export type Work = $Result.DefaultSelection<Prisma.$WorkPayload>
/**
 * Model Creator
 * 
 */
export type Creator = $Result.DefaultSelection<Prisma.$CreatorPayload>
/**
 * Model Chapter
 * 
 */
export type Chapter = $Result.DefaultSelection<Prisma.$ChapterPayload>
/**
 * Model GlossaryItem
 * 
 */
export type GlossaryItem = $Result.DefaultSelection<Prisma.$GlossaryItemPayload>
/**
 * Model TranslationLog
 * 
 */
export type TranslationLog = $Result.DefaultSelection<Prisma.$TranslationLogPayload>
/**
 * Model ActiveTranslationJob
 * 
 */
export type ActiveTranslationJob = $Result.DefaultSelection<Prisma.$ActiveTranslationJobPayload>
/**
 * Model TranslationJobHistory
 * 
 */
export type TranslationJobHistory = $Result.DefaultSelection<Prisma.$TranslationJobHistoryPayload>
/**
 * Model SettingBible
 * 
 */
export type SettingBible = $Result.DefaultSelection<Prisma.$SettingBiblePayload>
/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model SettingTerm
 * 
 */
export type SettingTerm = $Result.DefaultSelection<Prisma.$SettingTermPayload>
/**
 * Model TimelineEvent
 * 
 */
export type TimelineEvent = $Result.DefaultSelection<Prisma.$TimelineEventPayload>
/**
 * Model BibleGenerationJob
 * 
 */
export type BibleGenerationJob = $Result.DefaultSelection<Prisma.$BibleGenerationJobPayload>
/**
 * Model ChapterComment
 * 
 */
export type ChapterComment = $Result.DefaultSelection<Prisma.$ChapterCommentPayload>
/**
 * Model ChapterSnapshot
 * 
 */
export type ChapterSnapshot = $Result.DefaultSelection<Prisma.$ChapterSnapshotPayload>
/**
 * Model ChapterChange
 * 
 */
export type ChapterChange = $Result.DefaultSelection<Prisma.$ChapterChangePayload>
/**
 * Model ChapterActivity
 * 
 */
export type ChapterActivity = $Result.DefaultSelection<Prisma.$ChapterActivityPayload>
/**
 * Model EditorProfile
 * 
 */
export type EditorProfile = $Result.DefaultSelection<Prisma.$EditorProfilePayload>
/**
 * Model PortfolioItem
 * 
 */
export type PortfolioItem = $Result.DefaultSelection<Prisma.$PortfolioItemPayload>
/**
 * Model ProjectListing
 * 
 */
export type ProjectListing = $Result.DefaultSelection<Prisma.$ProjectListingPayload>
/**
 * Model ProjectApplication
 * 
 */
export type ProjectApplication = $Result.DefaultSelection<Prisma.$ProjectApplicationPayload>
/**
 * Model ProjectContract
 * 
 */
export type ProjectContract = $Result.DefaultSelection<Prisma.$ProjectContractPayload>
/**
 * Model ChapterRevisionRequest
 * 
 */
export type ChapterRevisionRequest = $Result.DefaultSelection<Prisma.$ChapterRevisionRequestPayload>
/**
 * Model EditorReview
 * 
 */
export type EditorReview = $Result.DefaultSelection<Prisma.$EditorReviewPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  AUTHOR: 'AUTHOR',
  EDITOR: 'EDITOR',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AgeRating: {
  ALL: 'ALL',
  FIFTEEN: 'FIFTEEN',
  NINETEEN: 'NINETEEN'
};

export type AgeRating = (typeof AgeRating)[keyof typeof AgeRating]


export const WorkStatus: {
  PREPARING: 'PREPARING',
  ONGOING: 'ONGOING',
  REGISTERED: 'REGISTERED',
  BIBLE_GENERATING: 'BIBLE_GENERATING',
  BIBLE_DRAFT: 'BIBLE_DRAFT',
  BIBLE_CONFIRMED: 'BIBLE_CONFIRMED',
  TRANSLATING: 'TRANSLATING',
  TRANSLATED: 'TRANSLATED',
  PROOFREADING: 'PROOFREADING',
  COMPLETED: 'COMPLETED'
};

export type WorkStatus = (typeof WorkStatus)[keyof typeof WorkStatus]


export const OriginalStatus: {
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED'
};

export type OriginalStatus = (typeof OriginalStatus)[keyof typeof OriginalStatus]


export const SourceLanguage: {
  ZH: 'ZH',
  JA: 'JA',
  EN: 'EN',
  OTHER: 'OTHER'
};

export type SourceLanguage = (typeof SourceLanguage)[keyof typeof SourceLanguage]


export const ChapterStatus: {
  PENDING: 'PENDING',
  TRANSLATING: 'TRANSLATING',
  TRANSLATED: 'TRANSLATED',
  REVIEWING: 'REVIEWING',
  EDITED: 'EDITED',
  APPROVED: 'APPROVED'
};

export type ChapterStatus = (typeof ChapterStatus)[keyof typeof ChapterStatus]


export const LogLevel: {
  DEBUG: 'DEBUG',
  INFO: 'INFO',
  WARN: 'WARN',
  ERROR: 'ERROR'
};

export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel]


export const LogCategory: {
  TRANSLATION: 'TRANSLATION',
  API_CALL: 'API_CALL',
  RATE_LIMIT: 'RATE_LIMIT',
  CHUNK: 'CHUNK',
  CHAPTER: 'CHAPTER',
  JOB: 'JOB',
  SYSTEM: 'SYSTEM'
};

export type LogCategory = (typeof LogCategory)[keyof typeof LogCategory]


export const BibleStatus: {
  GENERATING: 'GENERATING',
  DRAFT: 'DRAFT',
  CONFIRMED: 'CONFIRMED'
};

export type BibleStatus = (typeof BibleStatus)[keyof typeof BibleStatus]


export const CharacterRole: {
  PROTAGONIST: 'PROTAGONIST',
  ANTAGONIST: 'ANTAGONIST',
  SUPPORTING: 'SUPPORTING',
  MINOR: 'MINOR'
};

export type CharacterRole = (typeof CharacterRole)[keyof typeof CharacterRole]


export const TermCategory: {
  CHARACTER: 'CHARACTER',
  PLACE: 'PLACE',
  ORGANIZATION: 'ORGANIZATION',
  RANK_TITLE: 'RANK_TITLE',
  SKILL_TECHNIQUE: 'SKILL_TECHNIQUE',
  ITEM: 'ITEM',
  OTHER: 'OTHER'
};

export type TermCategory = (typeof TermCategory)[keyof typeof TermCategory]


export const EventType: {
  PLOT: 'PLOT',
  CHARACTER_DEV: 'CHARACTER_DEV',
  FORESHADOWING: 'FORESHADOWING',
  REVEAL: 'REVEAL',
  WORLD_BUILDING: 'WORLD_BUILDING'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const BibleJobStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type BibleJobStatus = (typeof BibleJobStatus)[keyof typeof BibleJobStatus]


export const SnapshotType: {
  MANUAL: 'MANUAL',
  AUTO_SAVE: 'AUTO_SAVE',
  STATUS_CHANGE: 'STATUS_CHANGE',
  RETRANSLATE: 'RETRANSLATE'
};

export type SnapshotType = (typeof SnapshotType)[keyof typeof SnapshotType]


export const ChangeType: {
  INSERT: 'INSERT',
  DELETE: 'DELETE',
  REPLACE: 'REPLACE'
};

export type ChangeType = (typeof ChangeType)[keyof typeof ChangeType]


export const ChangeStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED'
};

export type ChangeStatus = (typeof ChangeStatus)[keyof typeof ChangeStatus]


export const ActivityType: {
  COMMENT_ADDED: 'COMMENT_ADDED',
  COMMENT_RESOLVED: 'COMMENT_RESOLVED',
  COMMENT_REPLIED: 'COMMENT_REPLIED',
  EDIT_MADE: 'EDIT_MADE',
  CHANGE_ACCEPTED: 'CHANGE_ACCEPTED',
  CHANGE_REJECTED: 'CHANGE_REJECTED',
  STATUS_CHANGED: 'STATUS_CHANGED',
  SNAPSHOT_CREATED: 'SNAPSHOT_CREATED',
  SNAPSHOT_RESTORED: 'SNAPSHOT_RESTORED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const EditorAvailability: {
  AVAILABLE: 'AVAILABLE',
  BUSY: 'BUSY',
  UNAVAILABLE: 'UNAVAILABLE'
};

export type EditorAvailability = (typeof EditorAvailability)[keyof typeof EditorAvailability]


export const ProjectListingStatus: {
  DRAFT: 'DRAFT',
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ProjectListingStatus = (typeof ProjectListingStatus)[keyof typeof ProjectListingStatus]


export const ApplicationStatus: {
  PENDING: 'PENDING',
  SHORTLISTED: 'SHORTLISTED',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const RevisionRequestStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  DISPUTED: 'DISPUTED'
};

export type RevisionRequestStatus = (typeof RevisionRequestStatus)[keyof typeof RevisionRequestStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AgeRating = $Enums.AgeRating

export const AgeRating: typeof $Enums.AgeRating

export type WorkStatus = $Enums.WorkStatus

export const WorkStatus: typeof $Enums.WorkStatus

export type OriginalStatus = $Enums.OriginalStatus

export const OriginalStatus: typeof $Enums.OriginalStatus

export type SourceLanguage = $Enums.SourceLanguage

export const SourceLanguage: typeof $Enums.SourceLanguage

export type ChapterStatus = $Enums.ChapterStatus

export const ChapterStatus: typeof $Enums.ChapterStatus

export type LogLevel = $Enums.LogLevel

export const LogLevel: typeof $Enums.LogLevel

export type LogCategory = $Enums.LogCategory

export const LogCategory: typeof $Enums.LogCategory

export type BibleStatus = $Enums.BibleStatus

export const BibleStatus: typeof $Enums.BibleStatus

export type CharacterRole = $Enums.CharacterRole

export const CharacterRole: typeof $Enums.CharacterRole

export type TermCategory = $Enums.TermCategory

export const TermCategory: typeof $Enums.TermCategory

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type BibleJobStatus = $Enums.BibleJobStatus

export const BibleJobStatus: typeof $Enums.BibleJobStatus

export type SnapshotType = $Enums.SnapshotType

export const SnapshotType: typeof $Enums.SnapshotType

export type ChangeType = $Enums.ChangeType

export const ChangeType: typeof $Enums.ChangeType

export type ChangeStatus = $Enums.ChangeStatus

export const ChangeStatus: typeof $Enums.ChangeStatus

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type EditorAvailability = $Enums.EditorAvailability

export const EditorAvailability: typeof $Enums.EditorAvailability

export type ProjectListingStatus = $Enums.ProjectListingStatus

export const ProjectListingStatus: typeof $Enums.ProjectListingStatus

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type RevisionRequestStatus = $Enums.RevisionRequestStatus

export const RevisionRequestStatus: typeof $Enums.RevisionRequestStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.work`: Exposes CRUD operations for the **Work** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Works
    * const works = await prisma.work.findMany()
    * ```
    */
  get work(): Prisma.WorkDelegate<ExtArgs>;

  /**
   * `prisma.creator`: Exposes CRUD operations for the **Creator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creators
    * const creators = await prisma.creator.findMany()
    * ```
    */
  get creator(): Prisma.CreatorDelegate<ExtArgs>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **Chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.ChapterDelegate<ExtArgs>;

  /**
   * `prisma.glossaryItem`: Exposes CRUD operations for the **GlossaryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlossaryItems
    * const glossaryItems = await prisma.glossaryItem.findMany()
    * ```
    */
  get glossaryItem(): Prisma.GlossaryItemDelegate<ExtArgs>;

  /**
   * `prisma.translationLog`: Exposes CRUD operations for the **TranslationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranslationLogs
    * const translationLogs = await prisma.translationLog.findMany()
    * ```
    */
  get translationLog(): Prisma.TranslationLogDelegate<ExtArgs>;

  /**
   * `prisma.activeTranslationJob`: Exposes CRUD operations for the **ActiveTranslationJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActiveTranslationJobs
    * const activeTranslationJobs = await prisma.activeTranslationJob.findMany()
    * ```
    */
  get activeTranslationJob(): Prisma.ActiveTranslationJobDelegate<ExtArgs>;

  /**
   * `prisma.translationJobHistory`: Exposes CRUD operations for the **TranslationJobHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranslationJobHistories
    * const translationJobHistories = await prisma.translationJobHistory.findMany()
    * ```
    */
  get translationJobHistory(): Prisma.TranslationJobHistoryDelegate<ExtArgs>;

  /**
   * `prisma.settingBible`: Exposes CRUD operations for the **SettingBible** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettingBibles
    * const settingBibles = await prisma.settingBible.findMany()
    * ```
    */
  get settingBible(): Prisma.SettingBibleDelegate<ExtArgs>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs>;

  /**
   * `prisma.settingTerm`: Exposes CRUD operations for the **SettingTerm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettingTerms
    * const settingTerms = await prisma.settingTerm.findMany()
    * ```
    */
  get settingTerm(): Prisma.SettingTermDelegate<ExtArgs>;

  /**
   * `prisma.timelineEvent`: Exposes CRUD operations for the **TimelineEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimelineEvents
    * const timelineEvents = await prisma.timelineEvent.findMany()
    * ```
    */
  get timelineEvent(): Prisma.TimelineEventDelegate<ExtArgs>;

  /**
   * `prisma.bibleGenerationJob`: Exposes CRUD operations for the **BibleGenerationJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BibleGenerationJobs
    * const bibleGenerationJobs = await prisma.bibleGenerationJob.findMany()
    * ```
    */
  get bibleGenerationJob(): Prisma.BibleGenerationJobDelegate<ExtArgs>;

  /**
   * `prisma.chapterComment`: Exposes CRUD operations for the **ChapterComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChapterComments
    * const chapterComments = await prisma.chapterComment.findMany()
    * ```
    */
  get chapterComment(): Prisma.ChapterCommentDelegate<ExtArgs>;

  /**
   * `prisma.chapterSnapshot`: Exposes CRUD operations for the **ChapterSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChapterSnapshots
    * const chapterSnapshots = await prisma.chapterSnapshot.findMany()
    * ```
    */
  get chapterSnapshot(): Prisma.ChapterSnapshotDelegate<ExtArgs>;

  /**
   * `prisma.chapterChange`: Exposes CRUD operations for the **ChapterChange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChapterChanges
    * const chapterChanges = await prisma.chapterChange.findMany()
    * ```
    */
  get chapterChange(): Prisma.ChapterChangeDelegate<ExtArgs>;

  /**
   * `prisma.chapterActivity`: Exposes CRUD operations for the **ChapterActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChapterActivities
    * const chapterActivities = await prisma.chapterActivity.findMany()
    * ```
    */
  get chapterActivity(): Prisma.ChapterActivityDelegate<ExtArgs>;

  /**
   * `prisma.editorProfile`: Exposes CRUD operations for the **EditorProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EditorProfiles
    * const editorProfiles = await prisma.editorProfile.findMany()
    * ```
    */
  get editorProfile(): Prisma.EditorProfileDelegate<ExtArgs>;

  /**
   * `prisma.portfolioItem`: Exposes CRUD operations for the **PortfolioItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioItems
    * const portfolioItems = await prisma.portfolioItem.findMany()
    * ```
    */
  get portfolioItem(): Prisma.PortfolioItemDelegate<ExtArgs>;

  /**
   * `prisma.projectListing`: Exposes CRUD operations for the **ProjectListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectListings
    * const projectListings = await prisma.projectListing.findMany()
    * ```
    */
  get projectListing(): Prisma.ProjectListingDelegate<ExtArgs>;

  /**
   * `prisma.projectApplication`: Exposes CRUD operations for the **ProjectApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectApplications
    * const projectApplications = await prisma.projectApplication.findMany()
    * ```
    */
  get projectApplication(): Prisma.ProjectApplicationDelegate<ExtArgs>;

  /**
   * `prisma.projectContract`: Exposes CRUD operations for the **ProjectContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectContracts
    * const projectContracts = await prisma.projectContract.findMany()
    * ```
    */
  get projectContract(): Prisma.ProjectContractDelegate<ExtArgs>;

  /**
   * `prisma.chapterRevisionRequest`: Exposes CRUD operations for the **ChapterRevisionRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChapterRevisionRequests
    * const chapterRevisionRequests = await prisma.chapterRevisionRequest.findMany()
    * ```
    */
  get chapterRevisionRequest(): Prisma.ChapterRevisionRequestDelegate<ExtArgs>;

  /**
   * `prisma.editorReview`: Exposes CRUD operations for the **EditorReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EditorReviews
    * const editorReviews = await prisma.editorReview.findMany()
    * ```
    */
  get editorReview(): Prisma.EditorReviewDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    PasswordResetToken: 'PasswordResetToken',
    Work: 'Work',
    Creator: 'Creator',
    Chapter: 'Chapter',
    GlossaryItem: 'GlossaryItem',
    TranslationLog: 'TranslationLog',
    ActiveTranslationJob: 'ActiveTranslationJob',
    TranslationJobHistory: 'TranslationJobHistory',
    SettingBible: 'SettingBible',
    Character: 'Character',
    SettingTerm: 'SettingTerm',
    TimelineEvent: 'TimelineEvent',
    BibleGenerationJob: 'BibleGenerationJob',
    ChapterComment: 'ChapterComment',
    ChapterSnapshot: 'ChapterSnapshot',
    ChapterChange: 'ChapterChange',
    ChapterActivity: 'ChapterActivity',
    EditorProfile: 'EditorProfile',
    PortfolioItem: 'PortfolioItem',
    ProjectListing: 'ProjectListing',
    ProjectApplication: 'ProjectApplication',
    ProjectContract: 'ProjectContract',
    ChapterRevisionRequest: 'ChapterRevisionRequest',
    EditorReview: 'EditorReview'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "passwordResetToken" | "work" | "creator" | "chapter" | "glossaryItem" | "translationLog" | "activeTranslationJob" | "translationJobHistory" | "settingBible" | "character" | "settingTerm" | "timelineEvent" | "bibleGenerationJob" | "chapterComment" | "chapterSnapshot" | "chapterChange" | "chapterActivity" | "editorProfile" | "portfolioItem" | "projectListing" | "projectApplication" | "projectContract" | "chapterRevisionRequest" | "editorReview"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Work: {
        payload: Prisma.$WorkPayload<ExtArgs>
        fields: Prisma.WorkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkPayload>
          }
          findFirst: {
            args: Prisma.WorkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkPayload>
          }
          findMany: {
            args: Prisma.WorkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkPayload>[]
          }
          create: {
            args: Prisma.WorkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkPayload>
          }
          createMany: {
            args: Prisma.WorkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkPayload>[]
          }
          delete: {
            args: Prisma.WorkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkPayload>
          }
          update: {
            args: Prisma.WorkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkPayload>
          }
          deleteMany: {
            args: Prisma.WorkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkPayload>
          }
          aggregate: {
            args: Prisma.WorkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWork>
          }
          groupBy: {
            args: Prisma.WorkGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkCountArgs<ExtArgs>
            result: $Utils.Optional<WorkCountAggregateOutputType> | number
          }
        }
      }
      Creator: {
        payload: Prisma.$CreatorPayload<ExtArgs>
        fields: Prisma.CreatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          findFirst: {
            args: Prisma.CreatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          findMany: {
            args: Prisma.CreatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>[]
          }
          create: {
            args: Prisma.CreatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          createMany: {
            args: Prisma.CreatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>[]
          }
          delete: {
            args: Prisma.CreatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          update: {
            args: Prisma.CreatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          deleteMany: {
            args: Prisma.CreatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          aggregate: {
            args: Prisma.CreatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreator>
          }
          groupBy: {
            args: Prisma.CreatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatorCountArgs<ExtArgs>
            result: $Utils.Optional<CreatorCountAggregateOutputType> | number
          }
        }
      }
      Chapter: {
        payload: Prisma.$ChapterPayload<ExtArgs>
        fields: Prisma.ChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findFirst: {
            args: Prisma.ChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findMany: {
            args: Prisma.ChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          create: {
            args: Prisma.ChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          createMany: {
            args: Prisma.ChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          delete: {
            args: Prisma.ChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          update: {
            args: Prisma.ChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          deleteMany: {
            args: Prisma.ChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.ChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      GlossaryItem: {
        payload: Prisma.$GlossaryItemPayload<ExtArgs>
        fields: Prisma.GlossaryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlossaryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlossaryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryItemPayload>
          }
          findFirst: {
            args: Prisma.GlossaryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlossaryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryItemPayload>
          }
          findMany: {
            args: Prisma.GlossaryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryItemPayload>[]
          }
          create: {
            args: Prisma.GlossaryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryItemPayload>
          }
          createMany: {
            args: Prisma.GlossaryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlossaryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryItemPayload>[]
          }
          delete: {
            args: Prisma.GlossaryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryItemPayload>
          }
          update: {
            args: Prisma.GlossaryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryItemPayload>
          }
          deleteMany: {
            args: Prisma.GlossaryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlossaryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GlossaryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryItemPayload>
          }
          aggregate: {
            args: Prisma.GlossaryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlossaryItem>
          }
          groupBy: {
            args: Prisma.GlossaryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlossaryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlossaryItemCountArgs<ExtArgs>
            result: $Utils.Optional<GlossaryItemCountAggregateOutputType> | number
          }
        }
      }
      TranslationLog: {
        payload: Prisma.$TranslationLogPayload<ExtArgs>
        fields: Prisma.TranslationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranslationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranslationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationLogPayload>
          }
          findFirst: {
            args: Prisma.TranslationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranslationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationLogPayload>
          }
          findMany: {
            args: Prisma.TranslationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationLogPayload>[]
          }
          create: {
            args: Prisma.TranslationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationLogPayload>
          }
          createMany: {
            args: Prisma.TranslationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranslationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationLogPayload>[]
          }
          delete: {
            args: Prisma.TranslationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationLogPayload>
          }
          update: {
            args: Prisma.TranslationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationLogPayload>
          }
          deleteMany: {
            args: Prisma.TranslationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranslationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranslationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationLogPayload>
          }
          aggregate: {
            args: Prisma.TranslationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranslationLog>
          }
          groupBy: {
            args: Prisma.TranslationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranslationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranslationLogCountArgs<ExtArgs>
            result: $Utils.Optional<TranslationLogCountAggregateOutputType> | number
          }
        }
      }
      ActiveTranslationJob: {
        payload: Prisma.$ActiveTranslationJobPayload<ExtArgs>
        fields: Prisma.ActiveTranslationJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActiveTranslationJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveTranslationJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActiveTranslationJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveTranslationJobPayload>
          }
          findFirst: {
            args: Prisma.ActiveTranslationJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveTranslationJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActiveTranslationJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveTranslationJobPayload>
          }
          findMany: {
            args: Prisma.ActiveTranslationJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveTranslationJobPayload>[]
          }
          create: {
            args: Prisma.ActiveTranslationJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveTranslationJobPayload>
          }
          createMany: {
            args: Prisma.ActiveTranslationJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActiveTranslationJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveTranslationJobPayload>[]
          }
          delete: {
            args: Prisma.ActiveTranslationJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveTranslationJobPayload>
          }
          update: {
            args: Prisma.ActiveTranslationJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveTranslationJobPayload>
          }
          deleteMany: {
            args: Prisma.ActiveTranslationJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActiveTranslationJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActiveTranslationJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveTranslationJobPayload>
          }
          aggregate: {
            args: Prisma.ActiveTranslationJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActiveTranslationJob>
          }
          groupBy: {
            args: Prisma.ActiveTranslationJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActiveTranslationJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActiveTranslationJobCountArgs<ExtArgs>
            result: $Utils.Optional<ActiveTranslationJobCountAggregateOutputType> | number
          }
        }
      }
      TranslationJobHistory: {
        payload: Prisma.$TranslationJobHistoryPayload<ExtArgs>
        fields: Prisma.TranslationJobHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranslationJobHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationJobHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranslationJobHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationJobHistoryPayload>
          }
          findFirst: {
            args: Prisma.TranslationJobHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationJobHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranslationJobHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationJobHistoryPayload>
          }
          findMany: {
            args: Prisma.TranslationJobHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationJobHistoryPayload>[]
          }
          create: {
            args: Prisma.TranslationJobHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationJobHistoryPayload>
          }
          createMany: {
            args: Prisma.TranslationJobHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranslationJobHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationJobHistoryPayload>[]
          }
          delete: {
            args: Prisma.TranslationJobHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationJobHistoryPayload>
          }
          update: {
            args: Prisma.TranslationJobHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationJobHistoryPayload>
          }
          deleteMany: {
            args: Prisma.TranslationJobHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranslationJobHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranslationJobHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationJobHistoryPayload>
          }
          aggregate: {
            args: Prisma.TranslationJobHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranslationJobHistory>
          }
          groupBy: {
            args: Prisma.TranslationJobHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranslationJobHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranslationJobHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<TranslationJobHistoryCountAggregateOutputType> | number
          }
        }
      }
      SettingBible: {
        payload: Prisma.$SettingBiblePayload<ExtArgs>
        fields: Prisma.SettingBibleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingBibleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingBiblePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingBibleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingBiblePayload>
          }
          findFirst: {
            args: Prisma.SettingBibleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingBiblePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingBibleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingBiblePayload>
          }
          findMany: {
            args: Prisma.SettingBibleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingBiblePayload>[]
          }
          create: {
            args: Prisma.SettingBibleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingBiblePayload>
          }
          createMany: {
            args: Prisma.SettingBibleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingBibleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingBiblePayload>[]
          }
          delete: {
            args: Prisma.SettingBibleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingBiblePayload>
          }
          update: {
            args: Prisma.SettingBibleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingBiblePayload>
          }
          deleteMany: {
            args: Prisma.SettingBibleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingBibleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingBibleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingBiblePayload>
          }
          aggregate: {
            args: Prisma.SettingBibleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettingBible>
          }
          groupBy: {
            args: Prisma.SettingBibleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingBibleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingBibleCountArgs<ExtArgs>
            result: $Utils.Optional<SettingBibleCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      SettingTerm: {
        payload: Prisma.$SettingTermPayload<ExtArgs>
        fields: Prisma.SettingTermFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingTermFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTermPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingTermFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTermPayload>
          }
          findFirst: {
            args: Prisma.SettingTermFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTermPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingTermFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTermPayload>
          }
          findMany: {
            args: Prisma.SettingTermFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTermPayload>[]
          }
          create: {
            args: Prisma.SettingTermCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTermPayload>
          }
          createMany: {
            args: Prisma.SettingTermCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingTermCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTermPayload>[]
          }
          delete: {
            args: Prisma.SettingTermDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTermPayload>
          }
          update: {
            args: Prisma.SettingTermUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTermPayload>
          }
          deleteMany: {
            args: Prisma.SettingTermDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingTermUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingTermUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTermPayload>
          }
          aggregate: {
            args: Prisma.SettingTermAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettingTerm>
          }
          groupBy: {
            args: Prisma.SettingTermGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingTermGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingTermCountArgs<ExtArgs>
            result: $Utils.Optional<SettingTermCountAggregateOutputType> | number
          }
        }
      }
      TimelineEvent: {
        payload: Prisma.$TimelineEventPayload<ExtArgs>
        fields: Prisma.TimelineEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimelineEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimelineEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          findFirst: {
            args: Prisma.TimelineEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimelineEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          findMany: {
            args: Prisma.TimelineEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>[]
          }
          create: {
            args: Prisma.TimelineEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          createMany: {
            args: Prisma.TimelineEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimelineEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>[]
          }
          delete: {
            args: Prisma.TimelineEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          update: {
            args: Prisma.TimelineEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          deleteMany: {
            args: Prisma.TimelineEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimelineEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimelineEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          aggregate: {
            args: Prisma.TimelineEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimelineEvent>
          }
          groupBy: {
            args: Prisma.TimelineEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimelineEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimelineEventCountArgs<ExtArgs>
            result: $Utils.Optional<TimelineEventCountAggregateOutputType> | number
          }
        }
      }
      BibleGenerationJob: {
        payload: Prisma.$BibleGenerationJobPayload<ExtArgs>
        fields: Prisma.BibleGenerationJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BibleGenerationJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibleGenerationJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BibleGenerationJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibleGenerationJobPayload>
          }
          findFirst: {
            args: Prisma.BibleGenerationJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibleGenerationJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BibleGenerationJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibleGenerationJobPayload>
          }
          findMany: {
            args: Prisma.BibleGenerationJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibleGenerationJobPayload>[]
          }
          create: {
            args: Prisma.BibleGenerationJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibleGenerationJobPayload>
          }
          createMany: {
            args: Prisma.BibleGenerationJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BibleGenerationJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibleGenerationJobPayload>[]
          }
          delete: {
            args: Prisma.BibleGenerationJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibleGenerationJobPayload>
          }
          update: {
            args: Prisma.BibleGenerationJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibleGenerationJobPayload>
          }
          deleteMany: {
            args: Prisma.BibleGenerationJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BibleGenerationJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BibleGenerationJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibleGenerationJobPayload>
          }
          aggregate: {
            args: Prisma.BibleGenerationJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBibleGenerationJob>
          }
          groupBy: {
            args: Prisma.BibleGenerationJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<BibleGenerationJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.BibleGenerationJobCountArgs<ExtArgs>
            result: $Utils.Optional<BibleGenerationJobCountAggregateOutputType> | number
          }
        }
      }
      ChapterComment: {
        payload: Prisma.$ChapterCommentPayload<ExtArgs>
        fields: Prisma.ChapterCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterCommentPayload>
          }
          findFirst: {
            args: Prisma.ChapterCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterCommentPayload>
          }
          findMany: {
            args: Prisma.ChapterCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterCommentPayload>[]
          }
          create: {
            args: Prisma.ChapterCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterCommentPayload>
          }
          createMany: {
            args: Prisma.ChapterCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterCommentPayload>[]
          }
          delete: {
            args: Prisma.ChapterCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterCommentPayload>
          }
          update: {
            args: Prisma.ChapterCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterCommentPayload>
          }
          deleteMany: {
            args: Prisma.ChapterCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChapterCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterCommentPayload>
          }
          aggregate: {
            args: Prisma.ChapterCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapterComment>
          }
          groupBy: {
            args: Prisma.ChapterCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCommentCountAggregateOutputType> | number
          }
        }
      }
      ChapterSnapshot: {
        payload: Prisma.$ChapterSnapshotPayload<ExtArgs>
        fields: Prisma.ChapterSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterSnapshotPayload>
          }
          findFirst: {
            args: Prisma.ChapterSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterSnapshotPayload>
          }
          findMany: {
            args: Prisma.ChapterSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterSnapshotPayload>[]
          }
          create: {
            args: Prisma.ChapterSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterSnapshotPayload>
          }
          createMany: {
            args: Prisma.ChapterSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterSnapshotPayload>[]
          }
          delete: {
            args: Prisma.ChapterSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterSnapshotPayload>
          }
          update: {
            args: Prisma.ChapterSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.ChapterSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChapterSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterSnapshotPayload>
          }
          aggregate: {
            args: Prisma.ChapterSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapterSnapshot>
          }
          groupBy: {
            args: Prisma.ChapterSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterSnapshotCountAggregateOutputType> | number
          }
        }
      }
      ChapterChange: {
        payload: Prisma.$ChapterChangePayload<ExtArgs>
        fields: Prisma.ChapterChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterChangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterChangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChangePayload>
          }
          findFirst: {
            args: Prisma.ChapterChangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterChangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChangePayload>
          }
          findMany: {
            args: Prisma.ChapterChangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChangePayload>[]
          }
          create: {
            args: Prisma.ChapterChangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChangePayload>
          }
          createMany: {
            args: Prisma.ChapterChangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterChangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChangePayload>[]
          }
          delete: {
            args: Prisma.ChapterChangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChangePayload>
          }
          update: {
            args: Prisma.ChapterChangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChangePayload>
          }
          deleteMany: {
            args: Prisma.ChapterChangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterChangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChapterChangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChangePayload>
          }
          aggregate: {
            args: Prisma.ChapterChangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapterChange>
          }
          groupBy: {
            args: Prisma.ChapterChangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterChangeCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterChangeCountAggregateOutputType> | number
          }
        }
      }
      ChapterActivity: {
        payload: Prisma.$ChapterActivityPayload<ExtArgs>
        fields: Prisma.ChapterActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterActivityPayload>
          }
          findFirst: {
            args: Prisma.ChapterActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterActivityPayload>
          }
          findMany: {
            args: Prisma.ChapterActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterActivityPayload>[]
          }
          create: {
            args: Prisma.ChapterActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterActivityPayload>
          }
          createMany: {
            args: Prisma.ChapterActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterActivityPayload>[]
          }
          delete: {
            args: Prisma.ChapterActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterActivityPayload>
          }
          update: {
            args: Prisma.ChapterActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterActivityPayload>
          }
          deleteMany: {
            args: Prisma.ChapterActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChapterActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterActivityPayload>
          }
          aggregate: {
            args: Prisma.ChapterActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapterActivity>
          }
          groupBy: {
            args: Prisma.ChapterActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterActivityCountAggregateOutputType> | number
          }
        }
      }
      EditorProfile: {
        payload: Prisma.$EditorProfilePayload<ExtArgs>
        fields: Prisma.EditorProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EditorProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EditorProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorProfilePayload>
          }
          findFirst: {
            args: Prisma.EditorProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EditorProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorProfilePayload>
          }
          findMany: {
            args: Prisma.EditorProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorProfilePayload>[]
          }
          create: {
            args: Prisma.EditorProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorProfilePayload>
          }
          createMany: {
            args: Prisma.EditorProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EditorProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorProfilePayload>[]
          }
          delete: {
            args: Prisma.EditorProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorProfilePayload>
          }
          update: {
            args: Prisma.EditorProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorProfilePayload>
          }
          deleteMany: {
            args: Prisma.EditorProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EditorProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EditorProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorProfilePayload>
          }
          aggregate: {
            args: Prisma.EditorProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEditorProfile>
          }
          groupBy: {
            args: Prisma.EditorProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<EditorProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.EditorProfileCountArgs<ExtArgs>
            result: $Utils.Optional<EditorProfileCountAggregateOutputType> | number
          }
        }
      }
      PortfolioItem: {
        payload: Prisma.$PortfolioItemPayload<ExtArgs>
        fields: Prisma.PortfolioItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          findFirst: {
            args: Prisma.PortfolioItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          findMany: {
            args: Prisma.PortfolioItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>[]
          }
          create: {
            args: Prisma.PortfolioItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          createMany: {
            args: Prisma.PortfolioItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>[]
          }
          delete: {
            args: Prisma.PortfolioItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          update: {
            args: Prisma.PortfolioItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PortfolioItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          aggregate: {
            args: Prisma.PortfolioItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioItem>
          }
          groupBy: {
            args: Prisma.PortfolioItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioItemCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioItemCountAggregateOutputType> | number
          }
        }
      }
      ProjectListing: {
        payload: Prisma.$ProjectListingPayload<ExtArgs>
        fields: Prisma.ProjectListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectListingPayload>
          }
          findFirst: {
            args: Prisma.ProjectListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectListingPayload>
          }
          findMany: {
            args: Prisma.ProjectListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectListingPayload>[]
          }
          create: {
            args: Prisma.ProjectListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectListingPayload>
          }
          createMany: {
            args: Prisma.ProjectListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectListingPayload>[]
          }
          delete: {
            args: Prisma.ProjectListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectListingPayload>
          }
          update: {
            args: Prisma.ProjectListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectListingPayload>
          }
          deleteMany: {
            args: Prisma.ProjectListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectListingPayload>
          }
          aggregate: {
            args: Prisma.ProjectListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectListing>
          }
          groupBy: {
            args: Prisma.ProjectListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectListingCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectListingCountAggregateOutputType> | number
          }
        }
      }
      ProjectApplication: {
        payload: Prisma.$ProjectApplicationPayload<ExtArgs>
        fields: Prisma.ProjectApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectApplicationPayload>
          }
          findFirst: {
            args: Prisma.ProjectApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectApplicationPayload>
          }
          findMany: {
            args: Prisma.ProjectApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectApplicationPayload>[]
          }
          create: {
            args: Prisma.ProjectApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectApplicationPayload>
          }
          createMany: {
            args: Prisma.ProjectApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectApplicationPayload>[]
          }
          delete: {
            args: Prisma.ProjectApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectApplicationPayload>
          }
          update: {
            args: Prisma.ProjectApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ProjectApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectApplicationPayload>
          }
          aggregate: {
            args: Prisma.ProjectApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectApplication>
          }
          groupBy: {
            args: Prisma.ProjectApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectApplicationCountAggregateOutputType> | number
          }
        }
      }
      ProjectContract: {
        payload: Prisma.$ProjectContractPayload<ExtArgs>
        fields: Prisma.ProjectContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectContractPayload>
          }
          findFirst: {
            args: Prisma.ProjectContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectContractPayload>
          }
          findMany: {
            args: Prisma.ProjectContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectContractPayload>[]
          }
          create: {
            args: Prisma.ProjectContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectContractPayload>
          }
          createMany: {
            args: Prisma.ProjectContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectContractPayload>[]
          }
          delete: {
            args: Prisma.ProjectContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectContractPayload>
          }
          update: {
            args: Prisma.ProjectContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectContractPayload>
          }
          deleteMany: {
            args: Prisma.ProjectContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectContractPayload>
          }
          aggregate: {
            args: Prisma.ProjectContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectContract>
          }
          groupBy: {
            args: Prisma.ProjectContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectContractCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectContractCountAggregateOutputType> | number
          }
        }
      }
      ChapterRevisionRequest: {
        payload: Prisma.$ChapterRevisionRequestPayload<ExtArgs>
        fields: Prisma.ChapterRevisionRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterRevisionRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterRevisionRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterRevisionRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterRevisionRequestPayload>
          }
          findFirst: {
            args: Prisma.ChapterRevisionRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterRevisionRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterRevisionRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterRevisionRequestPayload>
          }
          findMany: {
            args: Prisma.ChapterRevisionRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterRevisionRequestPayload>[]
          }
          create: {
            args: Prisma.ChapterRevisionRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterRevisionRequestPayload>
          }
          createMany: {
            args: Prisma.ChapterRevisionRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterRevisionRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterRevisionRequestPayload>[]
          }
          delete: {
            args: Prisma.ChapterRevisionRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterRevisionRequestPayload>
          }
          update: {
            args: Prisma.ChapterRevisionRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterRevisionRequestPayload>
          }
          deleteMany: {
            args: Prisma.ChapterRevisionRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterRevisionRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChapterRevisionRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterRevisionRequestPayload>
          }
          aggregate: {
            args: Prisma.ChapterRevisionRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapterRevisionRequest>
          }
          groupBy: {
            args: Prisma.ChapterRevisionRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterRevisionRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterRevisionRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterRevisionRequestCountAggregateOutputType> | number
          }
        }
      }
      EditorReview: {
        payload: Prisma.$EditorReviewPayload<ExtArgs>
        fields: Prisma.EditorReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EditorReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EditorReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorReviewPayload>
          }
          findFirst: {
            args: Prisma.EditorReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EditorReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorReviewPayload>
          }
          findMany: {
            args: Prisma.EditorReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorReviewPayload>[]
          }
          create: {
            args: Prisma.EditorReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorReviewPayload>
          }
          createMany: {
            args: Prisma.EditorReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EditorReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorReviewPayload>[]
          }
          delete: {
            args: Prisma.EditorReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorReviewPayload>
          }
          update: {
            args: Prisma.EditorReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorReviewPayload>
          }
          deleteMany: {
            args: Prisma.EditorReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EditorReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EditorReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditorReviewPayload>
          }
          aggregate: {
            args: Prisma.EditorReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEditorReview>
          }
          groupBy: {
            args: Prisma.EditorReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<EditorReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.EditorReviewCountArgs<ExtArgs>
            result: $Utils.Optional<EditorReviewCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    works: number
    editingWorks: number
    accounts: number
    sessions: number
    lastEditedChapters: number
    comments: number
    resolvedComments: number
    snapshots: number
    changes: number
    reviewedChanges: number
    activities: number
    authorListings: number
    authorContracts: number
    editorContracts: number
    revisionRequests: number
    authorReviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    works?: boolean | UserCountOutputTypeCountWorksArgs
    editingWorks?: boolean | UserCountOutputTypeCountEditingWorksArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    lastEditedChapters?: boolean | UserCountOutputTypeCountLastEditedChaptersArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    resolvedComments?: boolean | UserCountOutputTypeCountResolvedCommentsArgs
    snapshots?: boolean | UserCountOutputTypeCountSnapshotsArgs
    changes?: boolean | UserCountOutputTypeCountChangesArgs
    reviewedChanges?: boolean | UserCountOutputTypeCountReviewedChangesArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    authorListings?: boolean | UserCountOutputTypeCountAuthorListingsArgs
    authorContracts?: boolean | UserCountOutputTypeCountAuthorContractsArgs
    editorContracts?: boolean | UserCountOutputTypeCountEditorContractsArgs
    revisionRequests?: boolean | UserCountOutputTypeCountRevisionRequestsArgs
    authorReviews?: boolean | UserCountOutputTypeCountAuthorReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEditingWorksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLastEditedChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResolvedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterSnapshotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterChangeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterChangeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthorListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectListingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthorContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectContractWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEditorContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectContractWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRevisionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterRevisionRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthorReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EditorReviewWhereInput
  }


  /**
   * Count Type WorkCountOutputType
   */

  export type WorkCountOutputType = {
    chapters: number
    glossary: number
    creators: number
    bibleJobs: number
    listings: number
    contracts: number
    reviews: number
  }

  export type WorkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | WorkCountOutputTypeCountChaptersArgs
    glossary?: boolean | WorkCountOutputTypeCountGlossaryArgs
    creators?: boolean | WorkCountOutputTypeCountCreatorsArgs
    bibleJobs?: boolean | WorkCountOutputTypeCountBibleJobsArgs
    listings?: boolean | WorkCountOutputTypeCountListingsArgs
    contracts?: boolean | WorkCountOutputTypeCountContractsArgs
    reviews?: boolean | WorkCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * WorkCountOutputType without action
   */
  export type WorkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCountOutputType
     */
    select?: WorkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkCountOutputType without action
   */
  export type WorkCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * WorkCountOutputType without action
   */
  export type WorkCountOutputTypeCountGlossaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlossaryItemWhereInput
  }

  /**
   * WorkCountOutputType without action
   */
  export type WorkCountOutputTypeCountCreatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatorWhereInput
  }

  /**
   * WorkCountOutputType without action
   */
  export type WorkCountOutputTypeCountBibleJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibleGenerationJobWhereInput
  }

  /**
   * WorkCountOutputType without action
   */
  export type WorkCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectListingWhereInput
  }

  /**
   * WorkCountOutputType without action
   */
  export type WorkCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectContractWhereInput
  }

  /**
   * WorkCountOutputType without action
   */
  export type WorkCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EditorReviewWhereInput
  }


  /**
   * Count Type ChapterCountOutputType
   */

  export type ChapterCountOutputType = {
    comments: number
    snapshots: number
    changes: number
    activities: number
    revisionRequests: number
  }

  export type ChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ChapterCountOutputTypeCountCommentsArgs
    snapshots?: boolean | ChapterCountOutputTypeCountSnapshotsArgs
    changes?: boolean | ChapterCountOutputTypeCountChangesArgs
    activities?: boolean | ChapterCountOutputTypeCountActivitiesArgs
    revisionRequests?: boolean | ChapterCountOutputTypeCountRevisionRequestsArgs
  }

  // Custom InputTypes
  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterCountOutputType
     */
    select?: ChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterCommentWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterSnapshotWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterChangeWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterActivityWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountRevisionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterRevisionRequestWhereInput
  }


  /**
   * Count Type SettingBibleCountOutputType
   */

  export type SettingBibleCountOutputType = {
    characters: number
    terms: number
    events: number
  }

  export type SettingBibleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | SettingBibleCountOutputTypeCountCharactersArgs
    terms?: boolean | SettingBibleCountOutputTypeCountTermsArgs
    events?: boolean | SettingBibleCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * SettingBibleCountOutputType without action
   */
  export type SettingBibleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBibleCountOutputType
     */
    select?: SettingBibleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SettingBibleCountOutputType without action
   */
  export type SettingBibleCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }

  /**
   * SettingBibleCountOutputType without action
   */
  export type SettingBibleCountOutputTypeCountTermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingTermWhereInput
  }

  /**
   * SettingBibleCountOutputType without action
   */
  export type SettingBibleCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimelineEventWhereInput
  }


  /**
   * Count Type ChapterCommentCountOutputType
   */

  export type ChapterCommentCountOutputType = {
    replies: number
  }

  export type ChapterCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | ChapterCommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * ChapterCommentCountOutputType without action
   */
  export type ChapterCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterCommentCountOutputType
     */
    select?: ChapterCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChapterCommentCountOutputType without action
   */
  export type ChapterCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterCommentWhereInput
  }


  /**
   * Count Type EditorProfileCountOutputType
   */

  export type EditorProfileCountOutputType = {
    portfolioItems: number
    applications: number
    reviews: number
  }

  export type EditorProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolioItems?: boolean | EditorProfileCountOutputTypeCountPortfolioItemsArgs
    applications?: boolean | EditorProfileCountOutputTypeCountApplicationsArgs
    reviews?: boolean | EditorProfileCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * EditorProfileCountOutputType without action
   */
  export type EditorProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfileCountOutputType
     */
    select?: EditorProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EditorProfileCountOutputType without action
   */
  export type EditorProfileCountOutputTypeCountPortfolioItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioItemWhereInput
  }

  /**
   * EditorProfileCountOutputType without action
   */
  export type EditorProfileCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectApplicationWhereInput
  }

  /**
   * EditorProfileCountOutputType without action
   */
  export type EditorProfileCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EditorReviewWhereInput
  }


  /**
   * Count Type ProjectListingCountOutputType
   */

  export type ProjectListingCountOutputType = {
    applications: number
  }

  export type ProjectListingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | ProjectListingCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * ProjectListingCountOutputType without action
   */
  export type ProjectListingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListingCountOutputType
     */
    select?: ProjectListingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectListingCountOutputType without action
   */
  export type ProjectListingCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectApplicationWhereInput
  }


  /**
   * Count Type ProjectContractCountOutputType
   */

  export type ProjectContractCountOutputType = {
    revisionRequests: number
  }

  export type ProjectContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    revisionRequests?: boolean | ProjectContractCountOutputTypeCountRevisionRequestsArgs
  }

  // Custom InputTypes
  /**
   * ProjectContractCountOutputType without action
   */
  export type ProjectContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContractCountOutputType
     */
    select?: ProjectContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectContractCountOutputType without action
   */
  export type ProjectContractCountOutputTypeCountRevisionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterRevisionRequestWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    image: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    image: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    image: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    image?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    image?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    image?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    name: string
    role: $Enums.UserRole
    image: string | null
    emailVerified: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    works?: boolean | User$worksArgs<ExtArgs>
    editingWorks?: boolean | User$editingWorksArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    lastEditedChapters?: boolean | User$lastEditedChaptersArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    resolvedComments?: boolean | User$resolvedCommentsArgs<ExtArgs>
    snapshots?: boolean | User$snapshotsArgs<ExtArgs>
    changes?: boolean | User$changesArgs<ExtArgs>
    reviewedChanges?: boolean | User$reviewedChangesArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    editorProfile?: boolean | User$editorProfileArgs<ExtArgs>
    authorListings?: boolean | User$authorListingsArgs<ExtArgs>
    authorContracts?: boolean | User$authorContractsArgs<ExtArgs>
    editorContracts?: boolean | User$editorContractsArgs<ExtArgs>
    revisionRequests?: boolean | User$revisionRequestsArgs<ExtArgs>
    authorReviews?: boolean | User$authorReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    works?: boolean | User$worksArgs<ExtArgs>
    editingWorks?: boolean | User$editingWorksArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    lastEditedChapters?: boolean | User$lastEditedChaptersArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    resolvedComments?: boolean | User$resolvedCommentsArgs<ExtArgs>
    snapshots?: boolean | User$snapshotsArgs<ExtArgs>
    changes?: boolean | User$changesArgs<ExtArgs>
    reviewedChanges?: boolean | User$reviewedChangesArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    editorProfile?: boolean | User$editorProfileArgs<ExtArgs>
    authorListings?: boolean | User$authorListingsArgs<ExtArgs>
    authorContracts?: boolean | User$authorContractsArgs<ExtArgs>
    editorContracts?: boolean | User$editorContractsArgs<ExtArgs>
    revisionRequests?: boolean | User$revisionRequestsArgs<ExtArgs>
    authorReviews?: boolean | User$authorReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      works: Prisma.$WorkPayload<ExtArgs>[]
      editingWorks: Prisma.$WorkPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      lastEditedChapters: Prisma.$ChapterPayload<ExtArgs>[]
      comments: Prisma.$ChapterCommentPayload<ExtArgs>[]
      resolvedComments: Prisma.$ChapterCommentPayload<ExtArgs>[]
      snapshots: Prisma.$ChapterSnapshotPayload<ExtArgs>[]
      changes: Prisma.$ChapterChangePayload<ExtArgs>[]
      reviewedChanges: Prisma.$ChapterChangePayload<ExtArgs>[]
      activities: Prisma.$ChapterActivityPayload<ExtArgs>[]
      editorProfile: Prisma.$EditorProfilePayload<ExtArgs> | null
      authorListings: Prisma.$ProjectListingPayload<ExtArgs>[]
      authorContracts: Prisma.$ProjectContractPayload<ExtArgs>[]
      editorContracts: Prisma.$ProjectContractPayload<ExtArgs>[]
      revisionRequests: Prisma.$ChapterRevisionRequestPayload<ExtArgs>[]
      authorReviews: Prisma.$EditorReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      name: string
      role: $Enums.UserRole
      image: string | null
      emailVerified: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    works<T extends User$worksArgs<ExtArgs> = {}>(args?: Subset<T, User$worksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findMany"> | Null>
    editingWorks<T extends User$editingWorksArgs<ExtArgs> = {}>(args?: Subset<T, User$editingWorksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    lastEditedChapters<T extends User$lastEditedChaptersArgs<ExtArgs> = {}>(args?: Subset<T, User$lastEditedChaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "findMany"> | Null>
    resolvedComments<T extends User$resolvedCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$resolvedCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "findMany"> | Null>
    snapshots<T extends User$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, User$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "findMany"> | Null>
    changes<T extends User$changesArgs<ExtArgs> = {}>(args?: Subset<T, User$changesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "findMany"> | Null>
    reviewedChanges<T extends User$reviewedChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "findMany"> | Null>
    editorProfile<T extends User$editorProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$editorProfileArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    authorListings<T extends User$authorListingsArgs<ExtArgs> = {}>(args?: Subset<T, User$authorListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "findMany"> | Null>
    authorContracts<T extends User$authorContractsArgs<ExtArgs> = {}>(args?: Subset<T, User$authorContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "findMany"> | Null>
    editorContracts<T extends User$editorContractsArgs<ExtArgs> = {}>(args?: Subset<T, User$editorContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "findMany"> | Null>
    revisionRequests<T extends User$revisionRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$revisionRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "findMany"> | Null>
    authorReviews<T extends User$authorReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$authorReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly image: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.works
   */
  export type User$worksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    where?: WorkWhereInput
    orderBy?: WorkOrderByWithRelationInput | WorkOrderByWithRelationInput[]
    cursor?: WorkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkScalarFieldEnum | WorkScalarFieldEnum[]
  }

  /**
   * User.editingWorks
   */
  export type User$editingWorksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    where?: WorkWhereInput
    orderBy?: WorkOrderByWithRelationInput | WorkOrderByWithRelationInput[]
    cursor?: WorkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkScalarFieldEnum | WorkScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.lastEditedChapters
   */
  export type User$lastEditedChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    where?: ChapterCommentWhereInput
    orderBy?: ChapterCommentOrderByWithRelationInput | ChapterCommentOrderByWithRelationInput[]
    cursor?: ChapterCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterCommentScalarFieldEnum | ChapterCommentScalarFieldEnum[]
  }

  /**
   * User.resolvedComments
   */
  export type User$resolvedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    where?: ChapterCommentWhereInput
    orderBy?: ChapterCommentOrderByWithRelationInput | ChapterCommentOrderByWithRelationInput[]
    cursor?: ChapterCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterCommentScalarFieldEnum | ChapterCommentScalarFieldEnum[]
  }

  /**
   * User.snapshots
   */
  export type User$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    where?: ChapterSnapshotWhereInput
    orderBy?: ChapterSnapshotOrderByWithRelationInput | ChapterSnapshotOrderByWithRelationInput[]
    cursor?: ChapterSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterSnapshotScalarFieldEnum | ChapterSnapshotScalarFieldEnum[]
  }

  /**
   * User.changes
   */
  export type User$changesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    where?: ChapterChangeWhereInput
    orderBy?: ChapterChangeOrderByWithRelationInput | ChapterChangeOrderByWithRelationInput[]
    cursor?: ChapterChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterChangeScalarFieldEnum | ChapterChangeScalarFieldEnum[]
  }

  /**
   * User.reviewedChanges
   */
  export type User$reviewedChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    where?: ChapterChangeWhereInput
    orderBy?: ChapterChangeOrderByWithRelationInput | ChapterChangeOrderByWithRelationInput[]
    cursor?: ChapterChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterChangeScalarFieldEnum | ChapterChangeScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    where?: ChapterActivityWhereInput
    orderBy?: ChapterActivityOrderByWithRelationInput | ChapterActivityOrderByWithRelationInput[]
    cursor?: ChapterActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterActivityScalarFieldEnum | ChapterActivityScalarFieldEnum[]
  }

  /**
   * User.editorProfile
   */
  export type User$editorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
    where?: EditorProfileWhereInput
  }

  /**
   * User.authorListings
   */
  export type User$authorListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    where?: ProjectListingWhereInput
    orderBy?: ProjectListingOrderByWithRelationInput | ProjectListingOrderByWithRelationInput[]
    cursor?: ProjectListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectListingScalarFieldEnum | ProjectListingScalarFieldEnum[]
  }

  /**
   * User.authorContracts
   */
  export type User$authorContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    where?: ProjectContractWhereInput
    orderBy?: ProjectContractOrderByWithRelationInput | ProjectContractOrderByWithRelationInput[]
    cursor?: ProjectContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectContractScalarFieldEnum | ProjectContractScalarFieldEnum[]
  }

  /**
   * User.editorContracts
   */
  export type User$editorContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    where?: ProjectContractWhereInput
    orderBy?: ProjectContractOrderByWithRelationInput | ProjectContractOrderByWithRelationInput[]
    cursor?: ProjectContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectContractScalarFieldEnum | ProjectContractScalarFieldEnum[]
  }

  /**
   * User.revisionRequests
   */
  export type User$revisionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    where?: ChapterRevisionRequestWhereInput
    orderBy?: ChapterRevisionRequestOrderByWithRelationInput | ChapterRevisionRequestOrderByWithRelationInput[]
    cursor?: ChapterRevisionRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterRevisionRequestScalarFieldEnum | ChapterRevisionRequestScalarFieldEnum[]
  }

  /**
   * User.authorReviews
   */
  export type User$authorReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    where?: EditorReviewWhereInput
    orderBy?: EditorReviewOrderByWithRelationInput | EditorReviewOrderByWithRelationInput[]
    cursor?: EditorReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EditorReviewScalarFieldEnum | EditorReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({ 
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }


  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
  }


  /**
   * Model Work
   */

  export type AggregateWork = {
    _count: WorkCountAggregateOutputType | null
    _avg: WorkAvgAggregateOutputType | null
    _sum: WorkSumAggregateOutputType | null
    _min: WorkMinAggregateOutputType | null
    _max: WorkMaxAggregateOutputType | null
  }

  export type WorkAvgAggregateOutputType = {
    expectedChapters: number | null
    totalChapters: number | null
  }

  export type WorkSumAggregateOutputType = {
    expectedChapters: number | null
    totalChapters: number | null
  }

  export type WorkMinAggregateOutputType = {
    id: string | null
    titleKo: string | null
    titleOriginal: string | null
    publisher: string | null
    ageRating: $Enums.AgeRating | null
    status: $Enums.WorkStatus | null
    coverImage: string | null
    synopsis: string | null
    originalStatus: $Enums.OriginalStatus | null
    sourceLanguage: $Enums.SourceLanguage | null
    expectedChapters: number | null
    platformName: string | null
    platformUrl: string | null
    publishedAt: Date | null
    totalChapters: number | null
    authorId: string | null
    editorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkMaxAggregateOutputType = {
    id: string | null
    titleKo: string | null
    titleOriginal: string | null
    publisher: string | null
    ageRating: $Enums.AgeRating | null
    status: $Enums.WorkStatus | null
    coverImage: string | null
    synopsis: string | null
    originalStatus: $Enums.OriginalStatus | null
    sourceLanguage: $Enums.SourceLanguage | null
    expectedChapters: number | null
    platformName: string | null
    platformUrl: string | null
    publishedAt: Date | null
    totalChapters: number | null
    authorId: string | null
    editorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkCountAggregateOutputType = {
    id: number
    titleKo: number
    titleOriginal: number
    publisher: number
    ageRating: number
    status: number
    coverImage: number
    synopsis: number
    genres: number
    originalStatus: number
    sourceLanguage: number
    expectedChapters: number
    platformName: number
    platformUrl: number
    publishedAt: number
    totalChapters: number
    authorId: number
    editorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkAvgAggregateInputType = {
    expectedChapters?: true
    totalChapters?: true
  }

  export type WorkSumAggregateInputType = {
    expectedChapters?: true
    totalChapters?: true
  }

  export type WorkMinAggregateInputType = {
    id?: true
    titleKo?: true
    titleOriginal?: true
    publisher?: true
    ageRating?: true
    status?: true
    coverImage?: true
    synopsis?: true
    originalStatus?: true
    sourceLanguage?: true
    expectedChapters?: true
    platformName?: true
    platformUrl?: true
    publishedAt?: true
    totalChapters?: true
    authorId?: true
    editorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkMaxAggregateInputType = {
    id?: true
    titleKo?: true
    titleOriginal?: true
    publisher?: true
    ageRating?: true
    status?: true
    coverImage?: true
    synopsis?: true
    originalStatus?: true
    sourceLanguage?: true
    expectedChapters?: true
    platformName?: true
    platformUrl?: true
    publishedAt?: true
    totalChapters?: true
    authorId?: true
    editorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkCountAggregateInputType = {
    id?: true
    titleKo?: true
    titleOriginal?: true
    publisher?: true
    ageRating?: true
    status?: true
    coverImage?: true
    synopsis?: true
    genres?: true
    originalStatus?: true
    sourceLanguage?: true
    expectedChapters?: true
    platformName?: true
    platformUrl?: true
    publishedAt?: true
    totalChapters?: true
    authorId?: true
    editorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Work to aggregate.
     */
    where?: WorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Works to fetch.
     */
    orderBy?: WorkOrderByWithRelationInput | WorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Works
    **/
    _count?: true | WorkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkMaxAggregateInputType
  }

  export type GetWorkAggregateType<T extends WorkAggregateArgs> = {
        [P in keyof T & keyof AggregateWork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWork[P]>
      : GetScalarType<T[P], AggregateWork[P]>
  }




  export type WorkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkWhereInput
    orderBy?: WorkOrderByWithAggregationInput | WorkOrderByWithAggregationInput[]
    by: WorkScalarFieldEnum[] | WorkScalarFieldEnum
    having?: WorkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkCountAggregateInputType | true
    _avg?: WorkAvgAggregateInputType
    _sum?: WorkSumAggregateInputType
    _min?: WorkMinAggregateInputType
    _max?: WorkMaxAggregateInputType
  }

  export type WorkGroupByOutputType = {
    id: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating: $Enums.AgeRating
    status: $Enums.WorkStatus
    coverImage: string | null
    synopsis: string
    genres: string[]
    originalStatus: $Enums.OriginalStatus
    sourceLanguage: $Enums.SourceLanguage
    expectedChapters: number | null
    platformName: string | null
    platformUrl: string | null
    publishedAt: Date | null
    totalChapters: number
    authorId: string
    editorId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkCountAggregateOutputType | null
    _avg: WorkAvgAggregateOutputType | null
    _sum: WorkSumAggregateOutputType | null
    _min: WorkMinAggregateOutputType | null
    _max: WorkMaxAggregateOutputType | null
  }

  type GetWorkGroupByPayload<T extends WorkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkGroupByOutputType[P]>
            : GetScalarType<T[P], WorkGroupByOutputType[P]>
        }
      >
    >


  export type WorkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleKo?: boolean
    titleOriginal?: boolean
    publisher?: boolean
    ageRating?: boolean
    status?: boolean
    coverImage?: boolean
    synopsis?: boolean
    genres?: boolean
    originalStatus?: boolean
    sourceLanguage?: boolean
    expectedChapters?: boolean
    platformName?: boolean
    platformUrl?: boolean
    publishedAt?: boolean
    totalChapters?: boolean
    authorId?: boolean
    editorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    editor?: boolean | Work$editorArgs<ExtArgs>
    chapters?: boolean | Work$chaptersArgs<ExtArgs>
    glossary?: boolean | Work$glossaryArgs<ExtArgs>
    creators?: boolean | Work$creatorsArgs<ExtArgs>
    settingBible?: boolean | Work$settingBibleArgs<ExtArgs>
    bibleJobs?: boolean | Work$bibleJobsArgs<ExtArgs>
    listings?: boolean | Work$listingsArgs<ExtArgs>
    contracts?: boolean | Work$contractsArgs<ExtArgs>
    reviews?: boolean | Work$reviewsArgs<ExtArgs>
    _count?: boolean | WorkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work"]>

  export type WorkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleKo?: boolean
    titleOriginal?: boolean
    publisher?: boolean
    ageRating?: boolean
    status?: boolean
    coverImage?: boolean
    synopsis?: boolean
    genres?: boolean
    originalStatus?: boolean
    sourceLanguage?: boolean
    expectedChapters?: boolean
    platformName?: boolean
    platformUrl?: boolean
    publishedAt?: boolean
    totalChapters?: boolean
    authorId?: boolean
    editorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    editor?: boolean | Work$editorArgs<ExtArgs>
  }, ExtArgs["result"]["work"]>

  export type WorkSelectScalar = {
    id?: boolean
    titleKo?: boolean
    titleOriginal?: boolean
    publisher?: boolean
    ageRating?: boolean
    status?: boolean
    coverImage?: boolean
    synopsis?: boolean
    genres?: boolean
    originalStatus?: boolean
    sourceLanguage?: boolean
    expectedChapters?: boolean
    platformName?: boolean
    platformUrl?: boolean
    publishedAt?: boolean
    totalChapters?: boolean
    authorId?: boolean
    editorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    editor?: boolean | Work$editorArgs<ExtArgs>
    chapters?: boolean | Work$chaptersArgs<ExtArgs>
    glossary?: boolean | Work$glossaryArgs<ExtArgs>
    creators?: boolean | Work$creatorsArgs<ExtArgs>
    settingBible?: boolean | Work$settingBibleArgs<ExtArgs>
    bibleJobs?: boolean | Work$bibleJobsArgs<ExtArgs>
    listings?: boolean | Work$listingsArgs<ExtArgs>
    contracts?: boolean | Work$contractsArgs<ExtArgs>
    reviews?: boolean | Work$reviewsArgs<ExtArgs>
    _count?: boolean | WorkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    editor?: boolean | Work$editorArgs<ExtArgs>
  }

  export type $WorkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Work"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      editor: Prisma.$UserPayload<ExtArgs> | null
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      glossary: Prisma.$GlossaryItemPayload<ExtArgs>[]
      creators: Prisma.$CreatorPayload<ExtArgs>[]
      settingBible: Prisma.$SettingBiblePayload<ExtArgs> | null
      bibleJobs: Prisma.$BibleGenerationJobPayload<ExtArgs>[]
      listings: Prisma.$ProjectListingPayload<ExtArgs>[]
      contracts: Prisma.$ProjectContractPayload<ExtArgs>[]
      reviews: Prisma.$EditorReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titleKo: string
      titleOriginal: string
      publisher: string
      ageRating: $Enums.AgeRating
      status: $Enums.WorkStatus
      coverImage: string | null
      synopsis: string
      genres: string[]
      originalStatus: $Enums.OriginalStatus
      sourceLanguage: $Enums.SourceLanguage
      expectedChapters: number | null
      platformName: string | null
      platformUrl: string | null
      publishedAt: Date | null
      totalChapters: number
      authorId: string
      editorId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["work"]>
    composites: {}
  }

  type WorkGetPayload<S extends boolean | null | undefined | WorkDefaultArgs> = $Result.GetResult<Prisma.$WorkPayload, S>

  type WorkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkCountAggregateInputType | true
    }

  export interface WorkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Work'], meta: { name: 'Work' } }
    /**
     * Find zero or one Work that matches the filter.
     * @param {WorkFindUniqueArgs} args - Arguments to find a Work
     * @example
     * // Get one Work
     * const work = await prisma.work.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkFindUniqueArgs>(args: SelectSubset<T, WorkFindUniqueArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Work that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkFindUniqueOrThrowArgs} args - Arguments to find a Work
     * @example
     * // Get one Work
     * const work = await prisma.work.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Work that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFindFirstArgs} args - Arguments to find a Work
     * @example
     * // Get one Work
     * const work = await prisma.work.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkFindFirstArgs>(args?: SelectSubset<T, WorkFindFirstArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Work that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFindFirstOrThrowArgs} args - Arguments to find a Work
     * @example
     * // Get one Work
     * const work = await prisma.work.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Works that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Works
     * const works = await prisma.work.findMany()
     * 
     * // Get first 10 Works
     * const works = await prisma.work.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workWithIdOnly = await prisma.work.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkFindManyArgs>(args?: SelectSubset<T, WorkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Work.
     * @param {WorkCreateArgs} args - Arguments to create a Work.
     * @example
     * // Create one Work
     * const Work = await prisma.work.create({
     *   data: {
     *     // ... data to create a Work
     *   }
     * })
     * 
     */
    create<T extends WorkCreateArgs>(args: SelectSubset<T, WorkCreateArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Works.
     * @param {WorkCreateManyArgs} args - Arguments to create many Works.
     * @example
     * // Create many Works
     * const work = await prisma.work.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkCreateManyArgs>(args?: SelectSubset<T, WorkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Works and returns the data saved in the database.
     * @param {WorkCreateManyAndReturnArgs} args - Arguments to create many Works.
     * @example
     * // Create many Works
     * const work = await prisma.work.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Works and only return the `id`
     * const workWithIdOnly = await prisma.work.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Work.
     * @param {WorkDeleteArgs} args - Arguments to delete one Work.
     * @example
     * // Delete one Work
     * const Work = await prisma.work.delete({
     *   where: {
     *     // ... filter to delete one Work
     *   }
     * })
     * 
     */
    delete<T extends WorkDeleteArgs>(args: SelectSubset<T, WorkDeleteArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Work.
     * @param {WorkUpdateArgs} args - Arguments to update one Work.
     * @example
     * // Update one Work
     * const work = await prisma.work.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkUpdateArgs>(args: SelectSubset<T, WorkUpdateArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Works.
     * @param {WorkDeleteManyArgs} args - Arguments to filter Works to delete.
     * @example
     * // Delete a few Works
     * const { count } = await prisma.work.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkDeleteManyArgs>(args?: SelectSubset<T, WorkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Works.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Works
     * const work = await prisma.work.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkUpdateManyArgs>(args: SelectSubset<T, WorkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Work.
     * @param {WorkUpsertArgs} args - Arguments to update or create a Work.
     * @example
     * // Update or create a Work
     * const work = await prisma.work.upsert({
     *   create: {
     *     // ... data to create a Work
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Work we want to update
     *   }
     * })
     */
    upsert<T extends WorkUpsertArgs>(args: SelectSubset<T, WorkUpsertArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Works.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkCountArgs} args - Arguments to filter Works to count.
     * @example
     * // Count the number of Works
     * const count = await prisma.work.count({
     *   where: {
     *     // ... the filter for the Works we want to count
     *   }
     * })
    **/
    count<T extends WorkCountArgs>(
      args?: Subset<T, WorkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Work.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkAggregateArgs>(args: Subset<T, WorkAggregateArgs>): Prisma.PrismaPromise<GetWorkAggregateType<T>>

    /**
     * Group by Work.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkGroupByArgs['orderBy'] }
        : { orderBy?: WorkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Work model
   */
  readonly fields: WorkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Work.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    editor<T extends Work$editorArgs<ExtArgs> = {}>(args?: Subset<T, Work$editorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    chapters<T extends Work$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Work$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany"> | Null>
    glossary<T extends Work$glossaryArgs<ExtArgs> = {}>(args?: Subset<T, Work$glossaryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "findMany"> | Null>
    creators<T extends Work$creatorsArgs<ExtArgs> = {}>(args?: Subset<T, Work$creatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findMany"> | Null>
    settingBible<T extends Work$settingBibleArgs<ExtArgs> = {}>(args?: Subset<T, Work$settingBibleArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    bibleJobs<T extends Work$bibleJobsArgs<ExtArgs> = {}>(args?: Subset<T, Work$bibleJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "findMany"> | Null>
    listings<T extends Work$listingsArgs<ExtArgs> = {}>(args?: Subset<T, Work$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "findMany"> | Null>
    contracts<T extends Work$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Work$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Work$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Work$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Work model
   */ 
  interface WorkFieldRefs {
    readonly id: FieldRef<"Work", 'String'>
    readonly titleKo: FieldRef<"Work", 'String'>
    readonly titleOriginal: FieldRef<"Work", 'String'>
    readonly publisher: FieldRef<"Work", 'String'>
    readonly ageRating: FieldRef<"Work", 'AgeRating'>
    readonly status: FieldRef<"Work", 'WorkStatus'>
    readonly coverImage: FieldRef<"Work", 'String'>
    readonly synopsis: FieldRef<"Work", 'String'>
    readonly genres: FieldRef<"Work", 'String[]'>
    readonly originalStatus: FieldRef<"Work", 'OriginalStatus'>
    readonly sourceLanguage: FieldRef<"Work", 'SourceLanguage'>
    readonly expectedChapters: FieldRef<"Work", 'Int'>
    readonly platformName: FieldRef<"Work", 'String'>
    readonly platformUrl: FieldRef<"Work", 'String'>
    readonly publishedAt: FieldRef<"Work", 'DateTime'>
    readonly totalChapters: FieldRef<"Work", 'Int'>
    readonly authorId: FieldRef<"Work", 'String'>
    readonly editorId: FieldRef<"Work", 'String'>
    readonly createdAt: FieldRef<"Work", 'DateTime'>
    readonly updatedAt: FieldRef<"Work", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Work findUnique
   */
  export type WorkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    /**
     * Filter, which Work to fetch.
     */
    where: WorkWhereUniqueInput
  }

  /**
   * Work findUniqueOrThrow
   */
  export type WorkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    /**
     * Filter, which Work to fetch.
     */
    where: WorkWhereUniqueInput
  }

  /**
   * Work findFirst
   */
  export type WorkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    /**
     * Filter, which Work to fetch.
     */
    where?: WorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Works to fetch.
     */
    orderBy?: WorkOrderByWithRelationInput | WorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Works.
     */
    cursor?: WorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Works.
     */
    distinct?: WorkScalarFieldEnum | WorkScalarFieldEnum[]
  }

  /**
   * Work findFirstOrThrow
   */
  export type WorkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    /**
     * Filter, which Work to fetch.
     */
    where?: WorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Works to fetch.
     */
    orderBy?: WorkOrderByWithRelationInput | WorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Works.
     */
    cursor?: WorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Works.
     */
    distinct?: WorkScalarFieldEnum | WorkScalarFieldEnum[]
  }

  /**
   * Work findMany
   */
  export type WorkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    /**
     * Filter, which Works to fetch.
     */
    where?: WorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Works to fetch.
     */
    orderBy?: WorkOrderByWithRelationInput | WorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Works.
     */
    cursor?: WorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Works.
     */
    skip?: number
    distinct?: WorkScalarFieldEnum | WorkScalarFieldEnum[]
  }

  /**
   * Work create
   */
  export type WorkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    /**
     * The data needed to create a Work.
     */
    data: XOR<WorkCreateInput, WorkUncheckedCreateInput>
  }

  /**
   * Work createMany
   */
  export type WorkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Works.
     */
    data: WorkCreateManyInput | WorkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Work createManyAndReturn
   */
  export type WorkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Works.
     */
    data: WorkCreateManyInput | WorkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Work update
   */
  export type WorkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    /**
     * The data needed to update a Work.
     */
    data: XOR<WorkUpdateInput, WorkUncheckedUpdateInput>
    /**
     * Choose, which Work to update.
     */
    where: WorkWhereUniqueInput
  }

  /**
   * Work updateMany
   */
  export type WorkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Works.
     */
    data: XOR<WorkUpdateManyMutationInput, WorkUncheckedUpdateManyInput>
    /**
     * Filter which Works to update
     */
    where?: WorkWhereInput
  }

  /**
   * Work upsert
   */
  export type WorkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    /**
     * The filter to search for the Work to update in case it exists.
     */
    where: WorkWhereUniqueInput
    /**
     * In case the Work found by the `where` argument doesn't exist, create a new Work with this data.
     */
    create: XOR<WorkCreateInput, WorkUncheckedCreateInput>
    /**
     * In case the Work was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkUpdateInput, WorkUncheckedUpdateInput>
  }

  /**
   * Work delete
   */
  export type WorkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
    /**
     * Filter which Work to delete.
     */
    where: WorkWhereUniqueInput
  }

  /**
   * Work deleteMany
   */
  export type WorkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Works to delete
     */
    where?: WorkWhereInput
  }

  /**
   * Work.editor
   */
  export type Work$editorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Work.chapters
   */
  export type Work$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Work.glossary
   */
  export type Work$glossaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
    where?: GlossaryItemWhereInput
    orderBy?: GlossaryItemOrderByWithRelationInput | GlossaryItemOrderByWithRelationInput[]
    cursor?: GlossaryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GlossaryItemScalarFieldEnum | GlossaryItemScalarFieldEnum[]
  }

  /**
   * Work.creators
   */
  export type Work$creatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    where?: CreatorWhereInput
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    cursor?: CreatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
  }

  /**
   * Work.settingBible
   */
  export type Work$settingBibleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
    where?: SettingBibleWhereInput
  }

  /**
   * Work.bibleJobs
   */
  export type Work$bibleJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
    where?: BibleGenerationJobWhereInput
    orderBy?: BibleGenerationJobOrderByWithRelationInput | BibleGenerationJobOrderByWithRelationInput[]
    cursor?: BibleGenerationJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BibleGenerationJobScalarFieldEnum | BibleGenerationJobScalarFieldEnum[]
  }

  /**
   * Work.listings
   */
  export type Work$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    where?: ProjectListingWhereInput
    orderBy?: ProjectListingOrderByWithRelationInput | ProjectListingOrderByWithRelationInput[]
    cursor?: ProjectListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectListingScalarFieldEnum | ProjectListingScalarFieldEnum[]
  }

  /**
   * Work.contracts
   */
  export type Work$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    where?: ProjectContractWhereInput
    orderBy?: ProjectContractOrderByWithRelationInput | ProjectContractOrderByWithRelationInput[]
    cursor?: ProjectContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectContractScalarFieldEnum | ProjectContractScalarFieldEnum[]
  }

  /**
   * Work.reviews
   */
  export type Work$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    where?: EditorReviewWhereInput
    orderBy?: EditorReviewOrderByWithRelationInput | EditorReviewOrderByWithRelationInput[]
    cursor?: EditorReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EditorReviewScalarFieldEnum | EditorReviewScalarFieldEnum[]
  }

  /**
   * Work without action
   */
  export type WorkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkInclude<ExtArgs> | null
  }


  /**
   * Model Creator
   */

  export type AggregateCreator = {
    _count: CreatorCountAggregateOutputType | null
    _min: CreatorMinAggregateOutputType | null
    _max: CreatorMaxAggregateOutputType | null
  }

  export type CreatorMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    workId: string | null
  }

  export type CreatorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    workId: string | null
  }

  export type CreatorCountAggregateOutputType = {
    id: number
    name: number
    role: number
    workId: number
    _all: number
  }


  export type CreatorMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    workId?: true
  }

  export type CreatorMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    workId?: true
  }

  export type CreatorCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    workId?: true
    _all?: true
  }

  export type CreatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creator to aggregate.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creators
    **/
    _count?: true | CreatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatorMaxAggregateInputType
  }

  export type GetCreatorAggregateType<T extends CreatorAggregateArgs> = {
        [P in keyof T & keyof AggregateCreator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreator[P]>
      : GetScalarType<T[P], AggregateCreator[P]>
  }




  export type CreatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatorWhereInput
    orderBy?: CreatorOrderByWithAggregationInput | CreatorOrderByWithAggregationInput[]
    by: CreatorScalarFieldEnum[] | CreatorScalarFieldEnum
    having?: CreatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatorCountAggregateInputType | true
    _min?: CreatorMinAggregateInputType
    _max?: CreatorMaxAggregateInputType
  }

  export type CreatorGroupByOutputType = {
    id: string
    name: string
    role: string
    workId: string
    _count: CreatorCountAggregateOutputType | null
    _min: CreatorMinAggregateOutputType | null
    _max: CreatorMaxAggregateOutputType | null
  }

  type GetCreatorGroupByPayload<T extends CreatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatorGroupByOutputType[P]>
            : GetScalarType<T[P], CreatorGroupByOutputType[P]>
        }
      >
    >


  export type CreatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    workId?: boolean
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creator"]>

  export type CreatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    workId?: boolean
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creator"]>

  export type CreatorSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    workId?: boolean
  }

  export type CreatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }
  export type CreatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }

  export type $CreatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Creator"
    objects: {
      work: Prisma.$WorkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      workId: string
    }, ExtArgs["result"]["creator"]>
    composites: {}
  }

  type CreatorGetPayload<S extends boolean | null | undefined | CreatorDefaultArgs> = $Result.GetResult<Prisma.$CreatorPayload, S>

  type CreatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreatorCountAggregateInputType | true
    }

  export interface CreatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Creator'], meta: { name: 'Creator' } }
    /**
     * Find zero or one Creator that matches the filter.
     * @param {CreatorFindUniqueArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatorFindUniqueArgs>(args: SelectSubset<T, CreatorFindUniqueArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Creator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreatorFindUniqueOrThrowArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatorFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Creator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindFirstArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatorFindFirstArgs>(args?: SelectSubset<T, CreatorFindFirstArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Creator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindFirstOrThrowArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatorFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Creators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creators
     * const creators = await prisma.creator.findMany()
     * 
     * // Get first 10 Creators
     * const creators = await prisma.creator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatorWithIdOnly = await prisma.creator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatorFindManyArgs>(args?: SelectSubset<T, CreatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Creator.
     * @param {CreatorCreateArgs} args - Arguments to create a Creator.
     * @example
     * // Create one Creator
     * const Creator = await prisma.creator.create({
     *   data: {
     *     // ... data to create a Creator
     *   }
     * })
     * 
     */
    create<T extends CreatorCreateArgs>(args: SelectSubset<T, CreatorCreateArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Creators.
     * @param {CreatorCreateManyArgs} args - Arguments to create many Creators.
     * @example
     * // Create many Creators
     * const creator = await prisma.creator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatorCreateManyArgs>(args?: SelectSubset<T, CreatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Creators and returns the data saved in the database.
     * @param {CreatorCreateManyAndReturnArgs} args - Arguments to create many Creators.
     * @example
     * // Create many Creators
     * const creator = await prisma.creator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Creators and only return the `id`
     * const creatorWithIdOnly = await prisma.creator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatorCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Creator.
     * @param {CreatorDeleteArgs} args - Arguments to delete one Creator.
     * @example
     * // Delete one Creator
     * const Creator = await prisma.creator.delete({
     *   where: {
     *     // ... filter to delete one Creator
     *   }
     * })
     * 
     */
    delete<T extends CreatorDeleteArgs>(args: SelectSubset<T, CreatorDeleteArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Creator.
     * @param {CreatorUpdateArgs} args - Arguments to update one Creator.
     * @example
     * // Update one Creator
     * const creator = await prisma.creator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatorUpdateArgs>(args: SelectSubset<T, CreatorUpdateArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Creators.
     * @param {CreatorDeleteManyArgs} args - Arguments to filter Creators to delete.
     * @example
     * // Delete a few Creators
     * const { count } = await prisma.creator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatorDeleteManyArgs>(args?: SelectSubset<T, CreatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creators
     * const creator = await prisma.creator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatorUpdateManyArgs>(args: SelectSubset<T, CreatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Creator.
     * @param {CreatorUpsertArgs} args - Arguments to update or create a Creator.
     * @example
     * // Update or create a Creator
     * const creator = await prisma.creator.upsert({
     *   create: {
     *     // ... data to create a Creator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creator we want to update
     *   }
     * })
     */
    upsert<T extends CreatorUpsertArgs>(args: SelectSubset<T, CreatorUpsertArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Creators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorCountArgs} args - Arguments to filter Creators to count.
     * @example
     * // Count the number of Creators
     * const count = await prisma.creator.count({
     *   where: {
     *     // ... the filter for the Creators we want to count
     *   }
     * })
    **/
    count<T extends CreatorCountArgs>(
      args?: Subset<T, CreatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatorAggregateArgs>(args: Subset<T, CreatorAggregateArgs>): Prisma.PrismaPromise<GetCreatorAggregateType<T>>

    /**
     * Group by Creator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatorGroupByArgs['orderBy'] }
        : { orderBy?: CreatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Creator model
   */
  readonly fields: CreatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Creator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work<T extends WorkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkDefaultArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Creator model
   */ 
  interface CreatorFieldRefs {
    readonly id: FieldRef<"Creator", 'String'>
    readonly name: FieldRef<"Creator", 'String'>
    readonly role: FieldRef<"Creator", 'String'>
    readonly workId: FieldRef<"Creator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Creator findUnique
   */
  export type CreatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator findUniqueOrThrow
   */
  export type CreatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator findFirst
   */
  export type CreatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creators.
     */
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
  }

  /**
   * Creator findFirstOrThrow
   */
  export type CreatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creators.
     */
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
  }

  /**
   * Creator findMany
   */
  export type CreatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creators to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
  }

  /**
   * Creator create
   */
  export type CreatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Creator.
     */
    data: XOR<CreatorCreateInput, CreatorUncheckedCreateInput>
  }

  /**
   * Creator createMany
   */
  export type CreatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creators.
     */
    data: CreatorCreateManyInput | CreatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creator createManyAndReturn
   */
  export type CreatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Creators.
     */
    data: CreatorCreateManyInput | CreatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Creator update
   */
  export type CreatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Creator.
     */
    data: XOR<CreatorUpdateInput, CreatorUncheckedUpdateInput>
    /**
     * Choose, which Creator to update.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator updateMany
   */
  export type CreatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creators.
     */
    data: XOR<CreatorUpdateManyMutationInput, CreatorUncheckedUpdateManyInput>
    /**
     * Filter which Creators to update
     */
    where?: CreatorWhereInput
  }

  /**
   * Creator upsert
   */
  export type CreatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Creator to update in case it exists.
     */
    where: CreatorWhereUniqueInput
    /**
     * In case the Creator found by the `where` argument doesn't exist, create a new Creator with this data.
     */
    create: XOR<CreatorCreateInput, CreatorUncheckedCreateInput>
    /**
     * In case the Creator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatorUpdateInput, CreatorUncheckedUpdateInput>
  }

  /**
   * Creator delete
   */
  export type CreatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter which Creator to delete.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator deleteMany
   */
  export type CreatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creators to delete
     */
    where?: CreatorWhereInput
  }

  /**
   * Creator without action
   */
  export type CreatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
  }


  /**
   * Model Chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    number: number | null
    wordCount: number | null
  }

  export type ChapterSumAggregateOutputType = {
    number: number | null
    wordCount: number | null
  }

  export type ChapterMinAggregateOutputType = {
    id: string | null
    number: number | null
    title: string | null
    originalContent: string | null
    translatedContent: string | null
    editedContent: string | null
    status: $Enums.ChapterStatus | null
    wordCount: number | null
    lastEditedById: string | null
    lastEditedAt: Date | null
    workId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: string | null
    number: number | null
    title: string | null
    originalContent: string | null
    translatedContent: string | null
    editedContent: string | null
    status: $Enums.ChapterStatus | null
    wordCount: number | null
    lastEditedById: string | null
    lastEditedAt: Date | null
    workId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    number: number
    title: number
    originalContent: number
    translatedContent: number
    editedContent: number
    status: number
    wordCount: number
    translationMeta: number
    trackChangesState: number
    lastEditedById: number
    lastEditedAt: number
    workId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    number?: true
    wordCount?: true
  }

  export type ChapterSumAggregateInputType = {
    number?: true
    wordCount?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    number?: true
    title?: true
    originalContent?: true
    translatedContent?: true
    editedContent?: true
    status?: true
    wordCount?: true
    lastEditedById?: true
    lastEditedAt?: true
    workId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    number?: true
    title?: true
    originalContent?: true
    translatedContent?: true
    editedContent?: true
    status?: true
    wordCount?: true
    lastEditedById?: true
    lastEditedAt?: true
    workId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    number?: true
    title?: true
    originalContent?: true
    translatedContent?: true
    editedContent?: true
    status?: true
    wordCount?: true
    translationMeta?: true
    trackChangesState?: true
    lastEditedById?: true
    lastEditedAt?: true
    workId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapter to aggregate.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type ChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithAggregationInput | ChapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: ChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: string
    number: number
    title: string | null
    originalContent: string
    translatedContent: string | null
    editedContent: string | null
    status: $Enums.ChapterStatus
    wordCount: number
    translationMeta: JsonValue | null
    trackChangesState: JsonValue | null
    lastEditedById: string | null
    lastEditedAt: Date | null
    workId: string
    createdAt: Date
    updatedAt: Date
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends ChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    title?: boolean
    originalContent?: boolean
    translatedContent?: boolean
    editedContent?: boolean
    status?: boolean
    wordCount?: boolean
    translationMeta?: boolean
    trackChangesState?: boolean
    lastEditedById?: boolean
    lastEditedAt?: boolean
    workId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastEditedBy?: boolean | Chapter$lastEditedByArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
    comments?: boolean | Chapter$commentsArgs<ExtArgs>
    snapshots?: boolean | Chapter$snapshotsArgs<ExtArgs>
    changes?: boolean | Chapter$changesArgs<ExtArgs>
    activities?: boolean | Chapter$activitiesArgs<ExtArgs>
    revisionRequests?: boolean | Chapter$revisionRequestsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    title?: boolean
    originalContent?: boolean
    translatedContent?: boolean
    editedContent?: boolean
    status?: boolean
    wordCount?: boolean
    translationMeta?: boolean
    trackChangesState?: boolean
    lastEditedById?: boolean
    lastEditedAt?: boolean
    workId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastEditedBy?: boolean | Chapter$lastEditedByArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectScalar = {
    id?: boolean
    number?: boolean
    title?: boolean
    originalContent?: boolean
    translatedContent?: boolean
    editedContent?: boolean
    status?: boolean
    wordCount?: boolean
    translationMeta?: boolean
    trackChangesState?: boolean
    lastEditedById?: boolean
    lastEditedAt?: boolean
    workId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastEditedBy?: boolean | Chapter$lastEditedByArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
    comments?: boolean | Chapter$commentsArgs<ExtArgs>
    snapshots?: boolean | Chapter$snapshotsArgs<ExtArgs>
    changes?: boolean | Chapter$changesArgs<ExtArgs>
    activities?: boolean | Chapter$activitiesArgs<ExtArgs>
    revisionRequests?: boolean | Chapter$revisionRequestsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastEditedBy?: boolean | Chapter$lastEditedByArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }

  export type $ChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapter"
    objects: {
      lastEditedBy: Prisma.$UserPayload<ExtArgs> | null
      work: Prisma.$WorkPayload<ExtArgs>
      comments: Prisma.$ChapterCommentPayload<ExtArgs>[]
      snapshots: Prisma.$ChapterSnapshotPayload<ExtArgs>[]
      changes: Prisma.$ChapterChangePayload<ExtArgs>[]
      activities: Prisma.$ChapterActivityPayload<ExtArgs>[]
      revisionRequests: Prisma.$ChapterRevisionRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: number
      title: string | null
      originalContent: string
      translatedContent: string | null
      editedContent: string | null
      status: $Enums.ChapterStatus
      wordCount: number
      translationMeta: Prisma.JsonValue | null
      trackChangesState: Prisma.JsonValue | null
      lastEditedById: string | null
      lastEditedAt: Date | null
      workId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type ChapterGetPayload<S extends boolean | null | undefined | ChapterDefaultArgs> = $Result.GetResult<Prisma.$ChapterPayload, S>

  type ChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChapterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface ChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapter'], meta: { name: 'Chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {ChapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterFindUniqueArgs>(args: SelectSubset<T, ChapterFindUniqueArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterFindFirstArgs>(args?: SelectSubset<T, ChapterFindFirstArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterFindManyArgs>(args?: SelectSubset<T, ChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chapter.
     * @param {ChapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends ChapterCreateArgs>(args: SelectSubset<T, ChapterCreateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chapters.
     * @param {ChapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCreateManyArgs>(args?: SelectSubset<T, ChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {ChapterCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chapter.
     * @param {ChapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends ChapterDeleteArgs>(args: SelectSubset<T, ChapterDeleteArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chapter.
     * @param {ChapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterUpdateArgs>(args: SelectSubset<T, ChapterUpdateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chapters.
     * @param {ChapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterDeleteManyArgs>(args?: SelectSubset<T, ChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterUpdateManyArgs>(args: SelectSubset<T, ChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapter.
     * @param {ChapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends ChapterUpsertArgs>(args: SelectSubset<T, ChapterUpsertArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChapterCountArgs>(
      args?: Subset<T, ChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterGroupByArgs['orderBy'] }
        : { orderBy?: ChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapter model
   */
  readonly fields: ChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lastEditedBy<T extends Chapter$lastEditedByArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$lastEditedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    work<T extends WorkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkDefaultArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comments<T extends Chapter$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "findMany"> | Null>
    snapshots<T extends Chapter$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "findMany"> | Null>
    changes<T extends Chapter$changesArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$changesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends Chapter$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "findMany"> | Null>
    revisionRequests<T extends Chapter$revisionRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$revisionRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapter model
   */ 
  interface ChapterFieldRefs {
    readonly id: FieldRef<"Chapter", 'String'>
    readonly number: FieldRef<"Chapter", 'Int'>
    readonly title: FieldRef<"Chapter", 'String'>
    readonly originalContent: FieldRef<"Chapter", 'String'>
    readonly translatedContent: FieldRef<"Chapter", 'String'>
    readonly editedContent: FieldRef<"Chapter", 'String'>
    readonly status: FieldRef<"Chapter", 'ChapterStatus'>
    readonly wordCount: FieldRef<"Chapter", 'Int'>
    readonly translationMeta: FieldRef<"Chapter", 'Json'>
    readonly trackChangesState: FieldRef<"Chapter", 'Json'>
    readonly lastEditedById: FieldRef<"Chapter", 'String'>
    readonly lastEditedAt: FieldRef<"Chapter", 'DateTime'>
    readonly workId: FieldRef<"Chapter", 'String'>
    readonly createdAt: FieldRef<"Chapter", 'DateTime'>
    readonly updatedAt: FieldRef<"Chapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chapter findUnique
   */
  export type ChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findUniqueOrThrow
   */
  export type ChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findFirst
   */
  export type ChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findFirstOrThrow
   */
  export type ChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findMany
   */
  export type ChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter create
   */
  export type ChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapter.
     */
    data: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
  }

  /**
   * Chapter createMany
   */
  export type ChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chapter createManyAndReturn
   */
  export type ChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter update
   */
  export type ChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapter.
     */
    data: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
    /**
     * Choose, which Chapter to update.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter updateMany
   */
  export type ChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
  }

  /**
   * Chapter upsert
   */
  export type ChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapter to update in case it exists.
     */
    where: ChapterWhereUniqueInput
    /**
     * In case the Chapter found by the `where` argument doesn't exist, create a new Chapter with this data.
     */
    create: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
    /**
     * In case the Chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
  }

  /**
   * Chapter delete
   */
  export type ChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter which Chapter to delete.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter deleteMany
   */
  export type ChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChapterWhereInput
  }

  /**
   * Chapter.lastEditedBy
   */
  export type Chapter$lastEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Chapter.comments
   */
  export type Chapter$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    where?: ChapterCommentWhereInput
    orderBy?: ChapterCommentOrderByWithRelationInput | ChapterCommentOrderByWithRelationInput[]
    cursor?: ChapterCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterCommentScalarFieldEnum | ChapterCommentScalarFieldEnum[]
  }

  /**
   * Chapter.snapshots
   */
  export type Chapter$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    where?: ChapterSnapshotWhereInput
    orderBy?: ChapterSnapshotOrderByWithRelationInput | ChapterSnapshotOrderByWithRelationInput[]
    cursor?: ChapterSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterSnapshotScalarFieldEnum | ChapterSnapshotScalarFieldEnum[]
  }

  /**
   * Chapter.changes
   */
  export type Chapter$changesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    where?: ChapterChangeWhereInput
    orderBy?: ChapterChangeOrderByWithRelationInput | ChapterChangeOrderByWithRelationInput[]
    cursor?: ChapterChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterChangeScalarFieldEnum | ChapterChangeScalarFieldEnum[]
  }

  /**
   * Chapter.activities
   */
  export type Chapter$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    where?: ChapterActivityWhereInput
    orderBy?: ChapterActivityOrderByWithRelationInput | ChapterActivityOrderByWithRelationInput[]
    cursor?: ChapterActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterActivityScalarFieldEnum | ChapterActivityScalarFieldEnum[]
  }

  /**
   * Chapter.revisionRequests
   */
  export type Chapter$revisionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    where?: ChapterRevisionRequestWhereInput
    orderBy?: ChapterRevisionRequestOrderByWithRelationInput | ChapterRevisionRequestOrderByWithRelationInput[]
    cursor?: ChapterRevisionRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterRevisionRequestScalarFieldEnum | ChapterRevisionRequestScalarFieldEnum[]
  }

  /**
   * Chapter without action
   */
  export type ChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
  }


  /**
   * Model GlossaryItem
   */

  export type AggregateGlossaryItem = {
    _count: GlossaryItemCountAggregateOutputType | null
    _min: GlossaryItemMinAggregateOutputType | null
    _max: GlossaryItemMaxAggregateOutputType | null
  }

  export type GlossaryItemMinAggregateOutputType = {
    id: string | null
    original: string | null
    translated: string | null
    category: string | null
    note: string | null
    workId: string | null
  }

  export type GlossaryItemMaxAggregateOutputType = {
    id: string | null
    original: string | null
    translated: string | null
    category: string | null
    note: string | null
    workId: string | null
  }

  export type GlossaryItemCountAggregateOutputType = {
    id: number
    original: number
    translated: number
    category: number
    note: number
    workId: number
    _all: number
  }


  export type GlossaryItemMinAggregateInputType = {
    id?: true
    original?: true
    translated?: true
    category?: true
    note?: true
    workId?: true
  }

  export type GlossaryItemMaxAggregateInputType = {
    id?: true
    original?: true
    translated?: true
    category?: true
    note?: true
    workId?: true
  }

  export type GlossaryItemCountAggregateInputType = {
    id?: true
    original?: true
    translated?: true
    category?: true
    note?: true
    workId?: true
    _all?: true
  }

  export type GlossaryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlossaryItem to aggregate.
     */
    where?: GlossaryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlossaryItems to fetch.
     */
    orderBy?: GlossaryItemOrderByWithRelationInput | GlossaryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlossaryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlossaryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlossaryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlossaryItems
    **/
    _count?: true | GlossaryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlossaryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlossaryItemMaxAggregateInputType
  }

  export type GetGlossaryItemAggregateType<T extends GlossaryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateGlossaryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlossaryItem[P]>
      : GetScalarType<T[P], AggregateGlossaryItem[P]>
  }




  export type GlossaryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlossaryItemWhereInput
    orderBy?: GlossaryItemOrderByWithAggregationInput | GlossaryItemOrderByWithAggregationInput[]
    by: GlossaryItemScalarFieldEnum[] | GlossaryItemScalarFieldEnum
    having?: GlossaryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlossaryItemCountAggregateInputType | true
    _min?: GlossaryItemMinAggregateInputType
    _max?: GlossaryItemMaxAggregateInputType
  }

  export type GlossaryItemGroupByOutputType = {
    id: string
    original: string
    translated: string
    category: string | null
    note: string | null
    workId: string
    _count: GlossaryItemCountAggregateOutputType | null
    _min: GlossaryItemMinAggregateOutputType | null
    _max: GlossaryItemMaxAggregateOutputType | null
  }

  type GetGlossaryItemGroupByPayload<T extends GlossaryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlossaryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlossaryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlossaryItemGroupByOutputType[P]>
            : GetScalarType<T[P], GlossaryItemGroupByOutputType[P]>
        }
      >
    >


  export type GlossaryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    original?: boolean
    translated?: boolean
    category?: boolean
    note?: boolean
    workId?: boolean
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["glossaryItem"]>

  export type GlossaryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    original?: boolean
    translated?: boolean
    category?: boolean
    note?: boolean
    workId?: boolean
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["glossaryItem"]>

  export type GlossaryItemSelectScalar = {
    id?: boolean
    original?: boolean
    translated?: boolean
    category?: boolean
    note?: boolean
    workId?: boolean
  }

  export type GlossaryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }
  export type GlossaryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }

  export type $GlossaryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GlossaryItem"
    objects: {
      work: Prisma.$WorkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      original: string
      translated: string
      category: string | null
      note: string | null
      workId: string
    }, ExtArgs["result"]["glossaryItem"]>
    composites: {}
  }

  type GlossaryItemGetPayload<S extends boolean | null | undefined | GlossaryItemDefaultArgs> = $Result.GetResult<Prisma.$GlossaryItemPayload, S>

  type GlossaryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GlossaryItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GlossaryItemCountAggregateInputType | true
    }

  export interface GlossaryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlossaryItem'], meta: { name: 'GlossaryItem' } }
    /**
     * Find zero or one GlossaryItem that matches the filter.
     * @param {GlossaryItemFindUniqueArgs} args - Arguments to find a GlossaryItem
     * @example
     * // Get one GlossaryItem
     * const glossaryItem = await prisma.glossaryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlossaryItemFindUniqueArgs>(args: SelectSubset<T, GlossaryItemFindUniqueArgs<ExtArgs>>): Prisma__GlossaryItemClient<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GlossaryItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GlossaryItemFindUniqueOrThrowArgs} args - Arguments to find a GlossaryItem
     * @example
     * // Get one GlossaryItem
     * const glossaryItem = await prisma.glossaryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlossaryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, GlossaryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlossaryItemClient<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GlossaryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryItemFindFirstArgs} args - Arguments to find a GlossaryItem
     * @example
     * // Get one GlossaryItem
     * const glossaryItem = await prisma.glossaryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlossaryItemFindFirstArgs>(args?: SelectSubset<T, GlossaryItemFindFirstArgs<ExtArgs>>): Prisma__GlossaryItemClient<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GlossaryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryItemFindFirstOrThrowArgs} args - Arguments to find a GlossaryItem
     * @example
     * // Get one GlossaryItem
     * const glossaryItem = await prisma.glossaryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlossaryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, GlossaryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlossaryItemClient<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GlossaryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlossaryItems
     * const glossaryItems = await prisma.glossaryItem.findMany()
     * 
     * // Get first 10 GlossaryItems
     * const glossaryItems = await prisma.glossaryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const glossaryItemWithIdOnly = await prisma.glossaryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlossaryItemFindManyArgs>(args?: SelectSubset<T, GlossaryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GlossaryItem.
     * @param {GlossaryItemCreateArgs} args - Arguments to create a GlossaryItem.
     * @example
     * // Create one GlossaryItem
     * const GlossaryItem = await prisma.glossaryItem.create({
     *   data: {
     *     // ... data to create a GlossaryItem
     *   }
     * })
     * 
     */
    create<T extends GlossaryItemCreateArgs>(args: SelectSubset<T, GlossaryItemCreateArgs<ExtArgs>>): Prisma__GlossaryItemClient<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GlossaryItems.
     * @param {GlossaryItemCreateManyArgs} args - Arguments to create many GlossaryItems.
     * @example
     * // Create many GlossaryItems
     * const glossaryItem = await prisma.glossaryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlossaryItemCreateManyArgs>(args?: SelectSubset<T, GlossaryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GlossaryItems and returns the data saved in the database.
     * @param {GlossaryItemCreateManyAndReturnArgs} args - Arguments to create many GlossaryItems.
     * @example
     * // Create many GlossaryItems
     * const glossaryItem = await prisma.glossaryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GlossaryItems and only return the `id`
     * const glossaryItemWithIdOnly = await prisma.glossaryItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlossaryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, GlossaryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GlossaryItem.
     * @param {GlossaryItemDeleteArgs} args - Arguments to delete one GlossaryItem.
     * @example
     * // Delete one GlossaryItem
     * const GlossaryItem = await prisma.glossaryItem.delete({
     *   where: {
     *     // ... filter to delete one GlossaryItem
     *   }
     * })
     * 
     */
    delete<T extends GlossaryItemDeleteArgs>(args: SelectSubset<T, GlossaryItemDeleteArgs<ExtArgs>>): Prisma__GlossaryItemClient<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GlossaryItem.
     * @param {GlossaryItemUpdateArgs} args - Arguments to update one GlossaryItem.
     * @example
     * // Update one GlossaryItem
     * const glossaryItem = await prisma.glossaryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlossaryItemUpdateArgs>(args: SelectSubset<T, GlossaryItemUpdateArgs<ExtArgs>>): Prisma__GlossaryItemClient<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GlossaryItems.
     * @param {GlossaryItemDeleteManyArgs} args - Arguments to filter GlossaryItems to delete.
     * @example
     * // Delete a few GlossaryItems
     * const { count } = await prisma.glossaryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlossaryItemDeleteManyArgs>(args?: SelectSubset<T, GlossaryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlossaryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlossaryItems
     * const glossaryItem = await prisma.glossaryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlossaryItemUpdateManyArgs>(args: SelectSubset<T, GlossaryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GlossaryItem.
     * @param {GlossaryItemUpsertArgs} args - Arguments to update or create a GlossaryItem.
     * @example
     * // Update or create a GlossaryItem
     * const glossaryItem = await prisma.glossaryItem.upsert({
     *   create: {
     *     // ... data to create a GlossaryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlossaryItem we want to update
     *   }
     * })
     */
    upsert<T extends GlossaryItemUpsertArgs>(args: SelectSubset<T, GlossaryItemUpsertArgs<ExtArgs>>): Prisma__GlossaryItemClient<$Result.GetResult<Prisma.$GlossaryItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GlossaryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryItemCountArgs} args - Arguments to filter GlossaryItems to count.
     * @example
     * // Count the number of GlossaryItems
     * const count = await prisma.glossaryItem.count({
     *   where: {
     *     // ... the filter for the GlossaryItems we want to count
     *   }
     * })
    **/
    count<T extends GlossaryItemCountArgs>(
      args?: Subset<T, GlossaryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlossaryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlossaryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlossaryItemAggregateArgs>(args: Subset<T, GlossaryItemAggregateArgs>): Prisma.PrismaPromise<GetGlossaryItemAggregateType<T>>

    /**
     * Group by GlossaryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlossaryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlossaryItemGroupByArgs['orderBy'] }
        : { orderBy?: GlossaryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlossaryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlossaryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlossaryItem model
   */
  readonly fields: GlossaryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlossaryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlossaryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work<T extends WorkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkDefaultArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GlossaryItem model
   */ 
  interface GlossaryItemFieldRefs {
    readonly id: FieldRef<"GlossaryItem", 'String'>
    readonly original: FieldRef<"GlossaryItem", 'String'>
    readonly translated: FieldRef<"GlossaryItem", 'String'>
    readonly category: FieldRef<"GlossaryItem", 'String'>
    readonly note: FieldRef<"GlossaryItem", 'String'>
    readonly workId: FieldRef<"GlossaryItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GlossaryItem findUnique
   */
  export type GlossaryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
    /**
     * Filter, which GlossaryItem to fetch.
     */
    where: GlossaryItemWhereUniqueInput
  }

  /**
   * GlossaryItem findUniqueOrThrow
   */
  export type GlossaryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
    /**
     * Filter, which GlossaryItem to fetch.
     */
    where: GlossaryItemWhereUniqueInput
  }

  /**
   * GlossaryItem findFirst
   */
  export type GlossaryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
    /**
     * Filter, which GlossaryItem to fetch.
     */
    where?: GlossaryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlossaryItems to fetch.
     */
    orderBy?: GlossaryItemOrderByWithRelationInput | GlossaryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlossaryItems.
     */
    cursor?: GlossaryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlossaryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlossaryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlossaryItems.
     */
    distinct?: GlossaryItemScalarFieldEnum | GlossaryItemScalarFieldEnum[]
  }

  /**
   * GlossaryItem findFirstOrThrow
   */
  export type GlossaryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
    /**
     * Filter, which GlossaryItem to fetch.
     */
    where?: GlossaryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlossaryItems to fetch.
     */
    orderBy?: GlossaryItemOrderByWithRelationInput | GlossaryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlossaryItems.
     */
    cursor?: GlossaryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlossaryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlossaryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlossaryItems.
     */
    distinct?: GlossaryItemScalarFieldEnum | GlossaryItemScalarFieldEnum[]
  }

  /**
   * GlossaryItem findMany
   */
  export type GlossaryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
    /**
     * Filter, which GlossaryItems to fetch.
     */
    where?: GlossaryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlossaryItems to fetch.
     */
    orderBy?: GlossaryItemOrderByWithRelationInput | GlossaryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlossaryItems.
     */
    cursor?: GlossaryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlossaryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlossaryItems.
     */
    skip?: number
    distinct?: GlossaryItemScalarFieldEnum | GlossaryItemScalarFieldEnum[]
  }

  /**
   * GlossaryItem create
   */
  export type GlossaryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a GlossaryItem.
     */
    data: XOR<GlossaryItemCreateInput, GlossaryItemUncheckedCreateInput>
  }

  /**
   * GlossaryItem createMany
   */
  export type GlossaryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlossaryItems.
     */
    data: GlossaryItemCreateManyInput | GlossaryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlossaryItem createManyAndReturn
   */
  export type GlossaryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GlossaryItems.
     */
    data: GlossaryItemCreateManyInput | GlossaryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GlossaryItem update
   */
  export type GlossaryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a GlossaryItem.
     */
    data: XOR<GlossaryItemUpdateInput, GlossaryItemUncheckedUpdateInput>
    /**
     * Choose, which GlossaryItem to update.
     */
    where: GlossaryItemWhereUniqueInput
  }

  /**
   * GlossaryItem updateMany
   */
  export type GlossaryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlossaryItems.
     */
    data: XOR<GlossaryItemUpdateManyMutationInput, GlossaryItemUncheckedUpdateManyInput>
    /**
     * Filter which GlossaryItems to update
     */
    where?: GlossaryItemWhereInput
  }

  /**
   * GlossaryItem upsert
   */
  export type GlossaryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the GlossaryItem to update in case it exists.
     */
    where: GlossaryItemWhereUniqueInput
    /**
     * In case the GlossaryItem found by the `where` argument doesn't exist, create a new GlossaryItem with this data.
     */
    create: XOR<GlossaryItemCreateInput, GlossaryItemUncheckedCreateInput>
    /**
     * In case the GlossaryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlossaryItemUpdateInput, GlossaryItemUncheckedUpdateInput>
  }

  /**
   * GlossaryItem delete
   */
  export type GlossaryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
    /**
     * Filter which GlossaryItem to delete.
     */
    where: GlossaryItemWhereUniqueInput
  }

  /**
   * GlossaryItem deleteMany
   */
  export type GlossaryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlossaryItems to delete
     */
    where?: GlossaryItemWhereInput
  }

  /**
   * GlossaryItem without action
   */
  export type GlossaryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryItem
     */
    select?: GlossaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlossaryItemInclude<ExtArgs> | null
  }


  /**
   * Model TranslationLog
   */

  export type AggregateTranslationLog = {
    _count: TranslationLogCountAggregateOutputType | null
    _avg: TranslationLogAvgAggregateOutputType | null
    _sum: TranslationLogSumAggregateOutputType | null
    _min: TranslationLogMinAggregateOutputType | null
    _max: TranslationLogMaxAggregateOutputType | null
  }

  export type TranslationLogAvgAggregateOutputType = {
    chapterNum: number | null
    chunkIndex: number | null
    durationMs: number | null
    retryCount: number | null
  }

  export type TranslationLogSumAggregateOutputType = {
    chapterNum: number | null
    chunkIndex: number | null
    durationMs: number | null
    retryCount: number | null
  }

  export type TranslationLogMinAggregateOutputType = {
    id: string | null
    level: $Enums.LogLevel | null
    category: $Enums.LogCategory | null
    jobId: string | null
    workId: string | null
    chapterId: string | null
    chapterNum: number | null
    chunkIndex: number | null
    userId: string | null
    userEmail: string | null
    message: string | null
    errorCode: string | null
    errorStack: string | null
    durationMs: number | null
    retryCount: number | null
    clientIp: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type TranslationLogMaxAggregateOutputType = {
    id: string | null
    level: $Enums.LogLevel | null
    category: $Enums.LogCategory | null
    jobId: string | null
    workId: string | null
    chapterId: string | null
    chapterNum: number | null
    chunkIndex: number | null
    userId: string | null
    userEmail: string | null
    message: string | null
    errorCode: string | null
    errorStack: string | null
    durationMs: number | null
    retryCount: number | null
    clientIp: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type TranslationLogCountAggregateOutputType = {
    id: number
    level: number
    category: number
    jobId: number
    workId: number
    chapterId: number
    chapterNum: number
    chunkIndex: number
    userId: number
    userEmail: number
    message: number
    errorCode: number
    errorStack: number
    metadata: number
    durationMs: number
    retryCount: number
    clientIp: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type TranslationLogAvgAggregateInputType = {
    chapterNum?: true
    chunkIndex?: true
    durationMs?: true
    retryCount?: true
  }

  export type TranslationLogSumAggregateInputType = {
    chapterNum?: true
    chunkIndex?: true
    durationMs?: true
    retryCount?: true
  }

  export type TranslationLogMinAggregateInputType = {
    id?: true
    level?: true
    category?: true
    jobId?: true
    workId?: true
    chapterId?: true
    chapterNum?: true
    chunkIndex?: true
    userId?: true
    userEmail?: true
    message?: true
    errorCode?: true
    errorStack?: true
    durationMs?: true
    retryCount?: true
    clientIp?: true
    userAgent?: true
    createdAt?: true
  }

  export type TranslationLogMaxAggregateInputType = {
    id?: true
    level?: true
    category?: true
    jobId?: true
    workId?: true
    chapterId?: true
    chapterNum?: true
    chunkIndex?: true
    userId?: true
    userEmail?: true
    message?: true
    errorCode?: true
    errorStack?: true
    durationMs?: true
    retryCount?: true
    clientIp?: true
    userAgent?: true
    createdAt?: true
  }

  export type TranslationLogCountAggregateInputType = {
    id?: true
    level?: true
    category?: true
    jobId?: true
    workId?: true
    chapterId?: true
    chapterNum?: true
    chunkIndex?: true
    userId?: true
    userEmail?: true
    message?: true
    errorCode?: true
    errorStack?: true
    metadata?: true
    durationMs?: true
    retryCount?: true
    clientIp?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type TranslationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranslationLog to aggregate.
     */
    where?: TranslationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationLogs to fetch.
     */
    orderBy?: TranslationLogOrderByWithRelationInput | TranslationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranslationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranslationLogs
    **/
    _count?: true | TranslationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranslationLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranslationLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationLogMaxAggregateInputType
  }

  export type GetTranslationLogAggregateType<T extends TranslationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslationLog[P]>
      : GetScalarType<T[P], AggregateTranslationLog[P]>
  }




  export type TranslationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationLogWhereInput
    orderBy?: TranslationLogOrderByWithAggregationInput | TranslationLogOrderByWithAggregationInput[]
    by: TranslationLogScalarFieldEnum[] | TranslationLogScalarFieldEnum
    having?: TranslationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationLogCountAggregateInputType | true
    _avg?: TranslationLogAvgAggregateInputType
    _sum?: TranslationLogSumAggregateInputType
    _min?: TranslationLogMinAggregateInputType
    _max?: TranslationLogMaxAggregateInputType
  }

  export type TranslationLogGroupByOutputType = {
    id: string
    level: $Enums.LogLevel
    category: $Enums.LogCategory
    jobId: string | null
    workId: string | null
    chapterId: string | null
    chapterNum: number | null
    chunkIndex: number | null
    userId: string | null
    userEmail: string | null
    message: string
    errorCode: string | null
    errorStack: string | null
    metadata: JsonValue | null
    durationMs: number | null
    retryCount: number | null
    clientIp: string | null
    userAgent: string | null
    createdAt: Date
    _count: TranslationLogCountAggregateOutputType | null
    _avg: TranslationLogAvgAggregateOutputType | null
    _sum: TranslationLogSumAggregateOutputType | null
    _min: TranslationLogMinAggregateOutputType | null
    _max: TranslationLogMaxAggregateOutputType | null
  }

  type GetTranslationLogGroupByPayload<T extends TranslationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranslationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationLogGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationLogGroupByOutputType[P]>
        }
      >
    >


  export type TranslationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    category?: boolean
    jobId?: boolean
    workId?: boolean
    chapterId?: boolean
    chapterNum?: boolean
    chunkIndex?: boolean
    userId?: boolean
    userEmail?: boolean
    message?: boolean
    errorCode?: boolean
    errorStack?: boolean
    metadata?: boolean
    durationMs?: boolean
    retryCount?: boolean
    clientIp?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["translationLog"]>

  export type TranslationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    category?: boolean
    jobId?: boolean
    workId?: boolean
    chapterId?: boolean
    chapterNum?: boolean
    chunkIndex?: boolean
    userId?: boolean
    userEmail?: boolean
    message?: boolean
    errorCode?: boolean
    errorStack?: boolean
    metadata?: boolean
    durationMs?: boolean
    retryCount?: boolean
    clientIp?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["translationLog"]>

  export type TranslationLogSelectScalar = {
    id?: boolean
    level?: boolean
    category?: boolean
    jobId?: boolean
    workId?: boolean
    chapterId?: boolean
    chapterNum?: boolean
    chunkIndex?: boolean
    userId?: boolean
    userEmail?: boolean
    message?: boolean
    errorCode?: boolean
    errorStack?: boolean
    metadata?: boolean
    durationMs?: boolean
    retryCount?: boolean
    clientIp?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }


  export type $TranslationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TranslationLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: $Enums.LogLevel
      category: $Enums.LogCategory
      jobId: string | null
      workId: string | null
      chapterId: string | null
      chapterNum: number | null
      chunkIndex: number | null
      userId: string | null
      userEmail: string | null
      message: string
      errorCode: string | null
      errorStack: string | null
      metadata: Prisma.JsonValue | null
      durationMs: number | null
      retryCount: number | null
      clientIp: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["translationLog"]>
    composites: {}
  }

  type TranslationLogGetPayload<S extends boolean | null | undefined | TranslationLogDefaultArgs> = $Result.GetResult<Prisma.$TranslationLogPayload, S>

  type TranslationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TranslationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TranslationLogCountAggregateInputType | true
    }

  export interface TranslationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TranslationLog'], meta: { name: 'TranslationLog' } }
    /**
     * Find zero or one TranslationLog that matches the filter.
     * @param {TranslationLogFindUniqueArgs} args - Arguments to find a TranslationLog
     * @example
     * // Get one TranslationLog
     * const translationLog = await prisma.translationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranslationLogFindUniqueArgs>(args: SelectSubset<T, TranslationLogFindUniqueArgs<ExtArgs>>): Prisma__TranslationLogClient<$Result.GetResult<Prisma.$TranslationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TranslationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TranslationLogFindUniqueOrThrowArgs} args - Arguments to find a TranslationLog
     * @example
     * // Get one TranslationLog
     * const translationLog = await prisma.translationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranslationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TranslationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranslationLogClient<$Result.GetResult<Prisma.$TranslationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TranslationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationLogFindFirstArgs} args - Arguments to find a TranslationLog
     * @example
     * // Get one TranslationLog
     * const translationLog = await prisma.translationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranslationLogFindFirstArgs>(args?: SelectSubset<T, TranslationLogFindFirstArgs<ExtArgs>>): Prisma__TranslationLogClient<$Result.GetResult<Prisma.$TranslationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TranslationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationLogFindFirstOrThrowArgs} args - Arguments to find a TranslationLog
     * @example
     * // Get one TranslationLog
     * const translationLog = await prisma.translationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranslationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TranslationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranslationLogClient<$Result.GetResult<Prisma.$TranslationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TranslationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranslationLogs
     * const translationLogs = await prisma.translationLog.findMany()
     * 
     * // Get first 10 TranslationLogs
     * const translationLogs = await prisma.translationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const translationLogWithIdOnly = await prisma.translationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranslationLogFindManyArgs>(args?: SelectSubset<T, TranslationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TranslationLog.
     * @param {TranslationLogCreateArgs} args - Arguments to create a TranslationLog.
     * @example
     * // Create one TranslationLog
     * const TranslationLog = await prisma.translationLog.create({
     *   data: {
     *     // ... data to create a TranslationLog
     *   }
     * })
     * 
     */
    create<T extends TranslationLogCreateArgs>(args: SelectSubset<T, TranslationLogCreateArgs<ExtArgs>>): Prisma__TranslationLogClient<$Result.GetResult<Prisma.$TranslationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TranslationLogs.
     * @param {TranslationLogCreateManyArgs} args - Arguments to create many TranslationLogs.
     * @example
     * // Create many TranslationLogs
     * const translationLog = await prisma.translationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranslationLogCreateManyArgs>(args?: SelectSubset<T, TranslationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TranslationLogs and returns the data saved in the database.
     * @param {TranslationLogCreateManyAndReturnArgs} args - Arguments to create many TranslationLogs.
     * @example
     * // Create many TranslationLogs
     * const translationLog = await prisma.translationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TranslationLogs and only return the `id`
     * const translationLogWithIdOnly = await prisma.translationLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranslationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TranslationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TranslationLog.
     * @param {TranslationLogDeleteArgs} args - Arguments to delete one TranslationLog.
     * @example
     * // Delete one TranslationLog
     * const TranslationLog = await prisma.translationLog.delete({
     *   where: {
     *     // ... filter to delete one TranslationLog
     *   }
     * })
     * 
     */
    delete<T extends TranslationLogDeleteArgs>(args: SelectSubset<T, TranslationLogDeleteArgs<ExtArgs>>): Prisma__TranslationLogClient<$Result.GetResult<Prisma.$TranslationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TranslationLog.
     * @param {TranslationLogUpdateArgs} args - Arguments to update one TranslationLog.
     * @example
     * // Update one TranslationLog
     * const translationLog = await prisma.translationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranslationLogUpdateArgs>(args: SelectSubset<T, TranslationLogUpdateArgs<ExtArgs>>): Prisma__TranslationLogClient<$Result.GetResult<Prisma.$TranslationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TranslationLogs.
     * @param {TranslationLogDeleteManyArgs} args - Arguments to filter TranslationLogs to delete.
     * @example
     * // Delete a few TranslationLogs
     * const { count } = await prisma.translationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranslationLogDeleteManyArgs>(args?: SelectSubset<T, TranslationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranslationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranslationLogs
     * const translationLog = await prisma.translationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranslationLogUpdateManyArgs>(args: SelectSubset<T, TranslationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TranslationLog.
     * @param {TranslationLogUpsertArgs} args - Arguments to update or create a TranslationLog.
     * @example
     * // Update or create a TranslationLog
     * const translationLog = await prisma.translationLog.upsert({
     *   create: {
     *     // ... data to create a TranslationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranslationLog we want to update
     *   }
     * })
     */
    upsert<T extends TranslationLogUpsertArgs>(args: SelectSubset<T, TranslationLogUpsertArgs<ExtArgs>>): Prisma__TranslationLogClient<$Result.GetResult<Prisma.$TranslationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TranslationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationLogCountArgs} args - Arguments to filter TranslationLogs to count.
     * @example
     * // Count the number of TranslationLogs
     * const count = await prisma.translationLog.count({
     *   where: {
     *     // ... the filter for the TranslationLogs we want to count
     *   }
     * })
    **/
    count<T extends TranslationLogCountArgs>(
      args?: Subset<T, TranslationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranslationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationLogAggregateArgs>(args: Subset<T, TranslationLogAggregateArgs>): Prisma.PrismaPromise<GetTranslationLogAggregateType<T>>

    /**
     * Group by TranslationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranslationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranslationLogGroupByArgs['orderBy'] }
        : { orderBy?: TranslationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranslationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TranslationLog model
   */
  readonly fields: TranslationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranslationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranslationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TranslationLog model
   */ 
  interface TranslationLogFieldRefs {
    readonly id: FieldRef<"TranslationLog", 'String'>
    readonly level: FieldRef<"TranslationLog", 'LogLevel'>
    readonly category: FieldRef<"TranslationLog", 'LogCategory'>
    readonly jobId: FieldRef<"TranslationLog", 'String'>
    readonly workId: FieldRef<"TranslationLog", 'String'>
    readonly chapterId: FieldRef<"TranslationLog", 'String'>
    readonly chapterNum: FieldRef<"TranslationLog", 'Int'>
    readonly chunkIndex: FieldRef<"TranslationLog", 'Int'>
    readonly userId: FieldRef<"TranslationLog", 'String'>
    readonly userEmail: FieldRef<"TranslationLog", 'String'>
    readonly message: FieldRef<"TranslationLog", 'String'>
    readonly errorCode: FieldRef<"TranslationLog", 'String'>
    readonly errorStack: FieldRef<"TranslationLog", 'String'>
    readonly metadata: FieldRef<"TranslationLog", 'Json'>
    readonly durationMs: FieldRef<"TranslationLog", 'Int'>
    readonly retryCount: FieldRef<"TranslationLog", 'Int'>
    readonly clientIp: FieldRef<"TranslationLog", 'String'>
    readonly userAgent: FieldRef<"TranslationLog", 'String'>
    readonly createdAt: FieldRef<"TranslationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TranslationLog findUnique
   */
  export type TranslationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelect<ExtArgs> | null
    /**
     * Filter, which TranslationLog to fetch.
     */
    where: TranslationLogWhereUniqueInput
  }

  /**
   * TranslationLog findUniqueOrThrow
   */
  export type TranslationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelect<ExtArgs> | null
    /**
     * Filter, which TranslationLog to fetch.
     */
    where: TranslationLogWhereUniqueInput
  }

  /**
   * TranslationLog findFirst
   */
  export type TranslationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelect<ExtArgs> | null
    /**
     * Filter, which TranslationLog to fetch.
     */
    where?: TranslationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationLogs to fetch.
     */
    orderBy?: TranslationLogOrderByWithRelationInput | TranslationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranslationLogs.
     */
    cursor?: TranslationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranslationLogs.
     */
    distinct?: TranslationLogScalarFieldEnum | TranslationLogScalarFieldEnum[]
  }

  /**
   * TranslationLog findFirstOrThrow
   */
  export type TranslationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelect<ExtArgs> | null
    /**
     * Filter, which TranslationLog to fetch.
     */
    where?: TranslationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationLogs to fetch.
     */
    orderBy?: TranslationLogOrderByWithRelationInput | TranslationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranslationLogs.
     */
    cursor?: TranslationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranslationLogs.
     */
    distinct?: TranslationLogScalarFieldEnum | TranslationLogScalarFieldEnum[]
  }

  /**
   * TranslationLog findMany
   */
  export type TranslationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelect<ExtArgs> | null
    /**
     * Filter, which TranslationLogs to fetch.
     */
    where?: TranslationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationLogs to fetch.
     */
    orderBy?: TranslationLogOrderByWithRelationInput | TranslationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranslationLogs.
     */
    cursor?: TranslationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationLogs.
     */
    skip?: number
    distinct?: TranslationLogScalarFieldEnum | TranslationLogScalarFieldEnum[]
  }

  /**
   * TranslationLog create
   */
  export type TranslationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelect<ExtArgs> | null
    /**
     * The data needed to create a TranslationLog.
     */
    data: XOR<TranslationLogCreateInput, TranslationLogUncheckedCreateInput>
  }

  /**
   * TranslationLog createMany
   */
  export type TranslationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TranslationLogs.
     */
    data: TranslationLogCreateManyInput | TranslationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranslationLog createManyAndReturn
   */
  export type TranslationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TranslationLogs.
     */
    data: TranslationLogCreateManyInput | TranslationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranslationLog update
   */
  export type TranslationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelect<ExtArgs> | null
    /**
     * The data needed to update a TranslationLog.
     */
    data: XOR<TranslationLogUpdateInput, TranslationLogUncheckedUpdateInput>
    /**
     * Choose, which TranslationLog to update.
     */
    where: TranslationLogWhereUniqueInput
  }

  /**
   * TranslationLog updateMany
   */
  export type TranslationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TranslationLogs.
     */
    data: XOR<TranslationLogUpdateManyMutationInput, TranslationLogUncheckedUpdateManyInput>
    /**
     * Filter which TranslationLogs to update
     */
    where?: TranslationLogWhereInput
  }

  /**
   * TranslationLog upsert
   */
  export type TranslationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelect<ExtArgs> | null
    /**
     * The filter to search for the TranslationLog to update in case it exists.
     */
    where: TranslationLogWhereUniqueInput
    /**
     * In case the TranslationLog found by the `where` argument doesn't exist, create a new TranslationLog with this data.
     */
    create: XOR<TranslationLogCreateInput, TranslationLogUncheckedCreateInput>
    /**
     * In case the TranslationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranslationLogUpdateInput, TranslationLogUncheckedUpdateInput>
  }

  /**
   * TranslationLog delete
   */
  export type TranslationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelect<ExtArgs> | null
    /**
     * Filter which TranslationLog to delete.
     */
    where: TranslationLogWhereUniqueInput
  }

  /**
   * TranslationLog deleteMany
   */
  export type TranslationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranslationLogs to delete
     */
    where?: TranslationLogWhereInput
  }

  /**
   * TranslationLog without action
   */
  export type TranslationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationLog
     */
    select?: TranslationLogSelect<ExtArgs> | null
  }


  /**
   * Model ActiveTranslationJob
   */

  export type AggregateActiveTranslationJob = {
    _count: ActiveTranslationJobCountAggregateOutputType | null
    _avg: ActiveTranslationJobAvgAggregateOutputType | null
    _sum: ActiveTranslationJobSumAggregateOutputType | null
    _min: ActiveTranslationJobMinAggregateOutputType | null
    _max: ActiveTranslationJobMaxAggregateOutputType | null
  }

  export type ActiveTranslationJobAvgAggregateOutputType = {
    totalBatches: number | null
    currentBatchIndex: number | null
    retryCount: number | null
    maxRetries: number | null
    totalChapters: number | null
    completedChapters: number | null
    failedChapters: number | null
    currentChapterNum: number | null
    currentChunkIndex: number | null
    totalChunks: number | null
    failedChapterNums: number | null
    autoRetryCount: number | null
    maxAutoRetries: number | null
  }

  export type ActiveTranslationJobSumAggregateOutputType = {
    totalBatches: number | null
    currentBatchIndex: number | null
    retryCount: number | null
    maxRetries: number | null
    totalChapters: number | null
    completedChapters: number | null
    failedChapters: number | null
    currentChapterNum: number | null
    currentChunkIndex: number | null
    totalChunks: number | null
    failedChapterNums: number[]
    autoRetryCount: number | null
    maxAutoRetries: number | null
  }

  export type ActiveTranslationJobMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    workId: string | null
    workTitle: string | null
    userId: string | null
    userEmail: string | null
    status: string | null
    isPauseRequested: boolean | null
    totalBatches: number | null
    currentBatchIndex: number | null
    retryCount: number | null
    maxRetries: number | null
    lastError: string | null
    totalChapters: number | null
    completedChapters: number | null
    failedChapters: number | null
    currentChapterNum: number | null
    currentChunkIndex: number | null
    totalChunks: number | null
    autoRetryCount: number | null
    maxAutoRetries: number | null
    errorMessage: string | null
    lockedAt: Date | null
    lockedBy: string | null
    startedAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type ActiveTranslationJobMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    workId: string | null
    workTitle: string | null
    userId: string | null
    userEmail: string | null
    status: string | null
    isPauseRequested: boolean | null
    totalBatches: number | null
    currentBatchIndex: number | null
    retryCount: number | null
    maxRetries: number | null
    lastError: string | null
    totalChapters: number | null
    completedChapters: number | null
    failedChapters: number | null
    currentChapterNum: number | null
    currentChunkIndex: number | null
    totalChunks: number | null
    autoRetryCount: number | null
    maxAutoRetries: number | null
    errorMessage: string | null
    lockedAt: Date | null
    lockedBy: string | null
    startedAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type ActiveTranslationJobCountAggregateOutputType = {
    id: number
    jobId: number
    workId: number
    workTitle: number
    userId: number
    userEmail: number
    status: number
    isPauseRequested: number
    batchPlan: number
    totalBatches: number
    currentBatchIndex: number
    retryCount: number
    maxRetries: number
    lastError: number
    totalChapters: number
    completedChapters: number
    failedChapters: number
    currentChapterNum: number
    currentChunkIndex: number
    totalChunks: number
    chaptersProgress: number
    failedChapterNums: number
    autoRetryCount: number
    maxAutoRetries: number
    errorMessage: number
    lockedAt: number
    lockedBy: number
    startedAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type ActiveTranslationJobAvgAggregateInputType = {
    totalBatches?: true
    currentBatchIndex?: true
    retryCount?: true
    maxRetries?: true
    totalChapters?: true
    completedChapters?: true
    failedChapters?: true
    currentChapterNum?: true
    currentChunkIndex?: true
    totalChunks?: true
    failedChapterNums?: true
    autoRetryCount?: true
    maxAutoRetries?: true
  }

  export type ActiveTranslationJobSumAggregateInputType = {
    totalBatches?: true
    currentBatchIndex?: true
    retryCount?: true
    maxRetries?: true
    totalChapters?: true
    completedChapters?: true
    failedChapters?: true
    currentChapterNum?: true
    currentChunkIndex?: true
    totalChunks?: true
    failedChapterNums?: true
    autoRetryCount?: true
    maxAutoRetries?: true
  }

  export type ActiveTranslationJobMinAggregateInputType = {
    id?: true
    jobId?: true
    workId?: true
    workTitle?: true
    userId?: true
    userEmail?: true
    status?: true
    isPauseRequested?: true
    totalBatches?: true
    currentBatchIndex?: true
    retryCount?: true
    maxRetries?: true
    lastError?: true
    totalChapters?: true
    completedChapters?: true
    failedChapters?: true
    currentChapterNum?: true
    currentChunkIndex?: true
    totalChunks?: true
    autoRetryCount?: true
    maxAutoRetries?: true
    errorMessage?: true
    lockedAt?: true
    lockedBy?: true
    startedAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type ActiveTranslationJobMaxAggregateInputType = {
    id?: true
    jobId?: true
    workId?: true
    workTitle?: true
    userId?: true
    userEmail?: true
    status?: true
    isPauseRequested?: true
    totalBatches?: true
    currentBatchIndex?: true
    retryCount?: true
    maxRetries?: true
    lastError?: true
    totalChapters?: true
    completedChapters?: true
    failedChapters?: true
    currentChapterNum?: true
    currentChunkIndex?: true
    totalChunks?: true
    autoRetryCount?: true
    maxAutoRetries?: true
    errorMessage?: true
    lockedAt?: true
    lockedBy?: true
    startedAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type ActiveTranslationJobCountAggregateInputType = {
    id?: true
    jobId?: true
    workId?: true
    workTitle?: true
    userId?: true
    userEmail?: true
    status?: true
    isPauseRequested?: true
    batchPlan?: true
    totalBatches?: true
    currentBatchIndex?: true
    retryCount?: true
    maxRetries?: true
    lastError?: true
    totalChapters?: true
    completedChapters?: true
    failedChapters?: true
    currentChapterNum?: true
    currentChunkIndex?: true
    totalChunks?: true
    chaptersProgress?: true
    failedChapterNums?: true
    autoRetryCount?: true
    maxAutoRetries?: true
    errorMessage?: true
    lockedAt?: true
    lockedBy?: true
    startedAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type ActiveTranslationJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiveTranslationJob to aggregate.
     */
    where?: ActiveTranslationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveTranslationJobs to fetch.
     */
    orderBy?: ActiveTranslationJobOrderByWithRelationInput | ActiveTranslationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActiveTranslationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveTranslationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveTranslationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActiveTranslationJobs
    **/
    _count?: true | ActiveTranslationJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActiveTranslationJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActiveTranslationJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActiveTranslationJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActiveTranslationJobMaxAggregateInputType
  }

  export type GetActiveTranslationJobAggregateType<T extends ActiveTranslationJobAggregateArgs> = {
        [P in keyof T & keyof AggregateActiveTranslationJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActiveTranslationJob[P]>
      : GetScalarType<T[P], AggregateActiveTranslationJob[P]>
  }




  export type ActiveTranslationJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiveTranslationJobWhereInput
    orderBy?: ActiveTranslationJobOrderByWithAggregationInput | ActiveTranslationJobOrderByWithAggregationInput[]
    by: ActiveTranslationJobScalarFieldEnum[] | ActiveTranslationJobScalarFieldEnum
    having?: ActiveTranslationJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActiveTranslationJobCountAggregateInputType | true
    _avg?: ActiveTranslationJobAvgAggregateInputType
    _sum?: ActiveTranslationJobSumAggregateInputType
    _min?: ActiveTranslationJobMinAggregateInputType
    _max?: ActiveTranslationJobMaxAggregateInputType
  }

  export type ActiveTranslationJobGroupByOutputType = {
    id: string
    jobId: string
    workId: string
    workTitle: string
    userId: string
    userEmail: string | null
    status: string
    isPauseRequested: boolean
    batchPlan: JsonValue | null
    totalBatches: number
    currentBatchIndex: number
    retryCount: number
    maxRetries: number
    lastError: string | null
    totalChapters: number
    completedChapters: number
    failedChapters: number
    currentChapterNum: number | null
    currentChunkIndex: number | null
    totalChunks: number | null
    chaptersProgress: JsonValue | null
    failedChapterNums: number[]
    autoRetryCount: number
    maxAutoRetries: number
    errorMessage: string | null
    lockedAt: Date | null
    lockedBy: string | null
    startedAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: ActiveTranslationJobCountAggregateOutputType | null
    _avg: ActiveTranslationJobAvgAggregateOutputType | null
    _sum: ActiveTranslationJobSumAggregateOutputType | null
    _min: ActiveTranslationJobMinAggregateOutputType | null
    _max: ActiveTranslationJobMaxAggregateOutputType | null
  }

  type GetActiveTranslationJobGroupByPayload<T extends ActiveTranslationJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActiveTranslationJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActiveTranslationJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActiveTranslationJobGroupByOutputType[P]>
            : GetScalarType<T[P], ActiveTranslationJobGroupByOutputType[P]>
        }
      >
    >


  export type ActiveTranslationJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    workId?: boolean
    workTitle?: boolean
    userId?: boolean
    userEmail?: boolean
    status?: boolean
    isPauseRequested?: boolean
    batchPlan?: boolean
    totalBatches?: boolean
    currentBatchIndex?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    lastError?: boolean
    totalChapters?: boolean
    completedChapters?: boolean
    failedChapters?: boolean
    currentChapterNum?: boolean
    currentChunkIndex?: boolean
    totalChunks?: boolean
    chaptersProgress?: boolean
    failedChapterNums?: boolean
    autoRetryCount?: boolean
    maxAutoRetries?: boolean
    errorMessage?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["activeTranslationJob"]>

  export type ActiveTranslationJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    workId?: boolean
    workTitle?: boolean
    userId?: boolean
    userEmail?: boolean
    status?: boolean
    isPauseRequested?: boolean
    batchPlan?: boolean
    totalBatches?: boolean
    currentBatchIndex?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    lastError?: boolean
    totalChapters?: boolean
    completedChapters?: boolean
    failedChapters?: boolean
    currentChapterNum?: boolean
    currentChunkIndex?: boolean
    totalChunks?: boolean
    chaptersProgress?: boolean
    failedChapterNums?: boolean
    autoRetryCount?: boolean
    maxAutoRetries?: boolean
    errorMessage?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["activeTranslationJob"]>

  export type ActiveTranslationJobSelectScalar = {
    id?: boolean
    jobId?: boolean
    workId?: boolean
    workTitle?: boolean
    userId?: boolean
    userEmail?: boolean
    status?: boolean
    isPauseRequested?: boolean
    batchPlan?: boolean
    totalBatches?: boolean
    currentBatchIndex?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    lastError?: boolean
    totalChapters?: boolean
    completedChapters?: boolean
    failedChapters?: boolean
    currentChapterNum?: boolean
    currentChunkIndex?: boolean
    totalChunks?: boolean
    chaptersProgress?: boolean
    failedChapterNums?: boolean
    autoRetryCount?: boolean
    maxAutoRetries?: boolean
    errorMessage?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }


  export type $ActiveTranslationJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActiveTranslationJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      workId: string
      workTitle: string
      userId: string
      userEmail: string | null
      status: string
      isPauseRequested: boolean
      batchPlan: Prisma.JsonValue | null
      totalBatches: number
      currentBatchIndex: number
      retryCount: number
      maxRetries: number
      lastError: string | null
      totalChapters: number
      completedChapters: number
      failedChapters: number
      currentChapterNum: number | null
      currentChunkIndex: number | null
      totalChunks: number | null
      chaptersProgress: Prisma.JsonValue | null
      failedChapterNums: number[]
      autoRetryCount: number
      maxAutoRetries: number
      errorMessage: string | null
      lockedAt: Date | null
      lockedBy: string | null
      startedAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["activeTranslationJob"]>
    composites: {}
  }

  type ActiveTranslationJobGetPayload<S extends boolean | null | undefined | ActiveTranslationJobDefaultArgs> = $Result.GetResult<Prisma.$ActiveTranslationJobPayload, S>

  type ActiveTranslationJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActiveTranslationJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActiveTranslationJobCountAggregateInputType | true
    }

  export interface ActiveTranslationJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActiveTranslationJob'], meta: { name: 'ActiveTranslationJob' } }
    /**
     * Find zero or one ActiveTranslationJob that matches the filter.
     * @param {ActiveTranslationJobFindUniqueArgs} args - Arguments to find a ActiveTranslationJob
     * @example
     * // Get one ActiveTranslationJob
     * const activeTranslationJob = await prisma.activeTranslationJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActiveTranslationJobFindUniqueArgs>(args: SelectSubset<T, ActiveTranslationJobFindUniqueArgs<ExtArgs>>): Prisma__ActiveTranslationJobClient<$Result.GetResult<Prisma.$ActiveTranslationJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActiveTranslationJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActiveTranslationJobFindUniqueOrThrowArgs} args - Arguments to find a ActiveTranslationJob
     * @example
     * // Get one ActiveTranslationJob
     * const activeTranslationJob = await prisma.activeTranslationJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActiveTranslationJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ActiveTranslationJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActiveTranslationJobClient<$Result.GetResult<Prisma.$ActiveTranslationJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActiveTranslationJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveTranslationJobFindFirstArgs} args - Arguments to find a ActiveTranslationJob
     * @example
     * // Get one ActiveTranslationJob
     * const activeTranslationJob = await prisma.activeTranslationJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActiveTranslationJobFindFirstArgs>(args?: SelectSubset<T, ActiveTranslationJobFindFirstArgs<ExtArgs>>): Prisma__ActiveTranslationJobClient<$Result.GetResult<Prisma.$ActiveTranslationJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActiveTranslationJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveTranslationJobFindFirstOrThrowArgs} args - Arguments to find a ActiveTranslationJob
     * @example
     * // Get one ActiveTranslationJob
     * const activeTranslationJob = await prisma.activeTranslationJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActiveTranslationJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ActiveTranslationJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActiveTranslationJobClient<$Result.GetResult<Prisma.$ActiveTranslationJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActiveTranslationJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveTranslationJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActiveTranslationJobs
     * const activeTranslationJobs = await prisma.activeTranslationJob.findMany()
     * 
     * // Get first 10 ActiveTranslationJobs
     * const activeTranslationJobs = await prisma.activeTranslationJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activeTranslationJobWithIdOnly = await prisma.activeTranslationJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActiveTranslationJobFindManyArgs>(args?: SelectSubset<T, ActiveTranslationJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveTranslationJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActiveTranslationJob.
     * @param {ActiveTranslationJobCreateArgs} args - Arguments to create a ActiveTranslationJob.
     * @example
     * // Create one ActiveTranslationJob
     * const ActiveTranslationJob = await prisma.activeTranslationJob.create({
     *   data: {
     *     // ... data to create a ActiveTranslationJob
     *   }
     * })
     * 
     */
    create<T extends ActiveTranslationJobCreateArgs>(args: SelectSubset<T, ActiveTranslationJobCreateArgs<ExtArgs>>): Prisma__ActiveTranslationJobClient<$Result.GetResult<Prisma.$ActiveTranslationJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActiveTranslationJobs.
     * @param {ActiveTranslationJobCreateManyArgs} args - Arguments to create many ActiveTranslationJobs.
     * @example
     * // Create many ActiveTranslationJobs
     * const activeTranslationJob = await prisma.activeTranslationJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActiveTranslationJobCreateManyArgs>(args?: SelectSubset<T, ActiveTranslationJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActiveTranslationJobs and returns the data saved in the database.
     * @param {ActiveTranslationJobCreateManyAndReturnArgs} args - Arguments to create many ActiveTranslationJobs.
     * @example
     * // Create many ActiveTranslationJobs
     * const activeTranslationJob = await prisma.activeTranslationJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActiveTranslationJobs and only return the `id`
     * const activeTranslationJobWithIdOnly = await prisma.activeTranslationJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActiveTranslationJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ActiveTranslationJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveTranslationJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActiveTranslationJob.
     * @param {ActiveTranslationJobDeleteArgs} args - Arguments to delete one ActiveTranslationJob.
     * @example
     * // Delete one ActiveTranslationJob
     * const ActiveTranslationJob = await prisma.activeTranslationJob.delete({
     *   where: {
     *     // ... filter to delete one ActiveTranslationJob
     *   }
     * })
     * 
     */
    delete<T extends ActiveTranslationJobDeleteArgs>(args: SelectSubset<T, ActiveTranslationJobDeleteArgs<ExtArgs>>): Prisma__ActiveTranslationJobClient<$Result.GetResult<Prisma.$ActiveTranslationJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActiveTranslationJob.
     * @param {ActiveTranslationJobUpdateArgs} args - Arguments to update one ActiveTranslationJob.
     * @example
     * // Update one ActiveTranslationJob
     * const activeTranslationJob = await prisma.activeTranslationJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActiveTranslationJobUpdateArgs>(args: SelectSubset<T, ActiveTranslationJobUpdateArgs<ExtArgs>>): Prisma__ActiveTranslationJobClient<$Result.GetResult<Prisma.$ActiveTranslationJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActiveTranslationJobs.
     * @param {ActiveTranslationJobDeleteManyArgs} args - Arguments to filter ActiveTranslationJobs to delete.
     * @example
     * // Delete a few ActiveTranslationJobs
     * const { count } = await prisma.activeTranslationJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActiveTranslationJobDeleteManyArgs>(args?: SelectSubset<T, ActiveTranslationJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActiveTranslationJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveTranslationJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActiveTranslationJobs
     * const activeTranslationJob = await prisma.activeTranslationJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActiveTranslationJobUpdateManyArgs>(args: SelectSubset<T, ActiveTranslationJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActiveTranslationJob.
     * @param {ActiveTranslationJobUpsertArgs} args - Arguments to update or create a ActiveTranslationJob.
     * @example
     * // Update or create a ActiveTranslationJob
     * const activeTranslationJob = await prisma.activeTranslationJob.upsert({
     *   create: {
     *     // ... data to create a ActiveTranslationJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActiveTranslationJob we want to update
     *   }
     * })
     */
    upsert<T extends ActiveTranslationJobUpsertArgs>(args: SelectSubset<T, ActiveTranslationJobUpsertArgs<ExtArgs>>): Prisma__ActiveTranslationJobClient<$Result.GetResult<Prisma.$ActiveTranslationJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActiveTranslationJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveTranslationJobCountArgs} args - Arguments to filter ActiveTranslationJobs to count.
     * @example
     * // Count the number of ActiveTranslationJobs
     * const count = await prisma.activeTranslationJob.count({
     *   where: {
     *     // ... the filter for the ActiveTranslationJobs we want to count
     *   }
     * })
    **/
    count<T extends ActiveTranslationJobCountArgs>(
      args?: Subset<T, ActiveTranslationJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActiveTranslationJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActiveTranslationJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveTranslationJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActiveTranslationJobAggregateArgs>(args: Subset<T, ActiveTranslationJobAggregateArgs>): Prisma.PrismaPromise<GetActiveTranslationJobAggregateType<T>>

    /**
     * Group by ActiveTranslationJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveTranslationJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActiveTranslationJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActiveTranslationJobGroupByArgs['orderBy'] }
        : { orderBy?: ActiveTranslationJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActiveTranslationJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActiveTranslationJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActiveTranslationJob model
   */
  readonly fields: ActiveTranslationJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActiveTranslationJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActiveTranslationJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActiveTranslationJob model
   */ 
  interface ActiveTranslationJobFieldRefs {
    readonly id: FieldRef<"ActiveTranslationJob", 'String'>
    readonly jobId: FieldRef<"ActiveTranslationJob", 'String'>
    readonly workId: FieldRef<"ActiveTranslationJob", 'String'>
    readonly workTitle: FieldRef<"ActiveTranslationJob", 'String'>
    readonly userId: FieldRef<"ActiveTranslationJob", 'String'>
    readonly userEmail: FieldRef<"ActiveTranslationJob", 'String'>
    readonly status: FieldRef<"ActiveTranslationJob", 'String'>
    readonly isPauseRequested: FieldRef<"ActiveTranslationJob", 'Boolean'>
    readonly batchPlan: FieldRef<"ActiveTranslationJob", 'Json'>
    readonly totalBatches: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly currentBatchIndex: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly retryCount: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly maxRetries: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly lastError: FieldRef<"ActiveTranslationJob", 'String'>
    readonly totalChapters: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly completedChapters: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly failedChapters: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly currentChapterNum: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly currentChunkIndex: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly totalChunks: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly chaptersProgress: FieldRef<"ActiveTranslationJob", 'Json'>
    readonly failedChapterNums: FieldRef<"ActiveTranslationJob", 'Int[]'>
    readonly autoRetryCount: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly maxAutoRetries: FieldRef<"ActiveTranslationJob", 'Int'>
    readonly errorMessage: FieldRef<"ActiveTranslationJob", 'String'>
    readonly lockedAt: FieldRef<"ActiveTranslationJob", 'DateTime'>
    readonly lockedBy: FieldRef<"ActiveTranslationJob", 'String'>
    readonly startedAt: FieldRef<"ActiveTranslationJob", 'DateTime'>
    readonly updatedAt: FieldRef<"ActiveTranslationJob", 'DateTime'>
    readonly completedAt: FieldRef<"ActiveTranslationJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActiveTranslationJob findUnique
   */
  export type ActiveTranslationJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelect<ExtArgs> | null
    /**
     * Filter, which ActiveTranslationJob to fetch.
     */
    where: ActiveTranslationJobWhereUniqueInput
  }

  /**
   * ActiveTranslationJob findUniqueOrThrow
   */
  export type ActiveTranslationJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelect<ExtArgs> | null
    /**
     * Filter, which ActiveTranslationJob to fetch.
     */
    where: ActiveTranslationJobWhereUniqueInput
  }

  /**
   * ActiveTranslationJob findFirst
   */
  export type ActiveTranslationJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelect<ExtArgs> | null
    /**
     * Filter, which ActiveTranslationJob to fetch.
     */
    where?: ActiveTranslationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveTranslationJobs to fetch.
     */
    orderBy?: ActiveTranslationJobOrderByWithRelationInput | ActiveTranslationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiveTranslationJobs.
     */
    cursor?: ActiveTranslationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveTranslationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveTranslationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiveTranslationJobs.
     */
    distinct?: ActiveTranslationJobScalarFieldEnum | ActiveTranslationJobScalarFieldEnum[]
  }

  /**
   * ActiveTranslationJob findFirstOrThrow
   */
  export type ActiveTranslationJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelect<ExtArgs> | null
    /**
     * Filter, which ActiveTranslationJob to fetch.
     */
    where?: ActiveTranslationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveTranslationJobs to fetch.
     */
    orderBy?: ActiveTranslationJobOrderByWithRelationInput | ActiveTranslationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiveTranslationJobs.
     */
    cursor?: ActiveTranslationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveTranslationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveTranslationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiveTranslationJobs.
     */
    distinct?: ActiveTranslationJobScalarFieldEnum | ActiveTranslationJobScalarFieldEnum[]
  }

  /**
   * ActiveTranslationJob findMany
   */
  export type ActiveTranslationJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelect<ExtArgs> | null
    /**
     * Filter, which ActiveTranslationJobs to fetch.
     */
    where?: ActiveTranslationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveTranslationJobs to fetch.
     */
    orderBy?: ActiveTranslationJobOrderByWithRelationInput | ActiveTranslationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActiveTranslationJobs.
     */
    cursor?: ActiveTranslationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveTranslationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveTranslationJobs.
     */
    skip?: number
    distinct?: ActiveTranslationJobScalarFieldEnum | ActiveTranslationJobScalarFieldEnum[]
  }

  /**
   * ActiveTranslationJob create
   */
  export type ActiveTranslationJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelect<ExtArgs> | null
    /**
     * The data needed to create a ActiveTranslationJob.
     */
    data: XOR<ActiveTranslationJobCreateInput, ActiveTranslationJobUncheckedCreateInput>
  }

  /**
   * ActiveTranslationJob createMany
   */
  export type ActiveTranslationJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActiveTranslationJobs.
     */
    data: ActiveTranslationJobCreateManyInput | ActiveTranslationJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActiveTranslationJob createManyAndReturn
   */
  export type ActiveTranslationJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActiveTranslationJobs.
     */
    data: ActiveTranslationJobCreateManyInput | ActiveTranslationJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActiveTranslationJob update
   */
  export type ActiveTranslationJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelect<ExtArgs> | null
    /**
     * The data needed to update a ActiveTranslationJob.
     */
    data: XOR<ActiveTranslationJobUpdateInput, ActiveTranslationJobUncheckedUpdateInput>
    /**
     * Choose, which ActiveTranslationJob to update.
     */
    where: ActiveTranslationJobWhereUniqueInput
  }

  /**
   * ActiveTranslationJob updateMany
   */
  export type ActiveTranslationJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActiveTranslationJobs.
     */
    data: XOR<ActiveTranslationJobUpdateManyMutationInput, ActiveTranslationJobUncheckedUpdateManyInput>
    /**
     * Filter which ActiveTranslationJobs to update
     */
    where?: ActiveTranslationJobWhereInput
  }

  /**
   * ActiveTranslationJob upsert
   */
  export type ActiveTranslationJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelect<ExtArgs> | null
    /**
     * The filter to search for the ActiveTranslationJob to update in case it exists.
     */
    where: ActiveTranslationJobWhereUniqueInput
    /**
     * In case the ActiveTranslationJob found by the `where` argument doesn't exist, create a new ActiveTranslationJob with this data.
     */
    create: XOR<ActiveTranslationJobCreateInput, ActiveTranslationJobUncheckedCreateInput>
    /**
     * In case the ActiveTranslationJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActiveTranslationJobUpdateInput, ActiveTranslationJobUncheckedUpdateInput>
  }

  /**
   * ActiveTranslationJob delete
   */
  export type ActiveTranslationJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelect<ExtArgs> | null
    /**
     * Filter which ActiveTranslationJob to delete.
     */
    where: ActiveTranslationJobWhereUniqueInput
  }

  /**
   * ActiveTranslationJob deleteMany
   */
  export type ActiveTranslationJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiveTranslationJobs to delete
     */
    where?: ActiveTranslationJobWhereInput
  }

  /**
   * ActiveTranslationJob without action
   */
  export type ActiveTranslationJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveTranslationJob
     */
    select?: ActiveTranslationJobSelect<ExtArgs> | null
  }


  /**
   * Model TranslationJobHistory
   */

  export type AggregateTranslationJobHistory = {
    _count: TranslationJobHistoryCountAggregateOutputType | null
    _avg: TranslationJobHistoryAvgAggregateOutputType | null
    _sum: TranslationJobHistorySumAggregateOutputType | null
    _min: TranslationJobHistoryMinAggregateOutputType | null
    _max: TranslationJobHistoryMaxAggregateOutputType | null
  }

  export type TranslationJobHistoryAvgAggregateOutputType = {
    totalChapters: number | null
    completedChapters: number | null
    failedChapters: number | null
    failedChapterNums: number | null
    durationMs: number | null
  }

  export type TranslationJobHistorySumAggregateOutputType = {
    totalChapters: number | null
    completedChapters: number | null
    failedChapters: number | null
    failedChapterNums: number[]
    durationMs: number | null
  }

  export type TranslationJobHistoryMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    workId: string | null
    workTitle: string | null
    userId: string | null
    userEmail: string | null
    status: string | null
    totalChapters: number | null
    completedChapters: number | null
    failedChapters: number | null
    errorMessage: string | null
    startedAt: Date | null
    completedAt: Date | null
    durationMs: number | null
    createdAt: Date | null
  }

  export type TranslationJobHistoryMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    workId: string | null
    workTitle: string | null
    userId: string | null
    userEmail: string | null
    status: string | null
    totalChapters: number | null
    completedChapters: number | null
    failedChapters: number | null
    errorMessage: string | null
    startedAt: Date | null
    completedAt: Date | null
    durationMs: number | null
    createdAt: Date | null
  }

  export type TranslationJobHistoryCountAggregateOutputType = {
    id: number
    jobId: number
    workId: number
    workTitle: number
    userId: number
    userEmail: number
    status: number
    totalChapters: number
    completedChapters: number
    failedChapters: number
    errorMessage: number
    failedChapterNums: number
    startedAt: number
    completedAt: number
    durationMs: number
    createdAt: number
    _all: number
  }


  export type TranslationJobHistoryAvgAggregateInputType = {
    totalChapters?: true
    completedChapters?: true
    failedChapters?: true
    failedChapterNums?: true
    durationMs?: true
  }

  export type TranslationJobHistorySumAggregateInputType = {
    totalChapters?: true
    completedChapters?: true
    failedChapters?: true
    failedChapterNums?: true
    durationMs?: true
  }

  export type TranslationJobHistoryMinAggregateInputType = {
    id?: true
    jobId?: true
    workId?: true
    workTitle?: true
    userId?: true
    userEmail?: true
    status?: true
    totalChapters?: true
    completedChapters?: true
    failedChapters?: true
    errorMessage?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    createdAt?: true
  }

  export type TranslationJobHistoryMaxAggregateInputType = {
    id?: true
    jobId?: true
    workId?: true
    workTitle?: true
    userId?: true
    userEmail?: true
    status?: true
    totalChapters?: true
    completedChapters?: true
    failedChapters?: true
    errorMessage?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    createdAt?: true
  }

  export type TranslationJobHistoryCountAggregateInputType = {
    id?: true
    jobId?: true
    workId?: true
    workTitle?: true
    userId?: true
    userEmail?: true
    status?: true
    totalChapters?: true
    completedChapters?: true
    failedChapters?: true
    errorMessage?: true
    failedChapterNums?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    createdAt?: true
    _all?: true
  }

  export type TranslationJobHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranslationJobHistory to aggregate.
     */
    where?: TranslationJobHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationJobHistories to fetch.
     */
    orderBy?: TranslationJobHistoryOrderByWithRelationInput | TranslationJobHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranslationJobHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationJobHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationJobHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranslationJobHistories
    **/
    _count?: true | TranslationJobHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranslationJobHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranslationJobHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationJobHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationJobHistoryMaxAggregateInputType
  }

  export type GetTranslationJobHistoryAggregateType<T extends TranslationJobHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslationJobHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslationJobHistory[P]>
      : GetScalarType<T[P], AggregateTranslationJobHistory[P]>
  }




  export type TranslationJobHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationJobHistoryWhereInput
    orderBy?: TranslationJobHistoryOrderByWithAggregationInput | TranslationJobHistoryOrderByWithAggregationInput[]
    by: TranslationJobHistoryScalarFieldEnum[] | TranslationJobHistoryScalarFieldEnum
    having?: TranslationJobHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationJobHistoryCountAggregateInputType | true
    _avg?: TranslationJobHistoryAvgAggregateInputType
    _sum?: TranslationJobHistorySumAggregateInputType
    _min?: TranslationJobHistoryMinAggregateInputType
    _max?: TranslationJobHistoryMaxAggregateInputType
  }

  export type TranslationJobHistoryGroupByOutputType = {
    id: string
    jobId: string
    workId: string
    workTitle: string
    userId: string
    userEmail: string | null
    status: string
    totalChapters: number
    completedChapters: number
    failedChapters: number
    errorMessage: string | null
    failedChapterNums: number[]
    startedAt: Date
    completedAt: Date | null
    durationMs: number | null
    createdAt: Date
    _count: TranslationJobHistoryCountAggregateOutputType | null
    _avg: TranslationJobHistoryAvgAggregateOutputType | null
    _sum: TranslationJobHistorySumAggregateOutputType | null
    _min: TranslationJobHistoryMinAggregateOutputType | null
    _max: TranslationJobHistoryMaxAggregateOutputType | null
  }

  type GetTranslationJobHistoryGroupByPayload<T extends TranslationJobHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranslationJobHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationJobHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationJobHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationJobHistoryGroupByOutputType[P]>
        }
      >
    >


  export type TranslationJobHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    workId?: boolean
    workTitle?: boolean
    userId?: boolean
    userEmail?: boolean
    status?: boolean
    totalChapters?: boolean
    completedChapters?: boolean
    failedChapters?: boolean
    errorMessage?: boolean
    failedChapterNums?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["translationJobHistory"]>

  export type TranslationJobHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    workId?: boolean
    workTitle?: boolean
    userId?: boolean
    userEmail?: boolean
    status?: boolean
    totalChapters?: boolean
    completedChapters?: boolean
    failedChapters?: boolean
    errorMessage?: boolean
    failedChapterNums?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["translationJobHistory"]>

  export type TranslationJobHistorySelectScalar = {
    id?: boolean
    jobId?: boolean
    workId?: boolean
    workTitle?: boolean
    userId?: boolean
    userEmail?: boolean
    status?: boolean
    totalChapters?: boolean
    completedChapters?: boolean
    failedChapters?: boolean
    errorMessage?: boolean
    failedChapterNums?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    createdAt?: boolean
  }


  export type $TranslationJobHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TranslationJobHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      workId: string
      workTitle: string
      userId: string
      userEmail: string | null
      status: string
      totalChapters: number
      completedChapters: number
      failedChapters: number
      errorMessage: string | null
      failedChapterNums: number[]
      startedAt: Date
      completedAt: Date | null
      durationMs: number | null
      createdAt: Date
    }, ExtArgs["result"]["translationJobHistory"]>
    composites: {}
  }

  type TranslationJobHistoryGetPayload<S extends boolean | null | undefined | TranslationJobHistoryDefaultArgs> = $Result.GetResult<Prisma.$TranslationJobHistoryPayload, S>

  type TranslationJobHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TranslationJobHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TranslationJobHistoryCountAggregateInputType | true
    }

  export interface TranslationJobHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TranslationJobHistory'], meta: { name: 'TranslationJobHistory' } }
    /**
     * Find zero or one TranslationJobHistory that matches the filter.
     * @param {TranslationJobHistoryFindUniqueArgs} args - Arguments to find a TranslationJobHistory
     * @example
     * // Get one TranslationJobHistory
     * const translationJobHistory = await prisma.translationJobHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranslationJobHistoryFindUniqueArgs>(args: SelectSubset<T, TranslationJobHistoryFindUniqueArgs<ExtArgs>>): Prisma__TranslationJobHistoryClient<$Result.GetResult<Prisma.$TranslationJobHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TranslationJobHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TranslationJobHistoryFindUniqueOrThrowArgs} args - Arguments to find a TranslationJobHistory
     * @example
     * // Get one TranslationJobHistory
     * const translationJobHistory = await prisma.translationJobHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranslationJobHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TranslationJobHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranslationJobHistoryClient<$Result.GetResult<Prisma.$TranslationJobHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TranslationJobHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationJobHistoryFindFirstArgs} args - Arguments to find a TranslationJobHistory
     * @example
     * // Get one TranslationJobHistory
     * const translationJobHistory = await prisma.translationJobHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranslationJobHistoryFindFirstArgs>(args?: SelectSubset<T, TranslationJobHistoryFindFirstArgs<ExtArgs>>): Prisma__TranslationJobHistoryClient<$Result.GetResult<Prisma.$TranslationJobHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TranslationJobHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationJobHistoryFindFirstOrThrowArgs} args - Arguments to find a TranslationJobHistory
     * @example
     * // Get one TranslationJobHistory
     * const translationJobHistory = await prisma.translationJobHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranslationJobHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TranslationJobHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranslationJobHistoryClient<$Result.GetResult<Prisma.$TranslationJobHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TranslationJobHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationJobHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranslationJobHistories
     * const translationJobHistories = await prisma.translationJobHistory.findMany()
     * 
     * // Get first 10 TranslationJobHistories
     * const translationJobHistories = await prisma.translationJobHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const translationJobHistoryWithIdOnly = await prisma.translationJobHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranslationJobHistoryFindManyArgs>(args?: SelectSubset<T, TranslationJobHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationJobHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TranslationJobHistory.
     * @param {TranslationJobHistoryCreateArgs} args - Arguments to create a TranslationJobHistory.
     * @example
     * // Create one TranslationJobHistory
     * const TranslationJobHistory = await prisma.translationJobHistory.create({
     *   data: {
     *     // ... data to create a TranslationJobHistory
     *   }
     * })
     * 
     */
    create<T extends TranslationJobHistoryCreateArgs>(args: SelectSubset<T, TranslationJobHistoryCreateArgs<ExtArgs>>): Prisma__TranslationJobHistoryClient<$Result.GetResult<Prisma.$TranslationJobHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TranslationJobHistories.
     * @param {TranslationJobHistoryCreateManyArgs} args - Arguments to create many TranslationJobHistories.
     * @example
     * // Create many TranslationJobHistories
     * const translationJobHistory = await prisma.translationJobHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranslationJobHistoryCreateManyArgs>(args?: SelectSubset<T, TranslationJobHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TranslationJobHistories and returns the data saved in the database.
     * @param {TranslationJobHistoryCreateManyAndReturnArgs} args - Arguments to create many TranslationJobHistories.
     * @example
     * // Create many TranslationJobHistories
     * const translationJobHistory = await prisma.translationJobHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TranslationJobHistories and only return the `id`
     * const translationJobHistoryWithIdOnly = await prisma.translationJobHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranslationJobHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TranslationJobHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationJobHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TranslationJobHistory.
     * @param {TranslationJobHistoryDeleteArgs} args - Arguments to delete one TranslationJobHistory.
     * @example
     * // Delete one TranslationJobHistory
     * const TranslationJobHistory = await prisma.translationJobHistory.delete({
     *   where: {
     *     // ... filter to delete one TranslationJobHistory
     *   }
     * })
     * 
     */
    delete<T extends TranslationJobHistoryDeleteArgs>(args: SelectSubset<T, TranslationJobHistoryDeleteArgs<ExtArgs>>): Prisma__TranslationJobHistoryClient<$Result.GetResult<Prisma.$TranslationJobHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TranslationJobHistory.
     * @param {TranslationJobHistoryUpdateArgs} args - Arguments to update one TranslationJobHistory.
     * @example
     * // Update one TranslationJobHistory
     * const translationJobHistory = await prisma.translationJobHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranslationJobHistoryUpdateArgs>(args: SelectSubset<T, TranslationJobHistoryUpdateArgs<ExtArgs>>): Prisma__TranslationJobHistoryClient<$Result.GetResult<Prisma.$TranslationJobHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TranslationJobHistories.
     * @param {TranslationJobHistoryDeleteManyArgs} args - Arguments to filter TranslationJobHistories to delete.
     * @example
     * // Delete a few TranslationJobHistories
     * const { count } = await prisma.translationJobHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranslationJobHistoryDeleteManyArgs>(args?: SelectSubset<T, TranslationJobHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranslationJobHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationJobHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranslationJobHistories
     * const translationJobHistory = await prisma.translationJobHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranslationJobHistoryUpdateManyArgs>(args: SelectSubset<T, TranslationJobHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TranslationJobHistory.
     * @param {TranslationJobHistoryUpsertArgs} args - Arguments to update or create a TranslationJobHistory.
     * @example
     * // Update or create a TranslationJobHistory
     * const translationJobHistory = await prisma.translationJobHistory.upsert({
     *   create: {
     *     // ... data to create a TranslationJobHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranslationJobHistory we want to update
     *   }
     * })
     */
    upsert<T extends TranslationJobHistoryUpsertArgs>(args: SelectSubset<T, TranslationJobHistoryUpsertArgs<ExtArgs>>): Prisma__TranslationJobHistoryClient<$Result.GetResult<Prisma.$TranslationJobHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TranslationJobHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationJobHistoryCountArgs} args - Arguments to filter TranslationJobHistories to count.
     * @example
     * // Count the number of TranslationJobHistories
     * const count = await prisma.translationJobHistory.count({
     *   where: {
     *     // ... the filter for the TranslationJobHistories we want to count
     *   }
     * })
    **/
    count<T extends TranslationJobHistoryCountArgs>(
      args?: Subset<T, TranslationJobHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationJobHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranslationJobHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationJobHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationJobHistoryAggregateArgs>(args: Subset<T, TranslationJobHistoryAggregateArgs>): Prisma.PrismaPromise<GetTranslationJobHistoryAggregateType<T>>

    /**
     * Group by TranslationJobHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationJobHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranslationJobHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranslationJobHistoryGroupByArgs['orderBy'] }
        : { orderBy?: TranslationJobHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranslationJobHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationJobHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TranslationJobHistory model
   */
  readonly fields: TranslationJobHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranslationJobHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranslationJobHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TranslationJobHistory model
   */ 
  interface TranslationJobHistoryFieldRefs {
    readonly id: FieldRef<"TranslationJobHistory", 'String'>
    readonly jobId: FieldRef<"TranslationJobHistory", 'String'>
    readonly workId: FieldRef<"TranslationJobHistory", 'String'>
    readonly workTitle: FieldRef<"TranslationJobHistory", 'String'>
    readonly userId: FieldRef<"TranslationJobHistory", 'String'>
    readonly userEmail: FieldRef<"TranslationJobHistory", 'String'>
    readonly status: FieldRef<"TranslationJobHistory", 'String'>
    readonly totalChapters: FieldRef<"TranslationJobHistory", 'Int'>
    readonly completedChapters: FieldRef<"TranslationJobHistory", 'Int'>
    readonly failedChapters: FieldRef<"TranslationJobHistory", 'Int'>
    readonly errorMessage: FieldRef<"TranslationJobHistory", 'String'>
    readonly failedChapterNums: FieldRef<"TranslationJobHistory", 'Int[]'>
    readonly startedAt: FieldRef<"TranslationJobHistory", 'DateTime'>
    readonly completedAt: FieldRef<"TranslationJobHistory", 'DateTime'>
    readonly durationMs: FieldRef<"TranslationJobHistory", 'Int'>
    readonly createdAt: FieldRef<"TranslationJobHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TranslationJobHistory findUnique
   */
  export type TranslationJobHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelect<ExtArgs> | null
    /**
     * Filter, which TranslationJobHistory to fetch.
     */
    where: TranslationJobHistoryWhereUniqueInput
  }

  /**
   * TranslationJobHistory findUniqueOrThrow
   */
  export type TranslationJobHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelect<ExtArgs> | null
    /**
     * Filter, which TranslationJobHistory to fetch.
     */
    where: TranslationJobHistoryWhereUniqueInput
  }

  /**
   * TranslationJobHistory findFirst
   */
  export type TranslationJobHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelect<ExtArgs> | null
    /**
     * Filter, which TranslationJobHistory to fetch.
     */
    where?: TranslationJobHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationJobHistories to fetch.
     */
    orderBy?: TranslationJobHistoryOrderByWithRelationInput | TranslationJobHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranslationJobHistories.
     */
    cursor?: TranslationJobHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationJobHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationJobHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranslationJobHistories.
     */
    distinct?: TranslationJobHistoryScalarFieldEnum | TranslationJobHistoryScalarFieldEnum[]
  }

  /**
   * TranslationJobHistory findFirstOrThrow
   */
  export type TranslationJobHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelect<ExtArgs> | null
    /**
     * Filter, which TranslationJobHistory to fetch.
     */
    where?: TranslationJobHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationJobHistories to fetch.
     */
    orderBy?: TranslationJobHistoryOrderByWithRelationInput | TranslationJobHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranslationJobHistories.
     */
    cursor?: TranslationJobHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationJobHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationJobHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranslationJobHistories.
     */
    distinct?: TranslationJobHistoryScalarFieldEnum | TranslationJobHistoryScalarFieldEnum[]
  }

  /**
   * TranslationJobHistory findMany
   */
  export type TranslationJobHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelect<ExtArgs> | null
    /**
     * Filter, which TranslationJobHistories to fetch.
     */
    where?: TranslationJobHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationJobHistories to fetch.
     */
    orderBy?: TranslationJobHistoryOrderByWithRelationInput | TranslationJobHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranslationJobHistories.
     */
    cursor?: TranslationJobHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationJobHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationJobHistories.
     */
    skip?: number
    distinct?: TranslationJobHistoryScalarFieldEnum | TranslationJobHistoryScalarFieldEnum[]
  }

  /**
   * TranslationJobHistory create
   */
  export type TranslationJobHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a TranslationJobHistory.
     */
    data: XOR<TranslationJobHistoryCreateInput, TranslationJobHistoryUncheckedCreateInput>
  }

  /**
   * TranslationJobHistory createMany
   */
  export type TranslationJobHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TranslationJobHistories.
     */
    data: TranslationJobHistoryCreateManyInput | TranslationJobHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranslationJobHistory createManyAndReturn
   */
  export type TranslationJobHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TranslationJobHistories.
     */
    data: TranslationJobHistoryCreateManyInput | TranslationJobHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranslationJobHistory update
   */
  export type TranslationJobHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a TranslationJobHistory.
     */
    data: XOR<TranslationJobHistoryUpdateInput, TranslationJobHistoryUncheckedUpdateInput>
    /**
     * Choose, which TranslationJobHistory to update.
     */
    where: TranslationJobHistoryWhereUniqueInput
  }

  /**
   * TranslationJobHistory updateMany
   */
  export type TranslationJobHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TranslationJobHistories.
     */
    data: XOR<TranslationJobHistoryUpdateManyMutationInput, TranslationJobHistoryUncheckedUpdateManyInput>
    /**
     * Filter which TranslationJobHistories to update
     */
    where?: TranslationJobHistoryWhereInput
  }

  /**
   * TranslationJobHistory upsert
   */
  export type TranslationJobHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the TranslationJobHistory to update in case it exists.
     */
    where: TranslationJobHistoryWhereUniqueInput
    /**
     * In case the TranslationJobHistory found by the `where` argument doesn't exist, create a new TranslationJobHistory with this data.
     */
    create: XOR<TranslationJobHistoryCreateInput, TranslationJobHistoryUncheckedCreateInput>
    /**
     * In case the TranslationJobHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranslationJobHistoryUpdateInput, TranslationJobHistoryUncheckedUpdateInput>
  }

  /**
   * TranslationJobHistory delete
   */
  export type TranslationJobHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelect<ExtArgs> | null
    /**
     * Filter which TranslationJobHistory to delete.
     */
    where: TranslationJobHistoryWhereUniqueInput
  }

  /**
   * TranslationJobHistory deleteMany
   */
  export type TranslationJobHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranslationJobHistories to delete
     */
    where?: TranslationJobHistoryWhereInput
  }

  /**
   * TranslationJobHistory without action
   */
  export type TranslationJobHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationJobHistory
     */
    select?: TranslationJobHistorySelect<ExtArgs> | null
  }


  /**
   * Model SettingBible
   */

  export type AggregateSettingBible = {
    _count: SettingBibleCountAggregateOutputType | null
    _avg: SettingBibleAvgAggregateOutputType | null
    _sum: SettingBibleSumAggregateOutputType | null
    _min: SettingBibleMinAggregateOutputType | null
    _max: SettingBibleMaxAggregateOutputType | null
  }

  export type SettingBibleAvgAggregateOutputType = {
    version: number | null
    analyzedChapters: number | null
  }

  export type SettingBibleSumAggregateOutputType = {
    version: number | null
    analyzedChapters: number | null
  }

  export type SettingBibleMinAggregateOutputType = {
    id: string | null
    workId: string | null
    status: $Enums.BibleStatus | null
    version: number | null
    translationGuide: string | null
    analyzedChapters: number | null
    generatedAt: Date | null
    confirmedAt: Date | null
    confirmedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingBibleMaxAggregateOutputType = {
    id: string | null
    workId: string | null
    status: $Enums.BibleStatus | null
    version: number | null
    translationGuide: string | null
    analyzedChapters: number | null
    generatedAt: Date | null
    confirmedAt: Date | null
    confirmedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingBibleCountAggregateOutputType = {
    id: number
    workId: number
    status: number
    version: number
    translationGuide: number
    analyzedChapters: number
    generatedAt: number
    confirmedAt: number
    confirmedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingBibleAvgAggregateInputType = {
    version?: true
    analyzedChapters?: true
  }

  export type SettingBibleSumAggregateInputType = {
    version?: true
    analyzedChapters?: true
  }

  export type SettingBibleMinAggregateInputType = {
    id?: true
    workId?: true
    status?: true
    version?: true
    translationGuide?: true
    analyzedChapters?: true
    generatedAt?: true
    confirmedAt?: true
    confirmedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingBibleMaxAggregateInputType = {
    id?: true
    workId?: true
    status?: true
    version?: true
    translationGuide?: true
    analyzedChapters?: true
    generatedAt?: true
    confirmedAt?: true
    confirmedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingBibleCountAggregateInputType = {
    id?: true
    workId?: true
    status?: true
    version?: true
    translationGuide?: true
    analyzedChapters?: true
    generatedAt?: true
    confirmedAt?: true
    confirmedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingBibleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingBible to aggregate.
     */
    where?: SettingBibleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingBibles to fetch.
     */
    orderBy?: SettingBibleOrderByWithRelationInput | SettingBibleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingBibleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingBibles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingBibles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettingBibles
    **/
    _count?: true | SettingBibleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingBibleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingBibleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingBibleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingBibleMaxAggregateInputType
  }

  export type GetSettingBibleAggregateType<T extends SettingBibleAggregateArgs> = {
        [P in keyof T & keyof AggregateSettingBible]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettingBible[P]>
      : GetScalarType<T[P], AggregateSettingBible[P]>
  }




  export type SettingBibleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingBibleWhereInput
    orderBy?: SettingBibleOrderByWithAggregationInput | SettingBibleOrderByWithAggregationInput[]
    by: SettingBibleScalarFieldEnum[] | SettingBibleScalarFieldEnum
    having?: SettingBibleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingBibleCountAggregateInputType | true
    _avg?: SettingBibleAvgAggregateInputType
    _sum?: SettingBibleSumAggregateInputType
    _min?: SettingBibleMinAggregateInputType
    _max?: SettingBibleMaxAggregateInputType
  }

  export type SettingBibleGroupByOutputType = {
    id: string
    workId: string
    status: $Enums.BibleStatus
    version: number
    translationGuide: string | null
    analyzedChapters: number
    generatedAt: Date | null
    confirmedAt: Date | null
    confirmedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: SettingBibleCountAggregateOutputType | null
    _avg: SettingBibleAvgAggregateOutputType | null
    _sum: SettingBibleSumAggregateOutputType | null
    _min: SettingBibleMinAggregateOutputType | null
    _max: SettingBibleMaxAggregateOutputType | null
  }

  type GetSettingBibleGroupByPayload<T extends SettingBibleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingBibleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingBibleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingBibleGroupByOutputType[P]>
            : GetScalarType<T[P], SettingBibleGroupByOutputType[P]>
        }
      >
    >


  export type SettingBibleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workId?: boolean
    status?: boolean
    version?: boolean
    translationGuide?: boolean
    analyzedChapters?: boolean
    generatedAt?: boolean
    confirmedAt?: boolean
    confirmedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    work?: boolean | WorkDefaultArgs<ExtArgs>
    characters?: boolean | SettingBible$charactersArgs<ExtArgs>
    terms?: boolean | SettingBible$termsArgs<ExtArgs>
    events?: boolean | SettingBible$eventsArgs<ExtArgs>
    _count?: boolean | SettingBibleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settingBible"]>

  export type SettingBibleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workId?: boolean
    status?: boolean
    version?: boolean
    translationGuide?: boolean
    analyzedChapters?: boolean
    generatedAt?: boolean
    confirmedAt?: boolean
    confirmedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settingBible"]>

  export type SettingBibleSelectScalar = {
    id?: boolean
    workId?: boolean
    status?: boolean
    version?: boolean
    translationGuide?: boolean
    analyzedChapters?: boolean
    generatedAt?: boolean
    confirmedAt?: boolean
    confirmedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingBibleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work?: boolean | WorkDefaultArgs<ExtArgs>
    characters?: boolean | SettingBible$charactersArgs<ExtArgs>
    terms?: boolean | SettingBible$termsArgs<ExtArgs>
    events?: boolean | SettingBible$eventsArgs<ExtArgs>
    _count?: boolean | SettingBibleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SettingBibleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }

  export type $SettingBiblePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettingBible"
    objects: {
      work: Prisma.$WorkPayload<ExtArgs>
      characters: Prisma.$CharacterPayload<ExtArgs>[]
      terms: Prisma.$SettingTermPayload<ExtArgs>[]
      events: Prisma.$TimelineEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workId: string
      status: $Enums.BibleStatus
      version: number
      translationGuide: string | null
      analyzedChapters: number
      generatedAt: Date | null
      confirmedAt: Date | null
      confirmedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["settingBible"]>
    composites: {}
  }

  type SettingBibleGetPayload<S extends boolean | null | undefined | SettingBibleDefaultArgs> = $Result.GetResult<Prisma.$SettingBiblePayload, S>

  type SettingBibleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingBibleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingBibleCountAggregateInputType | true
    }

  export interface SettingBibleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettingBible'], meta: { name: 'SettingBible' } }
    /**
     * Find zero or one SettingBible that matches the filter.
     * @param {SettingBibleFindUniqueArgs} args - Arguments to find a SettingBible
     * @example
     * // Get one SettingBible
     * const settingBible = await prisma.settingBible.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingBibleFindUniqueArgs>(args: SelectSubset<T, SettingBibleFindUniqueArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SettingBible that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingBibleFindUniqueOrThrowArgs} args - Arguments to find a SettingBible
     * @example
     * // Get one SettingBible
     * const settingBible = await prisma.settingBible.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingBibleFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingBibleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SettingBible that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingBibleFindFirstArgs} args - Arguments to find a SettingBible
     * @example
     * // Get one SettingBible
     * const settingBible = await prisma.settingBible.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingBibleFindFirstArgs>(args?: SelectSubset<T, SettingBibleFindFirstArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SettingBible that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingBibleFindFirstOrThrowArgs} args - Arguments to find a SettingBible
     * @example
     * // Get one SettingBible
     * const settingBible = await prisma.settingBible.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingBibleFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingBibleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SettingBibles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingBibleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettingBibles
     * const settingBibles = await prisma.settingBible.findMany()
     * 
     * // Get first 10 SettingBibles
     * const settingBibles = await prisma.settingBible.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingBibleWithIdOnly = await prisma.settingBible.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingBibleFindManyArgs>(args?: SelectSubset<T, SettingBibleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SettingBible.
     * @param {SettingBibleCreateArgs} args - Arguments to create a SettingBible.
     * @example
     * // Create one SettingBible
     * const SettingBible = await prisma.settingBible.create({
     *   data: {
     *     // ... data to create a SettingBible
     *   }
     * })
     * 
     */
    create<T extends SettingBibleCreateArgs>(args: SelectSubset<T, SettingBibleCreateArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SettingBibles.
     * @param {SettingBibleCreateManyArgs} args - Arguments to create many SettingBibles.
     * @example
     * // Create many SettingBibles
     * const settingBible = await prisma.settingBible.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingBibleCreateManyArgs>(args?: SelectSubset<T, SettingBibleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SettingBibles and returns the data saved in the database.
     * @param {SettingBibleCreateManyAndReturnArgs} args - Arguments to create many SettingBibles.
     * @example
     * // Create many SettingBibles
     * const settingBible = await prisma.settingBible.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SettingBibles and only return the `id`
     * const settingBibleWithIdOnly = await prisma.settingBible.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingBibleCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingBibleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SettingBible.
     * @param {SettingBibleDeleteArgs} args - Arguments to delete one SettingBible.
     * @example
     * // Delete one SettingBible
     * const SettingBible = await prisma.settingBible.delete({
     *   where: {
     *     // ... filter to delete one SettingBible
     *   }
     * })
     * 
     */
    delete<T extends SettingBibleDeleteArgs>(args: SelectSubset<T, SettingBibleDeleteArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SettingBible.
     * @param {SettingBibleUpdateArgs} args - Arguments to update one SettingBible.
     * @example
     * // Update one SettingBible
     * const settingBible = await prisma.settingBible.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingBibleUpdateArgs>(args: SelectSubset<T, SettingBibleUpdateArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SettingBibles.
     * @param {SettingBibleDeleteManyArgs} args - Arguments to filter SettingBibles to delete.
     * @example
     * // Delete a few SettingBibles
     * const { count } = await prisma.settingBible.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingBibleDeleteManyArgs>(args?: SelectSubset<T, SettingBibleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettingBibles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingBibleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettingBibles
     * const settingBible = await prisma.settingBible.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingBibleUpdateManyArgs>(args: SelectSubset<T, SettingBibleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SettingBible.
     * @param {SettingBibleUpsertArgs} args - Arguments to update or create a SettingBible.
     * @example
     * // Update or create a SettingBible
     * const settingBible = await prisma.settingBible.upsert({
     *   create: {
     *     // ... data to create a SettingBible
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettingBible we want to update
     *   }
     * })
     */
    upsert<T extends SettingBibleUpsertArgs>(args: SelectSubset<T, SettingBibleUpsertArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SettingBibles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingBibleCountArgs} args - Arguments to filter SettingBibles to count.
     * @example
     * // Count the number of SettingBibles
     * const count = await prisma.settingBible.count({
     *   where: {
     *     // ... the filter for the SettingBibles we want to count
     *   }
     * })
    **/
    count<T extends SettingBibleCountArgs>(
      args?: Subset<T, SettingBibleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingBibleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettingBible.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingBibleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingBibleAggregateArgs>(args: Subset<T, SettingBibleAggregateArgs>): Prisma.PrismaPromise<GetSettingBibleAggregateType<T>>

    /**
     * Group by SettingBible.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingBibleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingBibleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingBibleGroupByArgs['orderBy'] }
        : { orderBy?: SettingBibleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingBibleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingBibleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettingBible model
   */
  readonly fields: SettingBibleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettingBible.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingBibleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work<T extends WorkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkDefaultArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    characters<T extends SettingBible$charactersArgs<ExtArgs> = {}>(args?: Subset<T, SettingBible$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany"> | Null>
    terms<T extends SettingBible$termsArgs<ExtArgs> = {}>(args?: Subset<T, SettingBible$termsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends SettingBible$eventsArgs<ExtArgs> = {}>(args?: Subset<T, SettingBible$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettingBible model
   */ 
  interface SettingBibleFieldRefs {
    readonly id: FieldRef<"SettingBible", 'String'>
    readonly workId: FieldRef<"SettingBible", 'String'>
    readonly status: FieldRef<"SettingBible", 'BibleStatus'>
    readonly version: FieldRef<"SettingBible", 'Int'>
    readonly translationGuide: FieldRef<"SettingBible", 'String'>
    readonly analyzedChapters: FieldRef<"SettingBible", 'Int'>
    readonly generatedAt: FieldRef<"SettingBible", 'DateTime'>
    readonly confirmedAt: FieldRef<"SettingBible", 'DateTime'>
    readonly confirmedBy: FieldRef<"SettingBible", 'String'>
    readonly createdAt: FieldRef<"SettingBible", 'DateTime'>
    readonly updatedAt: FieldRef<"SettingBible", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SettingBible findUnique
   */
  export type SettingBibleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
    /**
     * Filter, which SettingBible to fetch.
     */
    where: SettingBibleWhereUniqueInput
  }

  /**
   * SettingBible findUniqueOrThrow
   */
  export type SettingBibleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
    /**
     * Filter, which SettingBible to fetch.
     */
    where: SettingBibleWhereUniqueInput
  }

  /**
   * SettingBible findFirst
   */
  export type SettingBibleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
    /**
     * Filter, which SettingBible to fetch.
     */
    where?: SettingBibleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingBibles to fetch.
     */
    orderBy?: SettingBibleOrderByWithRelationInput | SettingBibleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingBibles.
     */
    cursor?: SettingBibleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingBibles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingBibles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingBibles.
     */
    distinct?: SettingBibleScalarFieldEnum | SettingBibleScalarFieldEnum[]
  }

  /**
   * SettingBible findFirstOrThrow
   */
  export type SettingBibleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
    /**
     * Filter, which SettingBible to fetch.
     */
    where?: SettingBibleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingBibles to fetch.
     */
    orderBy?: SettingBibleOrderByWithRelationInput | SettingBibleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingBibles.
     */
    cursor?: SettingBibleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingBibles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingBibles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingBibles.
     */
    distinct?: SettingBibleScalarFieldEnum | SettingBibleScalarFieldEnum[]
  }

  /**
   * SettingBible findMany
   */
  export type SettingBibleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
    /**
     * Filter, which SettingBibles to fetch.
     */
    where?: SettingBibleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingBibles to fetch.
     */
    orderBy?: SettingBibleOrderByWithRelationInput | SettingBibleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettingBibles.
     */
    cursor?: SettingBibleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingBibles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingBibles.
     */
    skip?: number
    distinct?: SettingBibleScalarFieldEnum | SettingBibleScalarFieldEnum[]
  }

  /**
   * SettingBible create
   */
  export type SettingBibleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
    /**
     * The data needed to create a SettingBible.
     */
    data: XOR<SettingBibleCreateInput, SettingBibleUncheckedCreateInput>
  }

  /**
   * SettingBible createMany
   */
  export type SettingBibleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettingBibles.
     */
    data: SettingBibleCreateManyInput | SettingBibleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingBible createManyAndReturn
   */
  export type SettingBibleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SettingBibles.
     */
    data: SettingBibleCreateManyInput | SettingBibleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SettingBible update
   */
  export type SettingBibleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
    /**
     * The data needed to update a SettingBible.
     */
    data: XOR<SettingBibleUpdateInput, SettingBibleUncheckedUpdateInput>
    /**
     * Choose, which SettingBible to update.
     */
    where: SettingBibleWhereUniqueInput
  }

  /**
   * SettingBible updateMany
   */
  export type SettingBibleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettingBibles.
     */
    data: XOR<SettingBibleUpdateManyMutationInput, SettingBibleUncheckedUpdateManyInput>
    /**
     * Filter which SettingBibles to update
     */
    where?: SettingBibleWhereInput
  }

  /**
   * SettingBible upsert
   */
  export type SettingBibleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
    /**
     * The filter to search for the SettingBible to update in case it exists.
     */
    where: SettingBibleWhereUniqueInput
    /**
     * In case the SettingBible found by the `where` argument doesn't exist, create a new SettingBible with this data.
     */
    create: XOR<SettingBibleCreateInput, SettingBibleUncheckedCreateInput>
    /**
     * In case the SettingBible was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingBibleUpdateInput, SettingBibleUncheckedUpdateInput>
  }

  /**
   * SettingBible delete
   */
  export type SettingBibleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
    /**
     * Filter which SettingBible to delete.
     */
    where: SettingBibleWhereUniqueInput
  }

  /**
   * SettingBible deleteMany
   */
  export type SettingBibleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingBibles to delete
     */
    where?: SettingBibleWhereInput
  }

  /**
   * SettingBible.characters
   */
  export type SettingBible$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * SettingBible.terms
   */
  export type SettingBible$termsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
    where?: SettingTermWhereInput
    orderBy?: SettingTermOrderByWithRelationInput | SettingTermOrderByWithRelationInput[]
    cursor?: SettingTermWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingTermScalarFieldEnum | SettingTermScalarFieldEnum[]
  }

  /**
   * SettingBible.events
   */
  export type SettingBible$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    where?: TimelineEventWhereInput
    orderBy?: TimelineEventOrderByWithRelationInput | TimelineEventOrderByWithRelationInput[]
    cursor?: TimelineEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimelineEventScalarFieldEnum | TimelineEventScalarFieldEnum[]
  }

  /**
   * SettingBible without action
   */
  export type SettingBibleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingBible
     */
    select?: SettingBibleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingBibleInclude<ExtArgs> | null
  }


  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    firstAppearance: number | null
    sortOrder: number | null
  }

  export type CharacterSumAggregateOutputType = {
    firstAppearance: number | null
    sortOrder: number | null
  }

  export type CharacterMinAggregateOutputType = {
    id: string | null
    bibleId: string | null
    nameOriginal: string | null
    nameKorean: string | null
    nameHanja: string | null
    personality: string | null
    speechStyle: string | null
    role: $Enums.CharacterRole | null
    description: string | null
    firstAppearance: number | null
    sortOrder: number | null
    isConfirmed: boolean | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: string | null
    bibleId: string | null
    nameOriginal: string | null
    nameKorean: string | null
    nameHanja: string | null
    personality: string | null
    speechStyle: string | null
    role: $Enums.CharacterRole | null
    description: string | null
    firstAppearance: number | null
    sortOrder: number | null
    isConfirmed: boolean | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    bibleId: number
    nameOriginal: number
    nameKorean: number
    nameHanja: number
    titles: number
    aliases: number
    personality: number
    speechStyle: number
    role: number
    description: number
    relationships: number
    firstAppearance: number
    sortOrder: number
    isConfirmed: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    firstAppearance?: true
    sortOrder?: true
  }

  export type CharacterSumAggregateInputType = {
    firstAppearance?: true
    sortOrder?: true
  }

  export type CharacterMinAggregateInputType = {
    id?: true
    bibleId?: true
    nameOriginal?: true
    nameKorean?: true
    nameHanja?: true
    personality?: true
    speechStyle?: true
    role?: true
    description?: true
    firstAppearance?: true
    sortOrder?: true
    isConfirmed?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    bibleId?: true
    nameOriginal?: true
    nameKorean?: true
    nameHanja?: true
    personality?: true
    speechStyle?: true
    role?: true
    description?: true
    firstAppearance?: true
    sortOrder?: true
    isConfirmed?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    bibleId?: true
    nameOriginal?: true
    nameKorean?: true
    nameHanja?: true
    titles?: true
    aliases?: true
    personality?: true
    speechStyle?: true
    role?: true
    description?: true
    relationships?: true
    firstAppearance?: true
    sortOrder?: true
    isConfirmed?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    id: string
    bibleId: string
    nameOriginal: string
    nameKorean: string
    nameHanja: string | null
    titles: string[]
    aliases: string[]
    personality: string | null
    speechStyle: string | null
    role: $Enums.CharacterRole
    description: string | null
    relationships: JsonValue | null
    firstAppearance: number | null
    sortOrder: number
    isConfirmed: boolean
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bibleId?: boolean
    nameOriginal?: boolean
    nameKorean?: boolean
    nameHanja?: boolean
    titles?: boolean
    aliases?: boolean
    personality?: boolean
    speechStyle?: boolean
    role?: boolean
    description?: boolean
    relationships?: boolean
    firstAppearance?: boolean
    sortOrder?: boolean
    isConfirmed?: boolean
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bibleId?: boolean
    nameOriginal?: boolean
    nameKorean?: boolean
    nameHanja?: boolean
    titles?: boolean
    aliases?: boolean
    personality?: boolean
    speechStyle?: boolean
    role?: boolean
    description?: boolean
    relationships?: boolean
    firstAppearance?: boolean
    sortOrder?: boolean
    isConfirmed?: boolean
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    id?: boolean
    bibleId?: boolean
    nameOriginal?: boolean
    nameKorean?: boolean
    nameHanja?: boolean
    titles?: boolean
    aliases?: boolean
    personality?: boolean
    speechStyle?: boolean
    role?: boolean
    description?: boolean
    relationships?: boolean
    firstAppearance?: boolean
    sortOrder?: boolean
    isConfirmed?: boolean
  }

  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }
  export type CharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }

  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      bible: Prisma.$SettingBiblePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bibleId: string
      nameOriginal: string
      nameKorean: string
      nameHanja: string | null
      titles: string[]
      aliases: string[]
      personality: string | null
      speechStyle: string | null
      role: $Enums.CharacterRole
      description: string | null
      relationships: Prisma.JsonValue | null
      firstAppearance: number | null
      sortOrder: number
      isConfirmed: boolean
    }, ExtArgs["result"]["character"]>
    composites: {}
  }

  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterFindUniqueArgs>(args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Character that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterFindFirstArgs>(args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterFindManyArgs>(args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
     */
    create<T extends CharacterCreateArgs>(args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Characters.
     * @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterCreateManyArgs>(args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characters and returns the data saved in the database.
     * @param {CharacterCreateManyAndReturnArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
     */
    delete<T extends CharacterDeleteArgs>(args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterUpdateArgs>(args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterDeleteManyArgs>(args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterUpdateManyArgs>(args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
     */
    upsert<T extends CharacterUpsertArgs>(args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bible<T extends SettingBibleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SettingBibleDefaultArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Character model
   */ 
  interface CharacterFieldRefs {
    readonly id: FieldRef<"Character", 'String'>
    readonly bibleId: FieldRef<"Character", 'String'>
    readonly nameOriginal: FieldRef<"Character", 'String'>
    readonly nameKorean: FieldRef<"Character", 'String'>
    readonly nameHanja: FieldRef<"Character", 'String'>
    readonly titles: FieldRef<"Character", 'String[]'>
    readonly aliases: FieldRef<"Character", 'String[]'>
    readonly personality: FieldRef<"Character", 'String'>
    readonly speechStyle: FieldRef<"Character", 'String'>
    readonly role: FieldRef<"Character", 'CharacterRole'>
    readonly description: FieldRef<"Character", 'String'>
    readonly relationships: FieldRef<"Character", 'Json'>
    readonly firstAppearance: FieldRef<"Character", 'Int'>
    readonly sortOrder: FieldRef<"Character", 'Int'>
    readonly isConfirmed: FieldRef<"Character", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }

  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Character createManyAndReturn
   */
  export type CharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
  }

  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }

  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
  }

  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
  }


  /**
   * Model SettingTerm
   */

  export type AggregateSettingTerm = {
    _count: SettingTermCountAggregateOutputType | null
    _avg: SettingTermAvgAggregateOutputType | null
    _sum: SettingTermSumAggregateOutputType | null
    _min: SettingTermMinAggregateOutputType | null
    _max: SettingTermMaxAggregateOutputType | null
  }

  export type SettingTermAvgAggregateOutputType = {
    firstAppearance: number | null
    frequency: number | null
  }

  export type SettingTermSumAggregateOutputType = {
    firstAppearance: number | null
    frequency: number | null
  }

  export type SettingTermMinAggregateOutputType = {
    id: string | null
    bibleId: string | null
    original: string | null
    translated: string | null
    category: $Enums.TermCategory | null
    note: string | null
    context: string | null
    firstAppearance: number | null
    frequency: number | null
    isConfirmed: boolean | null
  }

  export type SettingTermMaxAggregateOutputType = {
    id: string | null
    bibleId: string | null
    original: string | null
    translated: string | null
    category: $Enums.TermCategory | null
    note: string | null
    context: string | null
    firstAppearance: number | null
    frequency: number | null
    isConfirmed: boolean | null
  }

  export type SettingTermCountAggregateOutputType = {
    id: number
    bibleId: number
    original: number
    translated: number
    category: number
    note: number
    context: number
    firstAppearance: number
    frequency: number
    isConfirmed: number
    _all: number
  }


  export type SettingTermAvgAggregateInputType = {
    firstAppearance?: true
    frequency?: true
  }

  export type SettingTermSumAggregateInputType = {
    firstAppearance?: true
    frequency?: true
  }

  export type SettingTermMinAggregateInputType = {
    id?: true
    bibleId?: true
    original?: true
    translated?: true
    category?: true
    note?: true
    context?: true
    firstAppearance?: true
    frequency?: true
    isConfirmed?: true
  }

  export type SettingTermMaxAggregateInputType = {
    id?: true
    bibleId?: true
    original?: true
    translated?: true
    category?: true
    note?: true
    context?: true
    firstAppearance?: true
    frequency?: true
    isConfirmed?: true
  }

  export type SettingTermCountAggregateInputType = {
    id?: true
    bibleId?: true
    original?: true
    translated?: true
    category?: true
    note?: true
    context?: true
    firstAppearance?: true
    frequency?: true
    isConfirmed?: true
    _all?: true
  }

  export type SettingTermAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingTerm to aggregate.
     */
    where?: SettingTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingTerms to fetch.
     */
    orderBy?: SettingTermOrderByWithRelationInput | SettingTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettingTerms
    **/
    _count?: true | SettingTermCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingTermAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingTermSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingTermMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingTermMaxAggregateInputType
  }

  export type GetSettingTermAggregateType<T extends SettingTermAggregateArgs> = {
        [P in keyof T & keyof AggregateSettingTerm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettingTerm[P]>
      : GetScalarType<T[P], AggregateSettingTerm[P]>
  }




  export type SettingTermGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingTermWhereInput
    orderBy?: SettingTermOrderByWithAggregationInput | SettingTermOrderByWithAggregationInput[]
    by: SettingTermScalarFieldEnum[] | SettingTermScalarFieldEnum
    having?: SettingTermScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingTermCountAggregateInputType | true
    _avg?: SettingTermAvgAggregateInputType
    _sum?: SettingTermSumAggregateInputType
    _min?: SettingTermMinAggregateInputType
    _max?: SettingTermMaxAggregateInputType
  }

  export type SettingTermGroupByOutputType = {
    id: string
    bibleId: string
    original: string
    translated: string
    category: $Enums.TermCategory
    note: string | null
    context: string | null
    firstAppearance: number | null
    frequency: number
    isConfirmed: boolean
    _count: SettingTermCountAggregateOutputType | null
    _avg: SettingTermAvgAggregateOutputType | null
    _sum: SettingTermSumAggregateOutputType | null
    _min: SettingTermMinAggregateOutputType | null
    _max: SettingTermMaxAggregateOutputType | null
  }

  type GetSettingTermGroupByPayload<T extends SettingTermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingTermGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingTermGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingTermGroupByOutputType[P]>
            : GetScalarType<T[P], SettingTermGroupByOutputType[P]>
        }
      >
    >


  export type SettingTermSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bibleId?: boolean
    original?: boolean
    translated?: boolean
    category?: boolean
    note?: boolean
    context?: boolean
    firstAppearance?: boolean
    frequency?: boolean
    isConfirmed?: boolean
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settingTerm"]>

  export type SettingTermSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bibleId?: boolean
    original?: boolean
    translated?: boolean
    category?: boolean
    note?: boolean
    context?: boolean
    firstAppearance?: boolean
    frequency?: boolean
    isConfirmed?: boolean
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settingTerm"]>

  export type SettingTermSelectScalar = {
    id?: boolean
    bibleId?: boolean
    original?: boolean
    translated?: boolean
    category?: boolean
    note?: boolean
    context?: boolean
    firstAppearance?: boolean
    frequency?: boolean
    isConfirmed?: boolean
  }

  export type SettingTermInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }
  export type SettingTermIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }

  export type $SettingTermPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettingTerm"
    objects: {
      bible: Prisma.$SettingBiblePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bibleId: string
      original: string
      translated: string
      category: $Enums.TermCategory
      note: string | null
      context: string | null
      firstAppearance: number | null
      frequency: number
      isConfirmed: boolean
    }, ExtArgs["result"]["settingTerm"]>
    composites: {}
  }

  type SettingTermGetPayload<S extends boolean | null | undefined | SettingTermDefaultArgs> = $Result.GetResult<Prisma.$SettingTermPayload, S>

  type SettingTermCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingTermFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingTermCountAggregateInputType | true
    }

  export interface SettingTermDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettingTerm'], meta: { name: 'SettingTerm' } }
    /**
     * Find zero or one SettingTerm that matches the filter.
     * @param {SettingTermFindUniqueArgs} args - Arguments to find a SettingTerm
     * @example
     * // Get one SettingTerm
     * const settingTerm = await prisma.settingTerm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingTermFindUniqueArgs>(args: SelectSubset<T, SettingTermFindUniqueArgs<ExtArgs>>): Prisma__SettingTermClient<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SettingTerm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingTermFindUniqueOrThrowArgs} args - Arguments to find a SettingTerm
     * @example
     * // Get one SettingTerm
     * const settingTerm = await prisma.settingTerm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingTermFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingTermFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingTermClient<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SettingTerm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTermFindFirstArgs} args - Arguments to find a SettingTerm
     * @example
     * // Get one SettingTerm
     * const settingTerm = await prisma.settingTerm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingTermFindFirstArgs>(args?: SelectSubset<T, SettingTermFindFirstArgs<ExtArgs>>): Prisma__SettingTermClient<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SettingTerm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTermFindFirstOrThrowArgs} args - Arguments to find a SettingTerm
     * @example
     * // Get one SettingTerm
     * const settingTerm = await prisma.settingTerm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingTermFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingTermFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingTermClient<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SettingTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettingTerms
     * const settingTerms = await prisma.settingTerm.findMany()
     * 
     * // Get first 10 SettingTerms
     * const settingTerms = await prisma.settingTerm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingTermWithIdOnly = await prisma.settingTerm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingTermFindManyArgs>(args?: SelectSubset<T, SettingTermFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SettingTerm.
     * @param {SettingTermCreateArgs} args - Arguments to create a SettingTerm.
     * @example
     * // Create one SettingTerm
     * const SettingTerm = await prisma.settingTerm.create({
     *   data: {
     *     // ... data to create a SettingTerm
     *   }
     * })
     * 
     */
    create<T extends SettingTermCreateArgs>(args: SelectSubset<T, SettingTermCreateArgs<ExtArgs>>): Prisma__SettingTermClient<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SettingTerms.
     * @param {SettingTermCreateManyArgs} args - Arguments to create many SettingTerms.
     * @example
     * // Create many SettingTerms
     * const settingTerm = await prisma.settingTerm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingTermCreateManyArgs>(args?: SelectSubset<T, SettingTermCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SettingTerms and returns the data saved in the database.
     * @param {SettingTermCreateManyAndReturnArgs} args - Arguments to create many SettingTerms.
     * @example
     * // Create many SettingTerms
     * const settingTerm = await prisma.settingTerm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SettingTerms and only return the `id`
     * const settingTermWithIdOnly = await prisma.settingTerm.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingTermCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingTermCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SettingTerm.
     * @param {SettingTermDeleteArgs} args - Arguments to delete one SettingTerm.
     * @example
     * // Delete one SettingTerm
     * const SettingTerm = await prisma.settingTerm.delete({
     *   where: {
     *     // ... filter to delete one SettingTerm
     *   }
     * })
     * 
     */
    delete<T extends SettingTermDeleteArgs>(args: SelectSubset<T, SettingTermDeleteArgs<ExtArgs>>): Prisma__SettingTermClient<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SettingTerm.
     * @param {SettingTermUpdateArgs} args - Arguments to update one SettingTerm.
     * @example
     * // Update one SettingTerm
     * const settingTerm = await prisma.settingTerm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingTermUpdateArgs>(args: SelectSubset<T, SettingTermUpdateArgs<ExtArgs>>): Prisma__SettingTermClient<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SettingTerms.
     * @param {SettingTermDeleteManyArgs} args - Arguments to filter SettingTerms to delete.
     * @example
     * // Delete a few SettingTerms
     * const { count } = await prisma.settingTerm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingTermDeleteManyArgs>(args?: SelectSubset<T, SettingTermDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettingTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettingTerms
     * const settingTerm = await prisma.settingTerm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingTermUpdateManyArgs>(args: SelectSubset<T, SettingTermUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SettingTerm.
     * @param {SettingTermUpsertArgs} args - Arguments to update or create a SettingTerm.
     * @example
     * // Update or create a SettingTerm
     * const settingTerm = await prisma.settingTerm.upsert({
     *   create: {
     *     // ... data to create a SettingTerm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettingTerm we want to update
     *   }
     * })
     */
    upsert<T extends SettingTermUpsertArgs>(args: SelectSubset<T, SettingTermUpsertArgs<ExtArgs>>): Prisma__SettingTermClient<$Result.GetResult<Prisma.$SettingTermPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SettingTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTermCountArgs} args - Arguments to filter SettingTerms to count.
     * @example
     * // Count the number of SettingTerms
     * const count = await prisma.settingTerm.count({
     *   where: {
     *     // ... the filter for the SettingTerms we want to count
     *   }
     * })
    **/
    count<T extends SettingTermCountArgs>(
      args?: Subset<T, SettingTermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingTermCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettingTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingTermAggregateArgs>(args: Subset<T, SettingTermAggregateArgs>): Prisma.PrismaPromise<GetSettingTermAggregateType<T>>

    /**
     * Group by SettingTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingTermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingTermGroupByArgs['orderBy'] }
        : { orderBy?: SettingTermGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingTermGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingTermGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettingTerm model
   */
  readonly fields: SettingTermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettingTerm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingTermClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bible<T extends SettingBibleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SettingBibleDefaultArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettingTerm model
   */ 
  interface SettingTermFieldRefs {
    readonly id: FieldRef<"SettingTerm", 'String'>
    readonly bibleId: FieldRef<"SettingTerm", 'String'>
    readonly original: FieldRef<"SettingTerm", 'String'>
    readonly translated: FieldRef<"SettingTerm", 'String'>
    readonly category: FieldRef<"SettingTerm", 'TermCategory'>
    readonly note: FieldRef<"SettingTerm", 'String'>
    readonly context: FieldRef<"SettingTerm", 'String'>
    readonly firstAppearance: FieldRef<"SettingTerm", 'Int'>
    readonly frequency: FieldRef<"SettingTerm", 'Int'>
    readonly isConfirmed: FieldRef<"SettingTerm", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SettingTerm findUnique
   */
  export type SettingTermFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
    /**
     * Filter, which SettingTerm to fetch.
     */
    where: SettingTermWhereUniqueInput
  }

  /**
   * SettingTerm findUniqueOrThrow
   */
  export type SettingTermFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
    /**
     * Filter, which SettingTerm to fetch.
     */
    where: SettingTermWhereUniqueInput
  }

  /**
   * SettingTerm findFirst
   */
  export type SettingTermFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
    /**
     * Filter, which SettingTerm to fetch.
     */
    where?: SettingTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingTerms to fetch.
     */
    orderBy?: SettingTermOrderByWithRelationInput | SettingTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingTerms.
     */
    cursor?: SettingTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingTerms.
     */
    distinct?: SettingTermScalarFieldEnum | SettingTermScalarFieldEnum[]
  }

  /**
   * SettingTerm findFirstOrThrow
   */
  export type SettingTermFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
    /**
     * Filter, which SettingTerm to fetch.
     */
    where?: SettingTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingTerms to fetch.
     */
    orderBy?: SettingTermOrderByWithRelationInput | SettingTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingTerms.
     */
    cursor?: SettingTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingTerms.
     */
    distinct?: SettingTermScalarFieldEnum | SettingTermScalarFieldEnum[]
  }

  /**
   * SettingTerm findMany
   */
  export type SettingTermFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
    /**
     * Filter, which SettingTerms to fetch.
     */
    where?: SettingTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingTerms to fetch.
     */
    orderBy?: SettingTermOrderByWithRelationInput | SettingTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettingTerms.
     */
    cursor?: SettingTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingTerms.
     */
    skip?: number
    distinct?: SettingTermScalarFieldEnum | SettingTermScalarFieldEnum[]
  }

  /**
   * SettingTerm create
   */
  export type SettingTermCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
    /**
     * The data needed to create a SettingTerm.
     */
    data: XOR<SettingTermCreateInput, SettingTermUncheckedCreateInput>
  }

  /**
   * SettingTerm createMany
   */
  export type SettingTermCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettingTerms.
     */
    data: SettingTermCreateManyInput | SettingTermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingTerm createManyAndReturn
   */
  export type SettingTermCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SettingTerms.
     */
    data: SettingTermCreateManyInput | SettingTermCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SettingTerm update
   */
  export type SettingTermUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
    /**
     * The data needed to update a SettingTerm.
     */
    data: XOR<SettingTermUpdateInput, SettingTermUncheckedUpdateInput>
    /**
     * Choose, which SettingTerm to update.
     */
    where: SettingTermWhereUniqueInput
  }

  /**
   * SettingTerm updateMany
   */
  export type SettingTermUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettingTerms.
     */
    data: XOR<SettingTermUpdateManyMutationInput, SettingTermUncheckedUpdateManyInput>
    /**
     * Filter which SettingTerms to update
     */
    where?: SettingTermWhereInput
  }

  /**
   * SettingTerm upsert
   */
  export type SettingTermUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
    /**
     * The filter to search for the SettingTerm to update in case it exists.
     */
    where: SettingTermWhereUniqueInput
    /**
     * In case the SettingTerm found by the `where` argument doesn't exist, create a new SettingTerm with this data.
     */
    create: XOR<SettingTermCreateInput, SettingTermUncheckedCreateInput>
    /**
     * In case the SettingTerm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingTermUpdateInput, SettingTermUncheckedUpdateInput>
  }

  /**
   * SettingTerm delete
   */
  export type SettingTermDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
    /**
     * Filter which SettingTerm to delete.
     */
    where: SettingTermWhereUniqueInput
  }

  /**
   * SettingTerm deleteMany
   */
  export type SettingTermDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingTerms to delete
     */
    where?: SettingTermWhereInput
  }

  /**
   * SettingTerm without action
   */
  export type SettingTermDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTerm
     */
    select?: SettingTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTermInclude<ExtArgs> | null
  }


  /**
   * Model TimelineEvent
   */

  export type AggregateTimelineEvent = {
    _count: TimelineEventCountAggregateOutputType | null
    _avg: TimelineEventAvgAggregateOutputType | null
    _sum: TimelineEventSumAggregateOutputType | null
    _min: TimelineEventMinAggregateOutputType | null
    _max: TimelineEventMaxAggregateOutputType | null
  }

  export type TimelineEventAvgAggregateOutputType = {
    chapterStart: number | null
    chapterEnd: number | null
    importance: number | null
  }

  export type TimelineEventSumAggregateOutputType = {
    chapterStart: number | null
    chapterEnd: number | null
    importance: number | null
  }

  export type TimelineEventMinAggregateOutputType = {
    id: string | null
    bibleId: string | null
    title: string | null
    description: string | null
    chapterStart: number | null
    chapterEnd: number | null
    eventType: $Enums.EventType | null
    importance: number | null
    isForeshadowing: boolean | null
    foreshadowNote: string | null
  }

  export type TimelineEventMaxAggregateOutputType = {
    id: string | null
    bibleId: string | null
    title: string | null
    description: string | null
    chapterStart: number | null
    chapterEnd: number | null
    eventType: $Enums.EventType | null
    importance: number | null
    isForeshadowing: boolean | null
    foreshadowNote: string | null
  }

  export type TimelineEventCountAggregateOutputType = {
    id: number
    bibleId: number
    title: number
    description: number
    chapterStart: number
    chapterEnd: number
    eventType: number
    importance: number
    isForeshadowing: number
    foreshadowNote: number
    involvedCharacterIds: number
    _all: number
  }


  export type TimelineEventAvgAggregateInputType = {
    chapterStart?: true
    chapterEnd?: true
    importance?: true
  }

  export type TimelineEventSumAggregateInputType = {
    chapterStart?: true
    chapterEnd?: true
    importance?: true
  }

  export type TimelineEventMinAggregateInputType = {
    id?: true
    bibleId?: true
    title?: true
    description?: true
    chapterStart?: true
    chapterEnd?: true
    eventType?: true
    importance?: true
    isForeshadowing?: true
    foreshadowNote?: true
  }

  export type TimelineEventMaxAggregateInputType = {
    id?: true
    bibleId?: true
    title?: true
    description?: true
    chapterStart?: true
    chapterEnd?: true
    eventType?: true
    importance?: true
    isForeshadowing?: true
    foreshadowNote?: true
  }

  export type TimelineEventCountAggregateInputType = {
    id?: true
    bibleId?: true
    title?: true
    description?: true
    chapterStart?: true
    chapterEnd?: true
    eventType?: true
    importance?: true
    isForeshadowing?: true
    foreshadowNote?: true
    involvedCharacterIds?: true
    _all?: true
  }

  export type TimelineEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimelineEvent to aggregate.
     */
    where?: TimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineEvents to fetch.
     */
    orderBy?: TimelineEventOrderByWithRelationInput | TimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimelineEvents
    **/
    _count?: true | TimelineEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimelineEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimelineEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimelineEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimelineEventMaxAggregateInputType
  }

  export type GetTimelineEventAggregateType<T extends TimelineEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTimelineEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimelineEvent[P]>
      : GetScalarType<T[P], AggregateTimelineEvent[P]>
  }




  export type TimelineEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimelineEventWhereInput
    orderBy?: TimelineEventOrderByWithAggregationInput | TimelineEventOrderByWithAggregationInput[]
    by: TimelineEventScalarFieldEnum[] | TimelineEventScalarFieldEnum
    having?: TimelineEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimelineEventCountAggregateInputType | true
    _avg?: TimelineEventAvgAggregateInputType
    _sum?: TimelineEventSumAggregateInputType
    _min?: TimelineEventMinAggregateInputType
    _max?: TimelineEventMaxAggregateInputType
  }

  export type TimelineEventGroupByOutputType = {
    id: string
    bibleId: string
    title: string
    description: string
    chapterStart: number
    chapterEnd: number | null
    eventType: $Enums.EventType
    importance: number
    isForeshadowing: boolean
    foreshadowNote: string | null
    involvedCharacterIds: string[]
    _count: TimelineEventCountAggregateOutputType | null
    _avg: TimelineEventAvgAggregateOutputType | null
    _sum: TimelineEventSumAggregateOutputType | null
    _min: TimelineEventMinAggregateOutputType | null
    _max: TimelineEventMaxAggregateOutputType | null
  }

  type GetTimelineEventGroupByPayload<T extends TimelineEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimelineEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimelineEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimelineEventGroupByOutputType[P]>
            : GetScalarType<T[P], TimelineEventGroupByOutputType[P]>
        }
      >
    >


  export type TimelineEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bibleId?: boolean
    title?: boolean
    description?: boolean
    chapterStart?: boolean
    chapterEnd?: boolean
    eventType?: boolean
    importance?: boolean
    isForeshadowing?: boolean
    foreshadowNote?: boolean
    involvedCharacterIds?: boolean
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timelineEvent"]>

  export type TimelineEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bibleId?: boolean
    title?: boolean
    description?: boolean
    chapterStart?: boolean
    chapterEnd?: boolean
    eventType?: boolean
    importance?: boolean
    isForeshadowing?: boolean
    foreshadowNote?: boolean
    involvedCharacterIds?: boolean
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timelineEvent"]>

  export type TimelineEventSelectScalar = {
    id?: boolean
    bibleId?: boolean
    title?: boolean
    description?: boolean
    chapterStart?: boolean
    chapterEnd?: boolean
    eventType?: boolean
    importance?: boolean
    isForeshadowing?: boolean
    foreshadowNote?: boolean
    involvedCharacterIds?: boolean
  }

  export type TimelineEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }
  export type TimelineEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bible?: boolean | SettingBibleDefaultArgs<ExtArgs>
  }

  export type $TimelineEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimelineEvent"
    objects: {
      bible: Prisma.$SettingBiblePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bibleId: string
      title: string
      description: string
      chapterStart: number
      chapterEnd: number | null
      eventType: $Enums.EventType
      importance: number
      isForeshadowing: boolean
      foreshadowNote: string | null
      involvedCharacterIds: string[]
    }, ExtArgs["result"]["timelineEvent"]>
    composites: {}
  }

  type TimelineEventGetPayload<S extends boolean | null | undefined | TimelineEventDefaultArgs> = $Result.GetResult<Prisma.$TimelineEventPayload, S>

  type TimelineEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimelineEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimelineEventCountAggregateInputType | true
    }

  export interface TimelineEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimelineEvent'], meta: { name: 'TimelineEvent' } }
    /**
     * Find zero or one TimelineEvent that matches the filter.
     * @param {TimelineEventFindUniqueArgs} args - Arguments to find a TimelineEvent
     * @example
     * // Get one TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimelineEventFindUniqueArgs>(args: SelectSubset<T, TimelineEventFindUniqueArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimelineEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimelineEventFindUniqueOrThrowArgs} args - Arguments to find a TimelineEvent
     * @example
     * // Get one TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimelineEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TimelineEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimelineEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventFindFirstArgs} args - Arguments to find a TimelineEvent
     * @example
     * // Get one TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimelineEventFindFirstArgs>(args?: SelectSubset<T, TimelineEventFindFirstArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimelineEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventFindFirstOrThrowArgs} args - Arguments to find a TimelineEvent
     * @example
     * // Get one TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimelineEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TimelineEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimelineEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimelineEvents
     * const timelineEvents = await prisma.timelineEvent.findMany()
     * 
     * // Get first 10 TimelineEvents
     * const timelineEvents = await prisma.timelineEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timelineEventWithIdOnly = await prisma.timelineEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimelineEventFindManyArgs>(args?: SelectSubset<T, TimelineEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimelineEvent.
     * @param {TimelineEventCreateArgs} args - Arguments to create a TimelineEvent.
     * @example
     * // Create one TimelineEvent
     * const TimelineEvent = await prisma.timelineEvent.create({
     *   data: {
     *     // ... data to create a TimelineEvent
     *   }
     * })
     * 
     */
    create<T extends TimelineEventCreateArgs>(args: SelectSubset<T, TimelineEventCreateArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimelineEvents.
     * @param {TimelineEventCreateManyArgs} args - Arguments to create many TimelineEvents.
     * @example
     * // Create many TimelineEvents
     * const timelineEvent = await prisma.timelineEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimelineEventCreateManyArgs>(args?: SelectSubset<T, TimelineEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimelineEvents and returns the data saved in the database.
     * @param {TimelineEventCreateManyAndReturnArgs} args - Arguments to create many TimelineEvents.
     * @example
     * // Create many TimelineEvents
     * const timelineEvent = await prisma.timelineEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimelineEvents and only return the `id`
     * const timelineEventWithIdOnly = await prisma.timelineEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimelineEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TimelineEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TimelineEvent.
     * @param {TimelineEventDeleteArgs} args - Arguments to delete one TimelineEvent.
     * @example
     * // Delete one TimelineEvent
     * const TimelineEvent = await prisma.timelineEvent.delete({
     *   where: {
     *     // ... filter to delete one TimelineEvent
     *   }
     * })
     * 
     */
    delete<T extends TimelineEventDeleteArgs>(args: SelectSubset<T, TimelineEventDeleteArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimelineEvent.
     * @param {TimelineEventUpdateArgs} args - Arguments to update one TimelineEvent.
     * @example
     * // Update one TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimelineEventUpdateArgs>(args: SelectSubset<T, TimelineEventUpdateArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimelineEvents.
     * @param {TimelineEventDeleteManyArgs} args - Arguments to filter TimelineEvents to delete.
     * @example
     * // Delete a few TimelineEvents
     * const { count } = await prisma.timelineEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimelineEventDeleteManyArgs>(args?: SelectSubset<T, TimelineEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimelineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimelineEvents
     * const timelineEvent = await prisma.timelineEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimelineEventUpdateManyArgs>(args: SelectSubset<T, TimelineEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimelineEvent.
     * @param {TimelineEventUpsertArgs} args - Arguments to update or create a TimelineEvent.
     * @example
     * // Update or create a TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.upsert({
     *   create: {
     *     // ... data to create a TimelineEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimelineEvent we want to update
     *   }
     * })
     */
    upsert<T extends TimelineEventUpsertArgs>(args: SelectSubset<T, TimelineEventUpsertArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimelineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventCountArgs} args - Arguments to filter TimelineEvents to count.
     * @example
     * // Count the number of TimelineEvents
     * const count = await prisma.timelineEvent.count({
     *   where: {
     *     // ... the filter for the TimelineEvents we want to count
     *   }
     * })
    **/
    count<T extends TimelineEventCountArgs>(
      args?: Subset<T, TimelineEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimelineEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimelineEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimelineEventAggregateArgs>(args: Subset<T, TimelineEventAggregateArgs>): Prisma.PrismaPromise<GetTimelineEventAggregateType<T>>

    /**
     * Group by TimelineEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimelineEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimelineEventGroupByArgs['orderBy'] }
        : { orderBy?: TimelineEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimelineEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimelineEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimelineEvent model
   */
  readonly fields: TimelineEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimelineEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimelineEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bible<T extends SettingBibleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SettingBibleDefaultArgs<ExtArgs>>): Prisma__SettingBibleClient<$Result.GetResult<Prisma.$SettingBiblePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimelineEvent model
   */ 
  interface TimelineEventFieldRefs {
    readonly id: FieldRef<"TimelineEvent", 'String'>
    readonly bibleId: FieldRef<"TimelineEvent", 'String'>
    readonly title: FieldRef<"TimelineEvent", 'String'>
    readonly description: FieldRef<"TimelineEvent", 'String'>
    readonly chapterStart: FieldRef<"TimelineEvent", 'Int'>
    readonly chapterEnd: FieldRef<"TimelineEvent", 'Int'>
    readonly eventType: FieldRef<"TimelineEvent", 'EventType'>
    readonly importance: FieldRef<"TimelineEvent", 'Int'>
    readonly isForeshadowing: FieldRef<"TimelineEvent", 'Boolean'>
    readonly foreshadowNote: FieldRef<"TimelineEvent", 'String'>
    readonly involvedCharacterIds: FieldRef<"TimelineEvent", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * TimelineEvent findUnique
   */
  export type TimelineEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TimelineEvent to fetch.
     */
    where: TimelineEventWhereUniqueInput
  }

  /**
   * TimelineEvent findUniqueOrThrow
   */
  export type TimelineEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TimelineEvent to fetch.
     */
    where: TimelineEventWhereUniqueInput
  }

  /**
   * TimelineEvent findFirst
   */
  export type TimelineEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TimelineEvent to fetch.
     */
    where?: TimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineEvents to fetch.
     */
    orderBy?: TimelineEventOrderByWithRelationInput | TimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimelineEvents.
     */
    cursor?: TimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimelineEvents.
     */
    distinct?: TimelineEventScalarFieldEnum | TimelineEventScalarFieldEnum[]
  }

  /**
   * TimelineEvent findFirstOrThrow
   */
  export type TimelineEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TimelineEvent to fetch.
     */
    where?: TimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineEvents to fetch.
     */
    orderBy?: TimelineEventOrderByWithRelationInput | TimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimelineEvents.
     */
    cursor?: TimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimelineEvents.
     */
    distinct?: TimelineEventScalarFieldEnum | TimelineEventScalarFieldEnum[]
  }

  /**
   * TimelineEvent findMany
   */
  export type TimelineEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TimelineEvents to fetch.
     */
    where?: TimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineEvents to fetch.
     */
    orderBy?: TimelineEventOrderByWithRelationInput | TimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimelineEvents.
     */
    cursor?: TimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineEvents.
     */
    skip?: number
    distinct?: TimelineEventScalarFieldEnum | TimelineEventScalarFieldEnum[]
  }

  /**
   * TimelineEvent create
   */
  export type TimelineEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * The data needed to create a TimelineEvent.
     */
    data: XOR<TimelineEventCreateInput, TimelineEventUncheckedCreateInput>
  }

  /**
   * TimelineEvent createMany
   */
  export type TimelineEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimelineEvents.
     */
    data: TimelineEventCreateManyInput | TimelineEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimelineEvent createManyAndReturn
   */
  export type TimelineEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TimelineEvents.
     */
    data: TimelineEventCreateManyInput | TimelineEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimelineEvent update
   */
  export type TimelineEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * The data needed to update a TimelineEvent.
     */
    data: XOR<TimelineEventUpdateInput, TimelineEventUncheckedUpdateInput>
    /**
     * Choose, which TimelineEvent to update.
     */
    where: TimelineEventWhereUniqueInput
  }

  /**
   * TimelineEvent updateMany
   */
  export type TimelineEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimelineEvents.
     */
    data: XOR<TimelineEventUpdateManyMutationInput, TimelineEventUncheckedUpdateManyInput>
    /**
     * Filter which TimelineEvents to update
     */
    where?: TimelineEventWhereInput
  }

  /**
   * TimelineEvent upsert
   */
  export type TimelineEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * The filter to search for the TimelineEvent to update in case it exists.
     */
    where: TimelineEventWhereUniqueInput
    /**
     * In case the TimelineEvent found by the `where` argument doesn't exist, create a new TimelineEvent with this data.
     */
    create: XOR<TimelineEventCreateInput, TimelineEventUncheckedCreateInput>
    /**
     * In case the TimelineEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimelineEventUpdateInput, TimelineEventUncheckedUpdateInput>
  }

  /**
   * TimelineEvent delete
   */
  export type TimelineEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter which TimelineEvent to delete.
     */
    where: TimelineEventWhereUniqueInput
  }

  /**
   * TimelineEvent deleteMany
   */
  export type TimelineEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimelineEvents to delete
     */
    where?: TimelineEventWhereInput
  }

  /**
   * TimelineEvent without action
   */
  export type TimelineEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
  }


  /**
   * Model BibleGenerationJob
   */

  export type AggregateBibleGenerationJob = {
    _count: BibleGenerationJobCountAggregateOutputType | null
    _avg: BibleGenerationJobAvgAggregateOutputType | null
    _sum: BibleGenerationJobSumAggregateOutputType | null
    _min: BibleGenerationJobMinAggregateOutputType | null
    _max: BibleGenerationJobMaxAggregateOutputType | null
  }

  export type BibleGenerationJobAvgAggregateOutputType = {
    totalBatches: number | null
    currentBatchIndex: number | null
    analyzedChapters: number | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type BibleGenerationJobSumAggregateOutputType = {
    totalBatches: number | null
    currentBatchIndex: number | null
    analyzedChapters: number | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type BibleGenerationJobMinAggregateOutputType = {
    id: string | null
    workId: string | null
    userId: string | null
    status: $Enums.BibleJobStatus | null
    totalBatches: number | null
    currentBatchIndex: number | null
    analyzedChapters: number | null
    retryCount: number | null
    maxRetries: number | null
    errorMessage: string | null
    lastError: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    lockedAt: Date | null
    lockedBy: string | null
  }

  export type BibleGenerationJobMaxAggregateOutputType = {
    id: string | null
    workId: string | null
    userId: string | null
    status: $Enums.BibleJobStatus | null
    totalBatches: number | null
    currentBatchIndex: number | null
    analyzedChapters: number | null
    retryCount: number | null
    maxRetries: number | null
    errorMessage: string | null
    lastError: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    lockedAt: Date | null
    lockedBy: string | null
  }

  export type BibleGenerationJobCountAggregateOutputType = {
    id: number
    workId: number
    userId: number
    status: number
    batchPlan: number
    totalBatches: number
    currentBatchIndex: number
    analyzedChapters: number
    retryCount: number
    maxRetries: number
    errorMessage: number
    lastError: number
    createdAt: number
    updatedAt: number
    startedAt: number
    completedAt: number
    lockedAt: number
    lockedBy: number
    _all: number
  }


  export type BibleGenerationJobAvgAggregateInputType = {
    totalBatches?: true
    currentBatchIndex?: true
    analyzedChapters?: true
    retryCount?: true
    maxRetries?: true
  }

  export type BibleGenerationJobSumAggregateInputType = {
    totalBatches?: true
    currentBatchIndex?: true
    analyzedChapters?: true
    retryCount?: true
    maxRetries?: true
  }

  export type BibleGenerationJobMinAggregateInputType = {
    id?: true
    workId?: true
    userId?: true
    status?: true
    totalBatches?: true
    currentBatchIndex?: true
    analyzedChapters?: true
    retryCount?: true
    maxRetries?: true
    errorMessage?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    lockedAt?: true
    lockedBy?: true
  }

  export type BibleGenerationJobMaxAggregateInputType = {
    id?: true
    workId?: true
    userId?: true
    status?: true
    totalBatches?: true
    currentBatchIndex?: true
    analyzedChapters?: true
    retryCount?: true
    maxRetries?: true
    errorMessage?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    lockedAt?: true
    lockedBy?: true
  }

  export type BibleGenerationJobCountAggregateInputType = {
    id?: true
    workId?: true
    userId?: true
    status?: true
    batchPlan?: true
    totalBatches?: true
    currentBatchIndex?: true
    analyzedChapters?: true
    retryCount?: true
    maxRetries?: true
    errorMessage?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    lockedAt?: true
    lockedBy?: true
    _all?: true
  }

  export type BibleGenerationJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BibleGenerationJob to aggregate.
     */
    where?: BibleGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BibleGenerationJobs to fetch.
     */
    orderBy?: BibleGenerationJobOrderByWithRelationInput | BibleGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BibleGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BibleGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BibleGenerationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BibleGenerationJobs
    **/
    _count?: true | BibleGenerationJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BibleGenerationJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BibleGenerationJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BibleGenerationJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BibleGenerationJobMaxAggregateInputType
  }

  export type GetBibleGenerationJobAggregateType<T extends BibleGenerationJobAggregateArgs> = {
        [P in keyof T & keyof AggregateBibleGenerationJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBibleGenerationJob[P]>
      : GetScalarType<T[P], AggregateBibleGenerationJob[P]>
  }




  export type BibleGenerationJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibleGenerationJobWhereInput
    orderBy?: BibleGenerationJobOrderByWithAggregationInput | BibleGenerationJobOrderByWithAggregationInput[]
    by: BibleGenerationJobScalarFieldEnum[] | BibleGenerationJobScalarFieldEnum
    having?: BibleGenerationJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BibleGenerationJobCountAggregateInputType | true
    _avg?: BibleGenerationJobAvgAggregateInputType
    _sum?: BibleGenerationJobSumAggregateInputType
    _min?: BibleGenerationJobMinAggregateInputType
    _max?: BibleGenerationJobMaxAggregateInputType
  }

  export type BibleGenerationJobGroupByOutputType = {
    id: string
    workId: string
    userId: string
    status: $Enums.BibleJobStatus
    batchPlan: JsonValue
    totalBatches: number
    currentBatchIndex: number
    analyzedChapters: number
    retryCount: number
    maxRetries: number
    errorMessage: string | null
    lastError: string | null
    createdAt: Date
    updatedAt: Date
    startedAt: Date | null
    completedAt: Date | null
    lockedAt: Date | null
    lockedBy: string | null
    _count: BibleGenerationJobCountAggregateOutputType | null
    _avg: BibleGenerationJobAvgAggregateOutputType | null
    _sum: BibleGenerationJobSumAggregateOutputType | null
    _min: BibleGenerationJobMinAggregateOutputType | null
    _max: BibleGenerationJobMaxAggregateOutputType | null
  }

  type GetBibleGenerationJobGroupByPayload<T extends BibleGenerationJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BibleGenerationJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BibleGenerationJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BibleGenerationJobGroupByOutputType[P]>
            : GetScalarType<T[P], BibleGenerationJobGroupByOutputType[P]>
        }
      >
    >


  export type BibleGenerationJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workId?: boolean
    userId?: boolean
    status?: boolean
    batchPlan?: boolean
    totalBatches?: boolean
    currentBatchIndex?: boolean
    analyzedChapters?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    errorMessage?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bibleGenerationJob"]>

  export type BibleGenerationJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workId?: boolean
    userId?: boolean
    status?: boolean
    batchPlan?: boolean
    totalBatches?: boolean
    currentBatchIndex?: boolean
    analyzedChapters?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    errorMessage?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bibleGenerationJob"]>

  export type BibleGenerationJobSelectScalar = {
    id?: boolean
    workId?: boolean
    userId?: boolean
    status?: boolean
    batchPlan?: boolean
    totalBatches?: boolean
    currentBatchIndex?: boolean
    analyzedChapters?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    errorMessage?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
  }

  export type BibleGenerationJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }
  export type BibleGenerationJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }

  export type $BibleGenerationJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BibleGenerationJob"
    objects: {
      work: Prisma.$WorkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workId: string
      userId: string
      status: $Enums.BibleJobStatus
      batchPlan: Prisma.JsonValue
      totalBatches: number
      currentBatchIndex: number
      analyzedChapters: number
      retryCount: number
      maxRetries: number
      errorMessage: string | null
      lastError: string | null
      createdAt: Date
      updatedAt: Date
      startedAt: Date | null
      completedAt: Date | null
      lockedAt: Date | null
      lockedBy: string | null
    }, ExtArgs["result"]["bibleGenerationJob"]>
    composites: {}
  }

  type BibleGenerationJobGetPayload<S extends boolean | null | undefined | BibleGenerationJobDefaultArgs> = $Result.GetResult<Prisma.$BibleGenerationJobPayload, S>

  type BibleGenerationJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BibleGenerationJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BibleGenerationJobCountAggregateInputType | true
    }

  export interface BibleGenerationJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BibleGenerationJob'], meta: { name: 'BibleGenerationJob' } }
    /**
     * Find zero or one BibleGenerationJob that matches the filter.
     * @param {BibleGenerationJobFindUniqueArgs} args - Arguments to find a BibleGenerationJob
     * @example
     * // Get one BibleGenerationJob
     * const bibleGenerationJob = await prisma.bibleGenerationJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BibleGenerationJobFindUniqueArgs>(args: SelectSubset<T, BibleGenerationJobFindUniqueArgs<ExtArgs>>): Prisma__BibleGenerationJobClient<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BibleGenerationJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BibleGenerationJobFindUniqueOrThrowArgs} args - Arguments to find a BibleGenerationJob
     * @example
     * // Get one BibleGenerationJob
     * const bibleGenerationJob = await prisma.bibleGenerationJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BibleGenerationJobFindUniqueOrThrowArgs>(args: SelectSubset<T, BibleGenerationJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BibleGenerationJobClient<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BibleGenerationJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibleGenerationJobFindFirstArgs} args - Arguments to find a BibleGenerationJob
     * @example
     * // Get one BibleGenerationJob
     * const bibleGenerationJob = await prisma.bibleGenerationJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BibleGenerationJobFindFirstArgs>(args?: SelectSubset<T, BibleGenerationJobFindFirstArgs<ExtArgs>>): Prisma__BibleGenerationJobClient<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BibleGenerationJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibleGenerationJobFindFirstOrThrowArgs} args - Arguments to find a BibleGenerationJob
     * @example
     * // Get one BibleGenerationJob
     * const bibleGenerationJob = await prisma.bibleGenerationJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BibleGenerationJobFindFirstOrThrowArgs>(args?: SelectSubset<T, BibleGenerationJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__BibleGenerationJobClient<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BibleGenerationJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibleGenerationJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BibleGenerationJobs
     * const bibleGenerationJobs = await prisma.bibleGenerationJob.findMany()
     * 
     * // Get first 10 BibleGenerationJobs
     * const bibleGenerationJobs = await prisma.bibleGenerationJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bibleGenerationJobWithIdOnly = await prisma.bibleGenerationJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BibleGenerationJobFindManyArgs>(args?: SelectSubset<T, BibleGenerationJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BibleGenerationJob.
     * @param {BibleGenerationJobCreateArgs} args - Arguments to create a BibleGenerationJob.
     * @example
     * // Create one BibleGenerationJob
     * const BibleGenerationJob = await prisma.bibleGenerationJob.create({
     *   data: {
     *     // ... data to create a BibleGenerationJob
     *   }
     * })
     * 
     */
    create<T extends BibleGenerationJobCreateArgs>(args: SelectSubset<T, BibleGenerationJobCreateArgs<ExtArgs>>): Prisma__BibleGenerationJobClient<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BibleGenerationJobs.
     * @param {BibleGenerationJobCreateManyArgs} args - Arguments to create many BibleGenerationJobs.
     * @example
     * // Create many BibleGenerationJobs
     * const bibleGenerationJob = await prisma.bibleGenerationJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BibleGenerationJobCreateManyArgs>(args?: SelectSubset<T, BibleGenerationJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BibleGenerationJobs and returns the data saved in the database.
     * @param {BibleGenerationJobCreateManyAndReturnArgs} args - Arguments to create many BibleGenerationJobs.
     * @example
     * // Create many BibleGenerationJobs
     * const bibleGenerationJob = await prisma.bibleGenerationJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BibleGenerationJobs and only return the `id`
     * const bibleGenerationJobWithIdOnly = await prisma.bibleGenerationJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BibleGenerationJobCreateManyAndReturnArgs>(args?: SelectSubset<T, BibleGenerationJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BibleGenerationJob.
     * @param {BibleGenerationJobDeleteArgs} args - Arguments to delete one BibleGenerationJob.
     * @example
     * // Delete one BibleGenerationJob
     * const BibleGenerationJob = await prisma.bibleGenerationJob.delete({
     *   where: {
     *     // ... filter to delete one BibleGenerationJob
     *   }
     * })
     * 
     */
    delete<T extends BibleGenerationJobDeleteArgs>(args: SelectSubset<T, BibleGenerationJobDeleteArgs<ExtArgs>>): Prisma__BibleGenerationJobClient<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BibleGenerationJob.
     * @param {BibleGenerationJobUpdateArgs} args - Arguments to update one BibleGenerationJob.
     * @example
     * // Update one BibleGenerationJob
     * const bibleGenerationJob = await prisma.bibleGenerationJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BibleGenerationJobUpdateArgs>(args: SelectSubset<T, BibleGenerationJobUpdateArgs<ExtArgs>>): Prisma__BibleGenerationJobClient<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BibleGenerationJobs.
     * @param {BibleGenerationJobDeleteManyArgs} args - Arguments to filter BibleGenerationJobs to delete.
     * @example
     * // Delete a few BibleGenerationJobs
     * const { count } = await prisma.bibleGenerationJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BibleGenerationJobDeleteManyArgs>(args?: SelectSubset<T, BibleGenerationJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BibleGenerationJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibleGenerationJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BibleGenerationJobs
     * const bibleGenerationJob = await prisma.bibleGenerationJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BibleGenerationJobUpdateManyArgs>(args: SelectSubset<T, BibleGenerationJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BibleGenerationJob.
     * @param {BibleGenerationJobUpsertArgs} args - Arguments to update or create a BibleGenerationJob.
     * @example
     * // Update or create a BibleGenerationJob
     * const bibleGenerationJob = await prisma.bibleGenerationJob.upsert({
     *   create: {
     *     // ... data to create a BibleGenerationJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BibleGenerationJob we want to update
     *   }
     * })
     */
    upsert<T extends BibleGenerationJobUpsertArgs>(args: SelectSubset<T, BibleGenerationJobUpsertArgs<ExtArgs>>): Prisma__BibleGenerationJobClient<$Result.GetResult<Prisma.$BibleGenerationJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BibleGenerationJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibleGenerationJobCountArgs} args - Arguments to filter BibleGenerationJobs to count.
     * @example
     * // Count the number of BibleGenerationJobs
     * const count = await prisma.bibleGenerationJob.count({
     *   where: {
     *     // ... the filter for the BibleGenerationJobs we want to count
     *   }
     * })
    **/
    count<T extends BibleGenerationJobCountArgs>(
      args?: Subset<T, BibleGenerationJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BibleGenerationJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BibleGenerationJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibleGenerationJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BibleGenerationJobAggregateArgs>(args: Subset<T, BibleGenerationJobAggregateArgs>): Prisma.PrismaPromise<GetBibleGenerationJobAggregateType<T>>

    /**
     * Group by BibleGenerationJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibleGenerationJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BibleGenerationJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BibleGenerationJobGroupByArgs['orderBy'] }
        : { orderBy?: BibleGenerationJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BibleGenerationJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBibleGenerationJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BibleGenerationJob model
   */
  readonly fields: BibleGenerationJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BibleGenerationJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BibleGenerationJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work<T extends WorkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkDefaultArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BibleGenerationJob model
   */ 
  interface BibleGenerationJobFieldRefs {
    readonly id: FieldRef<"BibleGenerationJob", 'String'>
    readonly workId: FieldRef<"BibleGenerationJob", 'String'>
    readonly userId: FieldRef<"BibleGenerationJob", 'String'>
    readonly status: FieldRef<"BibleGenerationJob", 'BibleJobStatus'>
    readonly batchPlan: FieldRef<"BibleGenerationJob", 'Json'>
    readonly totalBatches: FieldRef<"BibleGenerationJob", 'Int'>
    readonly currentBatchIndex: FieldRef<"BibleGenerationJob", 'Int'>
    readonly analyzedChapters: FieldRef<"BibleGenerationJob", 'Int'>
    readonly retryCount: FieldRef<"BibleGenerationJob", 'Int'>
    readonly maxRetries: FieldRef<"BibleGenerationJob", 'Int'>
    readonly errorMessage: FieldRef<"BibleGenerationJob", 'String'>
    readonly lastError: FieldRef<"BibleGenerationJob", 'String'>
    readonly createdAt: FieldRef<"BibleGenerationJob", 'DateTime'>
    readonly updatedAt: FieldRef<"BibleGenerationJob", 'DateTime'>
    readonly startedAt: FieldRef<"BibleGenerationJob", 'DateTime'>
    readonly completedAt: FieldRef<"BibleGenerationJob", 'DateTime'>
    readonly lockedAt: FieldRef<"BibleGenerationJob", 'DateTime'>
    readonly lockedBy: FieldRef<"BibleGenerationJob", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BibleGenerationJob findUnique
   */
  export type BibleGenerationJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which BibleGenerationJob to fetch.
     */
    where: BibleGenerationJobWhereUniqueInput
  }

  /**
   * BibleGenerationJob findUniqueOrThrow
   */
  export type BibleGenerationJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which BibleGenerationJob to fetch.
     */
    where: BibleGenerationJobWhereUniqueInput
  }

  /**
   * BibleGenerationJob findFirst
   */
  export type BibleGenerationJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which BibleGenerationJob to fetch.
     */
    where?: BibleGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BibleGenerationJobs to fetch.
     */
    orderBy?: BibleGenerationJobOrderByWithRelationInput | BibleGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BibleGenerationJobs.
     */
    cursor?: BibleGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BibleGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BibleGenerationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BibleGenerationJobs.
     */
    distinct?: BibleGenerationJobScalarFieldEnum | BibleGenerationJobScalarFieldEnum[]
  }

  /**
   * BibleGenerationJob findFirstOrThrow
   */
  export type BibleGenerationJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which BibleGenerationJob to fetch.
     */
    where?: BibleGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BibleGenerationJobs to fetch.
     */
    orderBy?: BibleGenerationJobOrderByWithRelationInput | BibleGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BibleGenerationJobs.
     */
    cursor?: BibleGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BibleGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BibleGenerationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BibleGenerationJobs.
     */
    distinct?: BibleGenerationJobScalarFieldEnum | BibleGenerationJobScalarFieldEnum[]
  }

  /**
   * BibleGenerationJob findMany
   */
  export type BibleGenerationJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which BibleGenerationJobs to fetch.
     */
    where?: BibleGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BibleGenerationJobs to fetch.
     */
    orderBy?: BibleGenerationJobOrderByWithRelationInput | BibleGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BibleGenerationJobs.
     */
    cursor?: BibleGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BibleGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BibleGenerationJobs.
     */
    skip?: number
    distinct?: BibleGenerationJobScalarFieldEnum | BibleGenerationJobScalarFieldEnum[]
  }

  /**
   * BibleGenerationJob create
   */
  export type BibleGenerationJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
    /**
     * The data needed to create a BibleGenerationJob.
     */
    data: XOR<BibleGenerationJobCreateInput, BibleGenerationJobUncheckedCreateInput>
  }

  /**
   * BibleGenerationJob createMany
   */
  export type BibleGenerationJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BibleGenerationJobs.
     */
    data: BibleGenerationJobCreateManyInput | BibleGenerationJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BibleGenerationJob createManyAndReturn
   */
  export type BibleGenerationJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BibleGenerationJobs.
     */
    data: BibleGenerationJobCreateManyInput | BibleGenerationJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BibleGenerationJob update
   */
  export type BibleGenerationJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
    /**
     * The data needed to update a BibleGenerationJob.
     */
    data: XOR<BibleGenerationJobUpdateInput, BibleGenerationJobUncheckedUpdateInput>
    /**
     * Choose, which BibleGenerationJob to update.
     */
    where: BibleGenerationJobWhereUniqueInput
  }

  /**
   * BibleGenerationJob updateMany
   */
  export type BibleGenerationJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BibleGenerationJobs.
     */
    data: XOR<BibleGenerationJobUpdateManyMutationInput, BibleGenerationJobUncheckedUpdateManyInput>
    /**
     * Filter which BibleGenerationJobs to update
     */
    where?: BibleGenerationJobWhereInput
  }

  /**
   * BibleGenerationJob upsert
   */
  export type BibleGenerationJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
    /**
     * The filter to search for the BibleGenerationJob to update in case it exists.
     */
    where: BibleGenerationJobWhereUniqueInput
    /**
     * In case the BibleGenerationJob found by the `where` argument doesn't exist, create a new BibleGenerationJob with this data.
     */
    create: XOR<BibleGenerationJobCreateInput, BibleGenerationJobUncheckedCreateInput>
    /**
     * In case the BibleGenerationJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BibleGenerationJobUpdateInput, BibleGenerationJobUncheckedUpdateInput>
  }

  /**
   * BibleGenerationJob delete
   */
  export type BibleGenerationJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
    /**
     * Filter which BibleGenerationJob to delete.
     */
    where: BibleGenerationJobWhereUniqueInput
  }

  /**
   * BibleGenerationJob deleteMany
   */
  export type BibleGenerationJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BibleGenerationJobs to delete
     */
    where?: BibleGenerationJobWhereInput
  }

  /**
   * BibleGenerationJob without action
   */
  export type BibleGenerationJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibleGenerationJob
     */
    select?: BibleGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibleGenerationJobInclude<ExtArgs> | null
  }


  /**
   * Model ChapterComment
   */

  export type AggregateChapterComment = {
    _count: ChapterCommentCountAggregateOutputType | null
    _min: ChapterCommentMinAggregateOutputType | null
    _max: ChapterCommentMaxAggregateOutputType | null
  }

  export type ChapterCommentMinAggregateOutputType = {
    id: string | null
    chapterId: string | null
    authorId: string | null
    parentId: string | null
    content: string | null
    quotedText: string | null
    isResolved: boolean | null
    resolvedAt: Date | null
    resolvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChapterCommentMaxAggregateOutputType = {
    id: string | null
    chapterId: string | null
    authorId: string | null
    parentId: string | null
    content: string | null
    quotedText: string | null
    isResolved: boolean | null
    resolvedAt: Date | null
    resolvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChapterCommentCountAggregateOutputType = {
    id: number
    chapterId: number
    authorId: number
    parentId: number
    content: number
    textRange: number
    quotedText: number
    isResolved: number
    resolvedAt: number
    resolvedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChapterCommentMinAggregateInputType = {
    id?: true
    chapterId?: true
    authorId?: true
    parentId?: true
    content?: true
    quotedText?: true
    isResolved?: true
    resolvedAt?: true
    resolvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChapterCommentMaxAggregateInputType = {
    id?: true
    chapterId?: true
    authorId?: true
    parentId?: true
    content?: true
    quotedText?: true
    isResolved?: true
    resolvedAt?: true
    resolvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChapterCommentCountAggregateInputType = {
    id?: true
    chapterId?: true
    authorId?: true
    parentId?: true
    content?: true
    textRange?: true
    quotedText?: true
    isResolved?: true
    resolvedAt?: true
    resolvedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChapterCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterComment to aggregate.
     */
    where?: ChapterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterComments to fetch.
     */
    orderBy?: ChapterCommentOrderByWithRelationInput | ChapterCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChapterComments
    **/
    _count?: true | ChapterCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterCommentMaxAggregateInputType
  }

  export type GetChapterCommentAggregateType<T extends ChapterCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateChapterComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapterComment[P]>
      : GetScalarType<T[P], AggregateChapterComment[P]>
  }




  export type ChapterCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterCommentWhereInput
    orderBy?: ChapterCommentOrderByWithAggregationInput | ChapterCommentOrderByWithAggregationInput[]
    by: ChapterCommentScalarFieldEnum[] | ChapterCommentScalarFieldEnum
    having?: ChapterCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCommentCountAggregateInputType | true
    _min?: ChapterCommentMinAggregateInputType
    _max?: ChapterCommentMaxAggregateInputType
  }

  export type ChapterCommentGroupByOutputType = {
    id: string
    chapterId: string
    authorId: string
    parentId: string | null
    content: string
    textRange: JsonValue | null
    quotedText: string | null
    isResolved: boolean
    resolvedAt: Date | null
    resolvedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChapterCommentCountAggregateOutputType | null
    _min: ChapterCommentMinAggregateOutputType | null
    _max: ChapterCommentMaxAggregateOutputType | null
  }

  type GetChapterCommentGroupByPayload<T extends ChapterCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterCommentGroupByOutputType[P]>
        }
      >
    >


  export type ChapterCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    authorId?: boolean
    parentId?: boolean
    content?: boolean
    textRange?: boolean
    quotedText?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | ChapterComment$parentArgs<ExtArgs>
    replies?: boolean | ChapterComment$repliesArgs<ExtArgs>
    resolvedBy?: boolean | ChapterComment$resolvedByArgs<ExtArgs>
    _count?: boolean | ChapterCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterComment"]>

  export type ChapterCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    authorId?: boolean
    parentId?: boolean
    content?: boolean
    textRange?: boolean
    quotedText?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | ChapterComment$parentArgs<ExtArgs>
    resolvedBy?: boolean | ChapterComment$resolvedByArgs<ExtArgs>
  }, ExtArgs["result"]["chapterComment"]>

  export type ChapterCommentSelectScalar = {
    id?: boolean
    chapterId?: boolean
    authorId?: boolean
    parentId?: boolean
    content?: boolean
    textRange?: boolean
    quotedText?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChapterCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | ChapterComment$parentArgs<ExtArgs>
    replies?: boolean | ChapterComment$repliesArgs<ExtArgs>
    resolvedBy?: boolean | ChapterComment$resolvedByArgs<ExtArgs>
    _count?: boolean | ChapterCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChapterCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | ChapterComment$parentArgs<ExtArgs>
    resolvedBy?: boolean | ChapterComment$resolvedByArgs<ExtArgs>
  }

  export type $ChapterCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChapterComment"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$ChapterCommentPayload<ExtArgs> | null
      replies: Prisma.$ChapterCommentPayload<ExtArgs>[]
      resolvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chapterId: string
      authorId: string
      parentId: string | null
      content: string
      textRange: Prisma.JsonValue | null
      quotedText: string | null
      isResolved: boolean
      resolvedAt: Date | null
      resolvedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chapterComment"]>
    composites: {}
  }

  type ChapterCommentGetPayload<S extends boolean | null | undefined | ChapterCommentDefaultArgs> = $Result.GetResult<Prisma.$ChapterCommentPayload, S>

  type ChapterCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChapterCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChapterCommentCountAggregateInputType | true
    }

  export interface ChapterCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChapterComment'], meta: { name: 'ChapterComment' } }
    /**
     * Find zero or one ChapterComment that matches the filter.
     * @param {ChapterCommentFindUniqueArgs} args - Arguments to find a ChapterComment
     * @example
     * // Get one ChapterComment
     * const chapterComment = await prisma.chapterComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterCommentFindUniqueArgs>(args: SelectSubset<T, ChapterCommentFindUniqueArgs<ExtArgs>>): Prisma__ChapterCommentClient<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChapterComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChapterCommentFindUniqueOrThrowArgs} args - Arguments to find a ChapterComment
     * @example
     * // Get one ChapterComment
     * const chapterComment = await prisma.chapterComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterCommentClient<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChapterComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCommentFindFirstArgs} args - Arguments to find a ChapterComment
     * @example
     * // Get one ChapterComment
     * const chapterComment = await prisma.chapterComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterCommentFindFirstArgs>(args?: SelectSubset<T, ChapterCommentFindFirstArgs<ExtArgs>>): Prisma__ChapterCommentClient<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChapterComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCommentFindFirstOrThrowArgs} args - Arguments to find a ChapterComment
     * @example
     * // Get one ChapterComment
     * const chapterComment = await prisma.chapterComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterCommentClient<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChapterComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChapterComments
     * const chapterComments = await prisma.chapterComment.findMany()
     * 
     * // Get first 10 ChapterComments
     * const chapterComments = await prisma.chapterComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterCommentWithIdOnly = await prisma.chapterComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterCommentFindManyArgs>(args?: SelectSubset<T, ChapterCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChapterComment.
     * @param {ChapterCommentCreateArgs} args - Arguments to create a ChapterComment.
     * @example
     * // Create one ChapterComment
     * const ChapterComment = await prisma.chapterComment.create({
     *   data: {
     *     // ... data to create a ChapterComment
     *   }
     * })
     * 
     */
    create<T extends ChapterCommentCreateArgs>(args: SelectSubset<T, ChapterCommentCreateArgs<ExtArgs>>): Prisma__ChapterCommentClient<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChapterComments.
     * @param {ChapterCommentCreateManyArgs} args - Arguments to create many ChapterComments.
     * @example
     * // Create many ChapterComments
     * const chapterComment = await prisma.chapterComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCommentCreateManyArgs>(args?: SelectSubset<T, ChapterCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChapterComments and returns the data saved in the database.
     * @param {ChapterCommentCreateManyAndReturnArgs} args - Arguments to create many ChapterComments.
     * @example
     * // Create many ChapterComments
     * const chapterComment = await prisma.chapterComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChapterComments and only return the `id`
     * const chapterCommentWithIdOnly = await prisma.chapterComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChapterComment.
     * @param {ChapterCommentDeleteArgs} args - Arguments to delete one ChapterComment.
     * @example
     * // Delete one ChapterComment
     * const ChapterComment = await prisma.chapterComment.delete({
     *   where: {
     *     // ... filter to delete one ChapterComment
     *   }
     * })
     * 
     */
    delete<T extends ChapterCommentDeleteArgs>(args: SelectSubset<T, ChapterCommentDeleteArgs<ExtArgs>>): Prisma__ChapterCommentClient<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChapterComment.
     * @param {ChapterCommentUpdateArgs} args - Arguments to update one ChapterComment.
     * @example
     * // Update one ChapterComment
     * const chapterComment = await prisma.chapterComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterCommentUpdateArgs>(args: SelectSubset<T, ChapterCommentUpdateArgs<ExtArgs>>): Prisma__ChapterCommentClient<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChapterComments.
     * @param {ChapterCommentDeleteManyArgs} args - Arguments to filter ChapterComments to delete.
     * @example
     * // Delete a few ChapterComments
     * const { count } = await prisma.chapterComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterCommentDeleteManyArgs>(args?: SelectSubset<T, ChapterCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChapterComments
     * const chapterComment = await prisma.chapterComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterCommentUpdateManyArgs>(args: SelectSubset<T, ChapterCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChapterComment.
     * @param {ChapterCommentUpsertArgs} args - Arguments to update or create a ChapterComment.
     * @example
     * // Update or create a ChapterComment
     * const chapterComment = await prisma.chapterComment.upsert({
     *   create: {
     *     // ... data to create a ChapterComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChapterComment we want to update
     *   }
     * })
     */
    upsert<T extends ChapterCommentUpsertArgs>(args: SelectSubset<T, ChapterCommentUpsertArgs<ExtArgs>>): Prisma__ChapterCommentClient<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChapterComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCommentCountArgs} args - Arguments to filter ChapterComments to count.
     * @example
     * // Count the number of ChapterComments
     * const count = await prisma.chapterComment.count({
     *   where: {
     *     // ... the filter for the ChapterComments we want to count
     *   }
     * })
    **/
    count<T extends ChapterCommentCountArgs>(
      args?: Subset<T, ChapterCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChapterComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterCommentAggregateArgs>(args: Subset<T, ChapterCommentAggregateArgs>): Prisma.PrismaPromise<GetChapterCommentAggregateType<T>>

    /**
     * Group by ChapterComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterCommentGroupByArgs['orderBy'] }
        : { orderBy?: ChapterCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChapterComment model
   */
  readonly fields: ChapterCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChapterComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends ChapterComment$parentArgs<ExtArgs> = {}>(args?: Subset<T, ChapterComment$parentArgs<ExtArgs>>): Prisma__ChapterCommentClient<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends ChapterComment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, ChapterComment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterCommentPayload<ExtArgs>, T, "findMany"> | Null>
    resolvedBy<T extends ChapterComment$resolvedByArgs<ExtArgs> = {}>(args?: Subset<T, ChapterComment$resolvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChapterComment model
   */ 
  interface ChapterCommentFieldRefs {
    readonly id: FieldRef<"ChapterComment", 'String'>
    readonly chapterId: FieldRef<"ChapterComment", 'String'>
    readonly authorId: FieldRef<"ChapterComment", 'String'>
    readonly parentId: FieldRef<"ChapterComment", 'String'>
    readonly content: FieldRef<"ChapterComment", 'String'>
    readonly textRange: FieldRef<"ChapterComment", 'Json'>
    readonly quotedText: FieldRef<"ChapterComment", 'String'>
    readonly isResolved: FieldRef<"ChapterComment", 'Boolean'>
    readonly resolvedAt: FieldRef<"ChapterComment", 'DateTime'>
    readonly resolvedById: FieldRef<"ChapterComment", 'String'>
    readonly createdAt: FieldRef<"ChapterComment", 'DateTime'>
    readonly updatedAt: FieldRef<"ChapterComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChapterComment findUnique
   */
  export type ChapterCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    /**
     * Filter, which ChapterComment to fetch.
     */
    where: ChapterCommentWhereUniqueInput
  }

  /**
   * ChapterComment findUniqueOrThrow
   */
  export type ChapterCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    /**
     * Filter, which ChapterComment to fetch.
     */
    where: ChapterCommentWhereUniqueInput
  }

  /**
   * ChapterComment findFirst
   */
  export type ChapterCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    /**
     * Filter, which ChapterComment to fetch.
     */
    where?: ChapterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterComments to fetch.
     */
    orderBy?: ChapterCommentOrderByWithRelationInput | ChapterCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterComments.
     */
    cursor?: ChapterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterComments.
     */
    distinct?: ChapterCommentScalarFieldEnum | ChapterCommentScalarFieldEnum[]
  }

  /**
   * ChapterComment findFirstOrThrow
   */
  export type ChapterCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    /**
     * Filter, which ChapterComment to fetch.
     */
    where?: ChapterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterComments to fetch.
     */
    orderBy?: ChapterCommentOrderByWithRelationInput | ChapterCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterComments.
     */
    cursor?: ChapterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterComments.
     */
    distinct?: ChapterCommentScalarFieldEnum | ChapterCommentScalarFieldEnum[]
  }

  /**
   * ChapterComment findMany
   */
  export type ChapterCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    /**
     * Filter, which ChapterComments to fetch.
     */
    where?: ChapterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterComments to fetch.
     */
    orderBy?: ChapterCommentOrderByWithRelationInput | ChapterCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChapterComments.
     */
    cursor?: ChapterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterComments.
     */
    skip?: number
    distinct?: ChapterCommentScalarFieldEnum | ChapterCommentScalarFieldEnum[]
  }

  /**
   * ChapterComment create
   */
  export type ChapterCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ChapterComment.
     */
    data: XOR<ChapterCommentCreateInput, ChapterCommentUncheckedCreateInput>
  }

  /**
   * ChapterComment createMany
   */
  export type ChapterCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChapterComments.
     */
    data: ChapterCommentCreateManyInput | ChapterCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChapterComment createManyAndReturn
   */
  export type ChapterCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChapterComments.
     */
    data: ChapterCommentCreateManyInput | ChapterCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterComment update
   */
  export type ChapterCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ChapterComment.
     */
    data: XOR<ChapterCommentUpdateInput, ChapterCommentUncheckedUpdateInput>
    /**
     * Choose, which ChapterComment to update.
     */
    where: ChapterCommentWhereUniqueInput
  }

  /**
   * ChapterComment updateMany
   */
  export type ChapterCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChapterComments.
     */
    data: XOR<ChapterCommentUpdateManyMutationInput, ChapterCommentUncheckedUpdateManyInput>
    /**
     * Filter which ChapterComments to update
     */
    where?: ChapterCommentWhereInput
  }

  /**
   * ChapterComment upsert
   */
  export type ChapterCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ChapterComment to update in case it exists.
     */
    where: ChapterCommentWhereUniqueInput
    /**
     * In case the ChapterComment found by the `where` argument doesn't exist, create a new ChapterComment with this data.
     */
    create: XOR<ChapterCommentCreateInput, ChapterCommentUncheckedCreateInput>
    /**
     * In case the ChapterComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterCommentUpdateInput, ChapterCommentUncheckedUpdateInput>
  }

  /**
   * ChapterComment delete
   */
  export type ChapterCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    /**
     * Filter which ChapterComment to delete.
     */
    where: ChapterCommentWhereUniqueInput
  }

  /**
   * ChapterComment deleteMany
   */
  export type ChapterCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterComments to delete
     */
    where?: ChapterCommentWhereInput
  }

  /**
   * ChapterComment.parent
   */
  export type ChapterComment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    where?: ChapterCommentWhereInput
  }

  /**
   * ChapterComment.replies
   */
  export type ChapterComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
    where?: ChapterCommentWhereInput
    orderBy?: ChapterCommentOrderByWithRelationInput | ChapterCommentOrderByWithRelationInput[]
    cursor?: ChapterCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterCommentScalarFieldEnum | ChapterCommentScalarFieldEnum[]
  }

  /**
   * ChapterComment.resolvedBy
   */
  export type ChapterComment$resolvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ChapterComment without action
   */
  export type ChapterCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterComment
     */
    select?: ChapterCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterCommentInclude<ExtArgs> | null
  }


  /**
   * Model ChapterSnapshot
   */

  export type AggregateChapterSnapshot = {
    _count: ChapterSnapshotCountAggregateOutputType | null
    _min: ChapterSnapshotMinAggregateOutputType | null
    _max: ChapterSnapshotMaxAggregateOutputType | null
  }

  export type ChapterSnapshotMinAggregateOutputType = {
    id: string | null
    chapterId: string | null
    authorId: string | null
    name: string | null
    description: string | null
    snapshotType: $Enums.SnapshotType | null
    originalContent: string | null
    translatedContent: string | null
    editedContent: string | null
    status: $Enums.ChapterStatus | null
    triggerEvent: string | null
    createdAt: Date | null
  }

  export type ChapterSnapshotMaxAggregateOutputType = {
    id: string | null
    chapterId: string | null
    authorId: string | null
    name: string | null
    description: string | null
    snapshotType: $Enums.SnapshotType | null
    originalContent: string | null
    translatedContent: string | null
    editedContent: string | null
    status: $Enums.ChapterStatus | null
    triggerEvent: string | null
    createdAt: Date | null
  }

  export type ChapterSnapshotCountAggregateOutputType = {
    id: number
    chapterId: number
    authorId: number
    name: number
    description: number
    snapshotType: number
    originalContent: number
    translatedContent: number
    editedContent: number
    status: number
    triggerEvent: number
    createdAt: number
    _all: number
  }


  export type ChapterSnapshotMinAggregateInputType = {
    id?: true
    chapterId?: true
    authorId?: true
    name?: true
    description?: true
    snapshotType?: true
    originalContent?: true
    translatedContent?: true
    editedContent?: true
    status?: true
    triggerEvent?: true
    createdAt?: true
  }

  export type ChapterSnapshotMaxAggregateInputType = {
    id?: true
    chapterId?: true
    authorId?: true
    name?: true
    description?: true
    snapshotType?: true
    originalContent?: true
    translatedContent?: true
    editedContent?: true
    status?: true
    triggerEvent?: true
    createdAt?: true
  }

  export type ChapterSnapshotCountAggregateInputType = {
    id?: true
    chapterId?: true
    authorId?: true
    name?: true
    description?: true
    snapshotType?: true
    originalContent?: true
    translatedContent?: true
    editedContent?: true
    status?: true
    triggerEvent?: true
    createdAt?: true
    _all?: true
  }

  export type ChapterSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterSnapshot to aggregate.
     */
    where?: ChapterSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterSnapshots to fetch.
     */
    orderBy?: ChapterSnapshotOrderByWithRelationInput | ChapterSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChapterSnapshots
    **/
    _count?: true | ChapterSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterSnapshotMaxAggregateInputType
  }

  export type GetChapterSnapshotAggregateType<T extends ChapterSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateChapterSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapterSnapshot[P]>
      : GetScalarType<T[P], AggregateChapterSnapshot[P]>
  }




  export type ChapterSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterSnapshotWhereInput
    orderBy?: ChapterSnapshotOrderByWithAggregationInput | ChapterSnapshotOrderByWithAggregationInput[]
    by: ChapterSnapshotScalarFieldEnum[] | ChapterSnapshotScalarFieldEnum
    having?: ChapterSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterSnapshotCountAggregateInputType | true
    _min?: ChapterSnapshotMinAggregateInputType
    _max?: ChapterSnapshotMaxAggregateInputType
  }

  export type ChapterSnapshotGroupByOutputType = {
    id: string
    chapterId: string
    authorId: string
    name: string | null
    description: string | null
    snapshotType: $Enums.SnapshotType
    originalContent: string
    translatedContent: string | null
    editedContent: string | null
    status: $Enums.ChapterStatus
    triggerEvent: string | null
    createdAt: Date
    _count: ChapterSnapshotCountAggregateOutputType | null
    _min: ChapterSnapshotMinAggregateOutputType | null
    _max: ChapterSnapshotMaxAggregateOutputType | null
  }

  type GetChapterSnapshotGroupByPayload<T extends ChapterSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    authorId?: boolean
    name?: boolean
    description?: boolean
    snapshotType?: boolean
    originalContent?: boolean
    translatedContent?: boolean
    editedContent?: boolean
    status?: boolean
    triggerEvent?: boolean
    createdAt?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterSnapshot"]>

  export type ChapterSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    authorId?: boolean
    name?: boolean
    description?: boolean
    snapshotType?: boolean
    originalContent?: boolean
    translatedContent?: boolean
    editedContent?: boolean
    status?: boolean
    triggerEvent?: boolean
    createdAt?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterSnapshot"]>

  export type ChapterSnapshotSelectScalar = {
    id?: boolean
    chapterId?: boolean
    authorId?: boolean
    name?: boolean
    description?: boolean
    snapshotType?: boolean
    originalContent?: boolean
    translatedContent?: boolean
    editedContent?: boolean
    status?: boolean
    triggerEvent?: boolean
    createdAt?: boolean
  }

  export type ChapterSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChapterSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChapterSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChapterSnapshot"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chapterId: string
      authorId: string
      name: string | null
      description: string | null
      snapshotType: $Enums.SnapshotType
      originalContent: string
      translatedContent: string | null
      editedContent: string | null
      status: $Enums.ChapterStatus
      triggerEvent: string | null
      createdAt: Date
    }, ExtArgs["result"]["chapterSnapshot"]>
    composites: {}
  }

  type ChapterSnapshotGetPayload<S extends boolean | null | undefined | ChapterSnapshotDefaultArgs> = $Result.GetResult<Prisma.$ChapterSnapshotPayload, S>

  type ChapterSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChapterSnapshotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChapterSnapshotCountAggregateInputType | true
    }

  export interface ChapterSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChapterSnapshot'], meta: { name: 'ChapterSnapshot' } }
    /**
     * Find zero or one ChapterSnapshot that matches the filter.
     * @param {ChapterSnapshotFindUniqueArgs} args - Arguments to find a ChapterSnapshot
     * @example
     * // Get one ChapterSnapshot
     * const chapterSnapshot = await prisma.chapterSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterSnapshotFindUniqueArgs>(args: SelectSubset<T, ChapterSnapshotFindUniqueArgs<ExtArgs>>): Prisma__ChapterSnapshotClient<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChapterSnapshot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChapterSnapshotFindUniqueOrThrowArgs} args - Arguments to find a ChapterSnapshot
     * @example
     * // Get one ChapterSnapshot
     * const chapterSnapshot = await prisma.chapterSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterSnapshotClient<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChapterSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterSnapshotFindFirstArgs} args - Arguments to find a ChapterSnapshot
     * @example
     * // Get one ChapterSnapshot
     * const chapterSnapshot = await prisma.chapterSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterSnapshotFindFirstArgs>(args?: SelectSubset<T, ChapterSnapshotFindFirstArgs<ExtArgs>>): Prisma__ChapterSnapshotClient<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChapterSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterSnapshotFindFirstOrThrowArgs} args - Arguments to find a ChapterSnapshot
     * @example
     * // Get one ChapterSnapshot
     * const chapterSnapshot = await prisma.chapterSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterSnapshotClient<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChapterSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChapterSnapshots
     * const chapterSnapshots = await prisma.chapterSnapshot.findMany()
     * 
     * // Get first 10 ChapterSnapshots
     * const chapterSnapshots = await prisma.chapterSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterSnapshotWithIdOnly = await prisma.chapterSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterSnapshotFindManyArgs>(args?: SelectSubset<T, ChapterSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChapterSnapshot.
     * @param {ChapterSnapshotCreateArgs} args - Arguments to create a ChapterSnapshot.
     * @example
     * // Create one ChapterSnapshot
     * const ChapterSnapshot = await prisma.chapterSnapshot.create({
     *   data: {
     *     // ... data to create a ChapterSnapshot
     *   }
     * })
     * 
     */
    create<T extends ChapterSnapshotCreateArgs>(args: SelectSubset<T, ChapterSnapshotCreateArgs<ExtArgs>>): Prisma__ChapterSnapshotClient<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChapterSnapshots.
     * @param {ChapterSnapshotCreateManyArgs} args - Arguments to create many ChapterSnapshots.
     * @example
     * // Create many ChapterSnapshots
     * const chapterSnapshot = await prisma.chapterSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterSnapshotCreateManyArgs>(args?: SelectSubset<T, ChapterSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChapterSnapshots and returns the data saved in the database.
     * @param {ChapterSnapshotCreateManyAndReturnArgs} args - Arguments to create many ChapterSnapshots.
     * @example
     * // Create many ChapterSnapshots
     * const chapterSnapshot = await prisma.chapterSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChapterSnapshots and only return the `id`
     * const chapterSnapshotWithIdOnly = await prisma.chapterSnapshot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChapterSnapshot.
     * @param {ChapterSnapshotDeleteArgs} args - Arguments to delete one ChapterSnapshot.
     * @example
     * // Delete one ChapterSnapshot
     * const ChapterSnapshot = await prisma.chapterSnapshot.delete({
     *   where: {
     *     // ... filter to delete one ChapterSnapshot
     *   }
     * })
     * 
     */
    delete<T extends ChapterSnapshotDeleteArgs>(args: SelectSubset<T, ChapterSnapshotDeleteArgs<ExtArgs>>): Prisma__ChapterSnapshotClient<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChapterSnapshot.
     * @param {ChapterSnapshotUpdateArgs} args - Arguments to update one ChapterSnapshot.
     * @example
     * // Update one ChapterSnapshot
     * const chapterSnapshot = await prisma.chapterSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterSnapshotUpdateArgs>(args: SelectSubset<T, ChapterSnapshotUpdateArgs<ExtArgs>>): Prisma__ChapterSnapshotClient<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChapterSnapshots.
     * @param {ChapterSnapshotDeleteManyArgs} args - Arguments to filter ChapterSnapshots to delete.
     * @example
     * // Delete a few ChapterSnapshots
     * const { count } = await prisma.chapterSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterSnapshotDeleteManyArgs>(args?: SelectSubset<T, ChapterSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChapterSnapshots
     * const chapterSnapshot = await prisma.chapterSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterSnapshotUpdateManyArgs>(args: SelectSubset<T, ChapterSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChapterSnapshot.
     * @param {ChapterSnapshotUpsertArgs} args - Arguments to update or create a ChapterSnapshot.
     * @example
     * // Update or create a ChapterSnapshot
     * const chapterSnapshot = await prisma.chapterSnapshot.upsert({
     *   create: {
     *     // ... data to create a ChapterSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChapterSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends ChapterSnapshotUpsertArgs>(args: SelectSubset<T, ChapterSnapshotUpsertArgs<ExtArgs>>): Prisma__ChapterSnapshotClient<$Result.GetResult<Prisma.$ChapterSnapshotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChapterSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterSnapshotCountArgs} args - Arguments to filter ChapterSnapshots to count.
     * @example
     * // Count the number of ChapterSnapshots
     * const count = await prisma.chapterSnapshot.count({
     *   where: {
     *     // ... the filter for the ChapterSnapshots we want to count
     *   }
     * })
    **/
    count<T extends ChapterSnapshotCountArgs>(
      args?: Subset<T, ChapterSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChapterSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterSnapshotAggregateArgs>(args: Subset<T, ChapterSnapshotAggregateArgs>): Prisma.PrismaPromise<GetChapterSnapshotAggregateType<T>>

    /**
     * Group by ChapterSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: ChapterSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChapterSnapshot model
   */
  readonly fields: ChapterSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChapterSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChapterSnapshot model
   */ 
  interface ChapterSnapshotFieldRefs {
    readonly id: FieldRef<"ChapterSnapshot", 'String'>
    readonly chapterId: FieldRef<"ChapterSnapshot", 'String'>
    readonly authorId: FieldRef<"ChapterSnapshot", 'String'>
    readonly name: FieldRef<"ChapterSnapshot", 'String'>
    readonly description: FieldRef<"ChapterSnapshot", 'String'>
    readonly snapshotType: FieldRef<"ChapterSnapshot", 'SnapshotType'>
    readonly originalContent: FieldRef<"ChapterSnapshot", 'String'>
    readonly translatedContent: FieldRef<"ChapterSnapshot", 'String'>
    readonly editedContent: FieldRef<"ChapterSnapshot", 'String'>
    readonly status: FieldRef<"ChapterSnapshot", 'ChapterStatus'>
    readonly triggerEvent: FieldRef<"ChapterSnapshot", 'String'>
    readonly createdAt: FieldRef<"ChapterSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChapterSnapshot findUnique
   */
  export type ChapterSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which ChapterSnapshot to fetch.
     */
    where: ChapterSnapshotWhereUniqueInput
  }

  /**
   * ChapterSnapshot findUniqueOrThrow
   */
  export type ChapterSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which ChapterSnapshot to fetch.
     */
    where: ChapterSnapshotWhereUniqueInput
  }

  /**
   * ChapterSnapshot findFirst
   */
  export type ChapterSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which ChapterSnapshot to fetch.
     */
    where?: ChapterSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterSnapshots to fetch.
     */
    orderBy?: ChapterSnapshotOrderByWithRelationInput | ChapterSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterSnapshots.
     */
    cursor?: ChapterSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterSnapshots.
     */
    distinct?: ChapterSnapshotScalarFieldEnum | ChapterSnapshotScalarFieldEnum[]
  }

  /**
   * ChapterSnapshot findFirstOrThrow
   */
  export type ChapterSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which ChapterSnapshot to fetch.
     */
    where?: ChapterSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterSnapshots to fetch.
     */
    orderBy?: ChapterSnapshotOrderByWithRelationInput | ChapterSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterSnapshots.
     */
    cursor?: ChapterSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterSnapshots.
     */
    distinct?: ChapterSnapshotScalarFieldEnum | ChapterSnapshotScalarFieldEnum[]
  }

  /**
   * ChapterSnapshot findMany
   */
  export type ChapterSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which ChapterSnapshots to fetch.
     */
    where?: ChapterSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterSnapshots to fetch.
     */
    orderBy?: ChapterSnapshotOrderByWithRelationInput | ChapterSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChapterSnapshots.
     */
    cursor?: ChapterSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterSnapshots.
     */
    skip?: number
    distinct?: ChapterSnapshotScalarFieldEnum | ChapterSnapshotScalarFieldEnum[]
  }

  /**
   * ChapterSnapshot create
   */
  export type ChapterSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a ChapterSnapshot.
     */
    data: XOR<ChapterSnapshotCreateInput, ChapterSnapshotUncheckedCreateInput>
  }

  /**
   * ChapterSnapshot createMany
   */
  export type ChapterSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChapterSnapshots.
     */
    data: ChapterSnapshotCreateManyInput | ChapterSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChapterSnapshot createManyAndReturn
   */
  export type ChapterSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChapterSnapshots.
     */
    data: ChapterSnapshotCreateManyInput | ChapterSnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterSnapshot update
   */
  export type ChapterSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a ChapterSnapshot.
     */
    data: XOR<ChapterSnapshotUpdateInput, ChapterSnapshotUncheckedUpdateInput>
    /**
     * Choose, which ChapterSnapshot to update.
     */
    where: ChapterSnapshotWhereUniqueInput
  }

  /**
   * ChapterSnapshot updateMany
   */
  export type ChapterSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChapterSnapshots.
     */
    data: XOR<ChapterSnapshotUpdateManyMutationInput, ChapterSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which ChapterSnapshots to update
     */
    where?: ChapterSnapshotWhereInput
  }

  /**
   * ChapterSnapshot upsert
   */
  export type ChapterSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the ChapterSnapshot to update in case it exists.
     */
    where: ChapterSnapshotWhereUniqueInput
    /**
     * In case the ChapterSnapshot found by the `where` argument doesn't exist, create a new ChapterSnapshot with this data.
     */
    create: XOR<ChapterSnapshotCreateInput, ChapterSnapshotUncheckedCreateInput>
    /**
     * In case the ChapterSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterSnapshotUpdateInput, ChapterSnapshotUncheckedUpdateInput>
  }

  /**
   * ChapterSnapshot delete
   */
  export type ChapterSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
    /**
     * Filter which ChapterSnapshot to delete.
     */
    where: ChapterSnapshotWhereUniqueInput
  }

  /**
   * ChapterSnapshot deleteMany
   */
  export type ChapterSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterSnapshots to delete
     */
    where?: ChapterSnapshotWhereInput
  }

  /**
   * ChapterSnapshot without action
   */
  export type ChapterSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterSnapshot
     */
    select?: ChapterSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model ChapterChange
   */

  export type AggregateChapterChange = {
    _count: ChapterChangeCountAggregateOutputType | null
    _avg: ChapterChangeAvgAggregateOutputType | null
    _sum: ChapterChangeSumAggregateOutputType | null
    _min: ChapterChangeMinAggregateOutputType | null
    _max: ChapterChangeMaxAggregateOutputType | null
  }

  export type ChapterChangeAvgAggregateOutputType = {
    fromPos: number | null
    toPos: number | null
  }

  export type ChapterChangeSumAggregateOutputType = {
    fromPos: number | null
    toPos: number | null
  }

  export type ChapterChangeMinAggregateOutputType = {
    id: string | null
    chapterId: string | null
    authorId: string | null
    changeType: $Enums.ChangeType | null
    fromPos: number | null
    toPos: number | null
    oldText: string | null
    newText: string | null
    status: $Enums.ChangeStatus | null
    reviewedById: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ChapterChangeMaxAggregateOutputType = {
    id: string | null
    chapterId: string | null
    authorId: string | null
    changeType: $Enums.ChangeType | null
    fromPos: number | null
    toPos: number | null
    oldText: string | null
    newText: string | null
    status: $Enums.ChangeStatus | null
    reviewedById: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ChapterChangeCountAggregateOutputType = {
    id: number
    chapterId: number
    authorId: number
    changeType: number
    fromPos: number
    toPos: number
    oldText: number
    newText: number
    status: number
    reviewedById: number
    reviewedAt: number
    createdAt: number
    _all: number
  }


  export type ChapterChangeAvgAggregateInputType = {
    fromPos?: true
    toPos?: true
  }

  export type ChapterChangeSumAggregateInputType = {
    fromPos?: true
    toPos?: true
  }

  export type ChapterChangeMinAggregateInputType = {
    id?: true
    chapterId?: true
    authorId?: true
    changeType?: true
    fromPos?: true
    toPos?: true
    oldText?: true
    newText?: true
    status?: true
    reviewedById?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ChapterChangeMaxAggregateInputType = {
    id?: true
    chapterId?: true
    authorId?: true
    changeType?: true
    fromPos?: true
    toPos?: true
    oldText?: true
    newText?: true
    status?: true
    reviewedById?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ChapterChangeCountAggregateInputType = {
    id?: true
    chapterId?: true
    authorId?: true
    changeType?: true
    fromPos?: true
    toPos?: true
    oldText?: true
    newText?: true
    status?: true
    reviewedById?: true
    reviewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ChapterChangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterChange to aggregate.
     */
    where?: ChapterChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChanges to fetch.
     */
    orderBy?: ChapterChangeOrderByWithRelationInput | ChapterChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChapterChanges
    **/
    _count?: true | ChapterChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterChangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterChangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterChangeMaxAggregateInputType
  }

  export type GetChapterChangeAggregateType<T extends ChapterChangeAggregateArgs> = {
        [P in keyof T & keyof AggregateChapterChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapterChange[P]>
      : GetScalarType<T[P], AggregateChapterChange[P]>
  }




  export type ChapterChangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterChangeWhereInput
    orderBy?: ChapterChangeOrderByWithAggregationInput | ChapterChangeOrderByWithAggregationInput[]
    by: ChapterChangeScalarFieldEnum[] | ChapterChangeScalarFieldEnum
    having?: ChapterChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterChangeCountAggregateInputType | true
    _avg?: ChapterChangeAvgAggregateInputType
    _sum?: ChapterChangeSumAggregateInputType
    _min?: ChapterChangeMinAggregateInputType
    _max?: ChapterChangeMaxAggregateInputType
  }

  export type ChapterChangeGroupByOutputType = {
    id: string
    chapterId: string
    authorId: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText: string | null
    newText: string | null
    status: $Enums.ChangeStatus
    reviewedById: string | null
    reviewedAt: Date | null
    createdAt: Date
    _count: ChapterChangeCountAggregateOutputType | null
    _avg: ChapterChangeAvgAggregateOutputType | null
    _sum: ChapterChangeSumAggregateOutputType | null
    _min: ChapterChangeMinAggregateOutputType | null
    _max: ChapterChangeMaxAggregateOutputType | null
  }

  type GetChapterChangeGroupByPayload<T extends ChapterChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterChangeGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterChangeGroupByOutputType[P]>
        }
      >
    >


  export type ChapterChangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    authorId?: boolean
    changeType?: boolean
    fromPos?: boolean
    toPos?: boolean
    oldText?: boolean
    newText?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | ChapterChange$reviewedByArgs<ExtArgs>
  }, ExtArgs["result"]["chapterChange"]>

  export type ChapterChangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    authorId?: boolean
    changeType?: boolean
    fromPos?: boolean
    toPos?: boolean
    oldText?: boolean
    newText?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | ChapterChange$reviewedByArgs<ExtArgs>
  }, ExtArgs["result"]["chapterChange"]>

  export type ChapterChangeSelectScalar = {
    id?: boolean
    chapterId?: boolean
    authorId?: boolean
    changeType?: boolean
    fromPos?: boolean
    toPos?: boolean
    oldText?: boolean
    newText?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }

  export type ChapterChangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | ChapterChange$reviewedByArgs<ExtArgs>
  }
  export type ChapterChangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | ChapterChange$reviewedByArgs<ExtArgs>
  }

  export type $ChapterChangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChapterChange"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      reviewedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chapterId: string
      authorId: string
      changeType: $Enums.ChangeType
      fromPos: number
      toPos: number
      oldText: string | null
      newText: string | null
      status: $Enums.ChangeStatus
      reviewedById: string | null
      reviewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["chapterChange"]>
    composites: {}
  }

  type ChapterChangeGetPayload<S extends boolean | null | undefined | ChapterChangeDefaultArgs> = $Result.GetResult<Prisma.$ChapterChangePayload, S>

  type ChapterChangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChapterChangeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChapterChangeCountAggregateInputType | true
    }

  export interface ChapterChangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChapterChange'], meta: { name: 'ChapterChange' } }
    /**
     * Find zero or one ChapterChange that matches the filter.
     * @param {ChapterChangeFindUniqueArgs} args - Arguments to find a ChapterChange
     * @example
     * // Get one ChapterChange
     * const chapterChange = await prisma.chapterChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterChangeFindUniqueArgs>(args: SelectSubset<T, ChapterChangeFindUniqueArgs<ExtArgs>>): Prisma__ChapterChangeClient<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChapterChange that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChapterChangeFindUniqueOrThrowArgs} args - Arguments to find a ChapterChange
     * @example
     * // Get one ChapterChange
     * const chapterChange = await prisma.chapterChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterChangeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterChangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterChangeClient<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChapterChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChangeFindFirstArgs} args - Arguments to find a ChapterChange
     * @example
     * // Get one ChapterChange
     * const chapterChange = await prisma.chapterChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterChangeFindFirstArgs>(args?: SelectSubset<T, ChapterChangeFindFirstArgs<ExtArgs>>): Prisma__ChapterChangeClient<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChapterChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChangeFindFirstOrThrowArgs} args - Arguments to find a ChapterChange
     * @example
     * // Get one ChapterChange
     * const chapterChange = await prisma.chapterChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterChangeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterChangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterChangeClient<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChapterChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChapterChanges
     * const chapterChanges = await prisma.chapterChange.findMany()
     * 
     * // Get first 10 ChapterChanges
     * const chapterChanges = await prisma.chapterChange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterChangeWithIdOnly = await prisma.chapterChange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterChangeFindManyArgs>(args?: SelectSubset<T, ChapterChangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChapterChange.
     * @param {ChapterChangeCreateArgs} args - Arguments to create a ChapterChange.
     * @example
     * // Create one ChapterChange
     * const ChapterChange = await prisma.chapterChange.create({
     *   data: {
     *     // ... data to create a ChapterChange
     *   }
     * })
     * 
     */
    create<T extends ChapterChangeCreateArgs>(args: SelectSubset<T, ChapterChangeCreateArgs<ExtArgs>>): Prisma__ChapterChangeClient<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChapterChanges.
     * @param {ChapterChangeCreateManyArgs} args - Arguments to create many ChapterChanges.
     * @example
     * // Create many ChapterChanges
     * const chapterChange = await prisma.chapterChange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterChangeCreateManyArgs>(args?: SelectSubset<T, ChapterChangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChapterChanges and returns the data saved in the database.
     * @param {ChapterChangeCreateManyAndReturnArgs} args - Arguments to create many ChapterChanges.
     * @example
     * // Create many ChapterChanges
     * const chapterChange = await prisma.chapterChange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChapterChanges and only return the `id`
     * const chapterChangeWithIdOnly = await prisma.chapterChange.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterChangeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterChangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChapterChange.
     * @param {ChapterChangeDeleteArgs} args - Arguments to delete one ChapterChange.
     * @example
     * // Delete one ChapterChange
     * const ChapterChange = await prisma.chapterChange.delete({
     *   where: {
     *     // ... filter to delete one ChapterChange
     *   }
     * })
     * 
     */
    delete<T extends ChapterChangeDeleteArgs>(args: SelectSubset<T, ChapterChangeDeleteArgs<ExtArgs>>): Prisma__ChapterChangeClient<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChapterChange.
     * @param {ChapterChangeUpdateArgs} args - Arguments to update one ChapterChange.
     * @example
     * // Update one ChapterChange
     * const chapterChange = await prisma.chapterChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterChangeUpdateArgs>(args: SelectSubset<T, ChapterChangeUpdateArgs<ExtArgs>>): Prisma__ChapterChangeClient<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChapterChanges.
     * @param {ChapterChangeDeleteManyArgs} args - Arguments to filter ChapterChanges to delete.
     * @example
     * // Delete a few ChapterChanges
     * const { count } = await prisma.chapterChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterChangeDeleteManyArgs>(args?: SelectSubset<T, ChapterChangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChapterChanges
     * const chapterChange = await prisma.chapterChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterChangeUpdateManyArgs>(args: SelectSubset<T, ChapterChangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChapterChange.
     * @param {ChapterChangeUpsertArgs} args - Arguments to update or create a ChapterChange.
     * @example
     * // Update or create a ChapterChange
     * const chapterChange = await prisma.chapterChange.upsert({
     *   create: {
     *     // ... data to create a ChapterChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChapterChange we want to update
     *   }
     * })
     */
    upsert<T extends ChapterChangeUpsertArgs>(args: SelectSubset<T, ChapterChangeUpsertArgs<ExtArgs>>): Prisma__ChapterChangeClient<$Result.GetResult<Prisma.$ChapterChangePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChapterChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChangeCountArgs} args - Arguments to filter ChapterChanges to count.
     * @example
     * // Count the number of ChapterChanges
     * const count = await prisma.chapterChange.count({
     *   where: {
     *     // ... the filter for the ChapterChanges we want to count
     *   }
     * })
    **/
    count<T extends ChapterChangeCountArgs>(
      args?: Subset<T, ChapterChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChapterChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterChangeAggregateArgs>(args: Subset<T, ChapterChangeAggregateArgs>): Prisma.PrismaPromise<GetChapterChangeAggregateType<T>>

    /**
     * Group by ChapterChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterChangeGroupByArgs['orderBy'] }
        : { orderBy?: ChapterChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChapterChange model
   */
  readonly fields: ChapterChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChapterChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterChangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviewedBy<T extends ChapterChange$reviewedByArgs<ExtArgs> = {}>(args?: Subset<T, ChapterChange$reviewedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChapterChange model
   */ 
  interface ChapterChangeFieldRefs {
    readonly id: FieldRef<"ChapterChange", 'String'>
    readonly chapterId: FieldRef<"ChapterChange", 'String'>
    readonly authorId: FieldRef<"ChapterChange", 'String'>
    readonly changeType: FieldRef<"ChapterChange", 'ChangeType'>
    readonly fromPos: FieldRef<"ChapterChange", 'Int'>
    readonly toPos: FieldRef<"ChapterChange", 'Int'>
    readonly oldText: FieldRef<"ChapterChange", 'String'>
    readonly newText: FieldRef<"ChapterChange", 'String'>
    readonly status: FieldRef<"ChapterChange", 'ChangeStatus'>
    readonly reviewedById: FieldRef<"ChapterChange", 'String'>
    readonly reviewedAt: FieldRef<"ChapterChange", 'DateTime'>
    readonly createdAt: FieldRef<"ChapterChange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChapterChange findUnique
   */
  export type ChapterChangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChange to fetch.
     */
    where: ChapterChangeWhereUniqueInput
  }

  /**
   * ChapterChange findUniqueOrThrow
   */
  export type ChapterChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChange to fetch.
     */
    where: ChapterChangeWhereUniqueInput
  }

  /**
   * ChapterChange findFirst
   */
  export type ChapterChangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChange to fetch.
     */
    where?: ChapterChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChanges to fetch.
     */
    orderBy?: ChapterChangeOrderByWithRelationInput | ChapterChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterChanges.
     */
    cursor?: ChapterChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterChanges.
     */
    distinct?: ChapterChangeScalarFieldEnum | ChapterChangeScalarFieldEnum[]
  }

  /**
   * ChapterChange findFirstOrThrow
   */
  export type ChapterChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChange to fetch.
     */
    where?: ChapterChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChanges to fetch.
     */
    orderBy?: ChapterChangeOrderByWithRelationInput | ChapterChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterChanges.
     */
    cursor?: ChapterChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterChanges.
     */
    distinct?: ChapterChangeScalarFieldEnum | ChapterChangeScalarFieldEnum[]
  }

  /**
   * ChapterChange findMany
   */
  export type ChapterChangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChanges to fetch.
     */
    where?: ChapterChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChanges to fetch.
     */
    orderBy?: ChapterChangeOrderByWithRelationInput | ChapterChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChapterChanges.
     */
    cursor?: ChapterChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChanges.
     */
    skip?: number
    distinct?: ChapterChangeScalarFieldEnum | ChapterChangeScalarFieldEnum[]
  }

  /**
   * ChapterChange create
   */
  export type ChapterChangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a ChapterChange.
     */
    data: XOR<ChapterChangeCreateInput, ChapterChangeUncheckedCreateInput>
  }

  /**
   * ChapterChange createMany
   */
  export type ChapterChangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChapterChanges.
     */
    data: ChapterChangeCreateManyInput | ChapterChangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChapterChange createManyAndReturn
   */
  export type ChapterChangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChapterChanges.
     */
    data: ChapterChangeCreateManyInput | ChapterChangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterChange update
   */
  export type ChapterChangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a ChapterChange.
     */
    data: XOR<ChapterChangeUpdateInput, ChapterChangeUncheckedUpdateInput>
    /**
     * Choose, which ChapterChange to update.
     */
    where: ChapterChangeWhereUniqueInput
  }

  /**
   * ChapterChange updateMany
   */
  export type ChapterChangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChapterChanges.
     */
    data: XOR<ChapterChangeUpdateManyMutationInput, ChapterChangeUncheckedUpdateManyInput>
    /**
     * Filter which ChapterChanges to update
     */
    where?: ChapterChangeWhereInput
  }

  /**
   * ChapterChange upsert
   */
  export type ChapterChangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the ChapterChange to update in case it exists.
     */
    where: ChapterChangeWhereUniqueInput
    /**
     * In case the ChapterChange found by the `where` argument doesn't exist, create a new ChapterChange with this data.
     */
    create: XOR<ChapterChangeCreateInput, ChapterChangeUncheckedCreateInput>
    /**
     * In case the ChapterChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterChangeUpdateInput, ChapterChangeUncheckedUpdateInput>
  }

  /**
   * ChapterChange delete
   */
  export type ChapterChangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
    /**
     * Filter which ChapterChange to delete.
     */
    where: ChapterChangeWhereUniqueInput
  }

  /**
   * ChapterChange deleteMany
   */
  export type ChapterChangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterChanges to delete
     */
    where?: ChapterChangeWhereInput
  }

  /**
   * ChapterChange.reviewedBy
   */
  export type ChapterChange$reviewedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ChapterChange without action
   */
  export type ChapterChangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChange
     */
    select?: ChapterChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChangeInclude<ExtArgs> | null
  }


  /**
   * Model ChapterActivity
   */

  export type AggregateChapterActivity = {
    _count: ChapterActivityCountAggregateOutputType | null
    _min: ChapterActivityMinAggregateOutputType | null
    _max: ChapterActivityMaxAggregateOutputType | null
  }

  export type ChapterActivityMinAggregateOutputType = {
    id: string | null
    chapterId: string | null
    actorId: string | null
    activityType: $Enums.ActivityType | null
    summary: string | null
    createdAt: Date | null
  }

  export type ChapterActivityMaxAggregateOutputType = {
    id: string | null
    chapterId: string | null
    actorId: string | null
    activityType: $Enums.ActivityType | null
    summary: string | null
    createdAt: Date | null
  }

  export type ChapterActivityCountAggregateOutputType = {
    id: number
    chapterId: number
    actorId: number
    activityType: number
    metadata: number
    summary: number
    createdAt: number
    _all: number
  }


  export type ChapterActivityMinAggregateInputType = {
    id?: true
    chapterId?: true
    actorId?: true
    activityType?: true
    summary?: true
    createdAt?: true
  }

  export type ChapterActivityMaxAggregateInputType = {
    id?: true
    chapterId?: true
    actorId?: true
    activityType?: true
    summary?: true
    createdAt?: true
  }

  export type ChapterActivityCountAggregateInputType = {
    id?: true
    chapterId?: true
    actorId?: true
    activityType?: true
    metadata?: true
    summary?: true
    createdAt?: true
    _all?: true
  }

  export type ChapterActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterActivity to aggregate.
     */
    where?: ChapterActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterActivities to fetch.
     */
    orderBy?: ChapterActivityOrderByWithRelationInput | ChapterActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChapterActivities
    **/
    _count?: true | ChapterActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterActivityMaxAggregateInputType
  }

  export type GetChapterActivityAggregateType<T extends ChapterActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateChapterActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapterActivity[P]>
      : GetScalarType<T[P], AggregateChapterActivity[P]>
  }




  export type ChapterActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterActivityWhereInput
    orderBy?: ChapterActivityOrderByWithAggregationInput | ChapterActivityOrderByWithAggregationInput[]
    by: ChapterActivityScalarFieldEnum[] | ChapterActivityScalarFieldEnum
    having?: ChapterActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterActivityCountAggregateInputType | true
    _min?: ChapterActivityMinAggregateInputType
    _max?: ChapterActivityMaxAggregateInputType
  }

  export type ChapterActivityGroupByOutputType = {
    id: string
    chapterId: string
    actorId: string
    activityType: $Enums.ActivityType
    metadata: JsonValue | null
    summary: string
    createdAt: Date
    _count: ChapterActivityCountAggregateOutputType | null
    _min: ChapterActivityMinAggregateOutputType | null
    _max: ChapterActivityMaxAggregateOutputType | null
  }

  type GetChapterActivityGroupByPayload<T extends ChapterActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterActivityGroupByOutputType[P]>
        }
      >
    >


  export type ChapterActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    actorId?: boolean
    activityType?: boolean
    metadata?: boolean
    summary?: boolean
    createdAt?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterActivity"]>

  export type ChapterActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    actorId?: boolean
    activityType?: boolean
    metadata?: boolean
    summary?: boolean
    createdAt?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterActivity"]>

  export type ChapterActivitySelectScalar = {
    id?: boolean
    chapterId?: boolean
    actorId?: boolean
    activityType?: boolean
    metadata?: boolean
    summary?: boolean
    createdAt?: boolean
  }

  export type ChapterActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChapterActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChapterActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChapterActivity"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
      actor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chapterId: string
      actorId: string
      activityType: $Enums.ActivityType
      metadata: Prisma.JsonValue | null
      summary: string
      createdAt: Date
    }, ExtArgs["result"]["chapterActivity"]>
    composites: {}
  }

  type ChapterActivityGetPayload<S extends boolean | null | undefined | ChapterActivityDefaultArgs> = $Result.GetResult<Prisma.$ChapterActivityPayload, S>

  type ChapterActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChapterActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChapterActivityCountAggregateInputType | true
    }

  export interface ChapterActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChapterActivity'], meta: { name: 'ChapterActivity' } }
    /**
     * Find zero or one ChapterActivity that matches the filter.
     * @param {ChapterActivityFindUniqueArgs} args - Arguments to find a ChapterActivity
     * @example
     * // Get one ChapterActivity
     * const chapterActivity = await prisma.chapterActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterActivityFindUniqueArgs>(args: SelectSubset<T, ChapterActivityFindUniqueArgs<ExtArgs>>): Prisma__ChapterActivityClient<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChapterActivity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChapterActivityFindUniqueOrThrowArgs} args - Arguments to find a ChapterActivity
     * @example
     * // Get one ChapterActivity
     * const chapterActivity = await prisma.chapterActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterActivityClient<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChapterActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterActivityFindFirstArgs} args - Arguments to find a ChapterActivity
     * @example
     * // Get one ChapterActivity
     * const chapterActivity = await prisma.chapterActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterActivityFindFirstArgs>(args?: SelectSubset<T, ChapterActivityFindFirstArgs<ExtArgs>>): Prisma__ChapterActivityClient<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChapterActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterActivityFindFirstOrThrowArgs} args - Arguments to find a ChapterActivity
     * @example
     * // Get one ChapterActivity
     * const chapterActivity = await prisma.chapterActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterActivityClient<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChapterActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChapterActivities
     * const chapterActivities = await prisma.chapterActivity.findMany()
     * 
     * // Get first 10 ChapterActivities
     * const chapterActivities = await prisma.chapterActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterActivityWithIdOnly = await prisma.chapterActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterActivityFindManyArgs>(args?: SelectSubset<T, ChapterActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChapterActivity.
     * @param {ChapterActivityCreateArgs} args - Arguments to create a ChapterActivity.
     * @example
     * // Create one ChapterActivity
     * const ChapterActivity = await prisma.chapterActivity.create({
     *   data: {
     *     // ... data to create a ChapterActivity
     *   }
     * })
     * 
     */
    create<T extends ChapterActivityCreateArgs>(args: SelectSubset<T, ChapterActivityCreateArgs<ExtArgs>>): Prisma__ChapterActivityClient<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChapterActivities.
     * @param {ChapterActivityCreateManyArgs} args - Arguments to create many ChapterActivities.
     * @example
     * // Create many ChapterActivities
     * const chapterActivity = await prisma.chapterActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterActivityCreateManyArgs>(args?: SelectSubset<T, ChapterActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChapterActivities and returns the data saved in the database.
     * @param {ChapterActivityCreateManyAndReturnArgs} args - Arguments to create many ChapterActivities.
     * @example
     * // Create many ChapterActivities
     * const chapterActivity = await prisma.chapterActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChapterActivities and only return the `id`
     * const chapterActivityWithIdOnly = await prisma.chapterActivity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChapterActivity.
     * @param {ChapterActivityDeleteArgs} args - Arguments to delete one ChapterActivity.
     * @example
     * // Delete one ChapterActivity
     * const ChapterActivity = await prisma.chapterActivity.delete({
     *   where: {
     *     // ... filter to delete one ChapterActivity
     *   }
     * })
     * 
     */
    delete<T extends ChapterActivityDeleteArgs>(args: SelectSubset<T, ChapterActivityDeleteArgs<ExtArgs>>): Prisma__ChapterActivityClient<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChapterActivity.
     * @param {ChapterActivityUpdateArgs} args - Arguments to update one ChapterActivity.
     * @example
     * // Update one ChapterActivity
     * const chapterActivity = await prisma.chapterActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterActivityUpdateArgs>(args: SelectSubset<T, ChapterActivityUpdateArgs<ExtArgs>>): Prisma__ChapterActivityClient<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChapterActivities.
     * @param {ChapterActivityDeleteManyArgs} args - Arguments to filter ChapterActivities to delete.
     * @example
     * // Delete a few ChapterActivities
     * const { count } = await prisma.chapterActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterActivityDeleteManyArgs>(args?: SelectSubset<T, ChapterActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChapterActivities
     * const chapterActivity = await prisma.chapterActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterActivityUpdateManyArgs>(args: SelectSubset<T, ChapterActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChapterActivity.
     * @param {ChapterActivityUpsertArgs} args - Arguments to update or create a ChapterActivity.
     * @example
     * // Update or create a ChapterActivity
     * const chapterActivity = await prisma.chapterActivity.upsert({
     *   create: {
     *     // ... data to create a ChapterActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChapterActivity we want to update
     *   }
     * })
     */
    upsert<T extends ChapterActivityUpsertArgs>(args: SelectSubset<T, ChapterActivityUpsertArgs<ExtArgs>>): Prisma__ChapterActivityClient<$Result.GetResult<Prisma.$ChapterActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChapterActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterActivityCountArgs} args - Arguments to filter ChapterActivities to count.
     * @example
     * // Count the number of ChapterActivities
     * const count = await prisma.chapterActivity.count({
     *   where: {
     *     // ... the filter for the ChapterActivities we want to count
     *   }
     * })
    **/
    count<T extends ChapterActivityCountArgs>(
      args?: Subset<T, ChapterActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChapterActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterActivityAggregateArgs>(args: Subset<T, ChapterActivityAggregateArgs>): Prisma.PrismaPromise<GetChapterActivityAggregateType<T>>

    /**
     * Group by ChapterActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterActivityGroupByArgs['orderBy'] }
        : { orderBy?: ChapterActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChapterActivity model
   */
  readonly fields: ChapterActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChapterActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    actor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChapterActivity model
   */ 
  interface ChapterActivityFieldRefs {
    readonly id: FieldRef<"ChapterActivity", 'String'>
    readonly chapterId: FieldRef<"ChapterActivity", 'String'>
    readonly actorId: FieldRef<"ChapterActivity", 'String'>
    readonly activityType: FieldRef<"ChapterActivity", 'ActivityType'>
    readonly metadata: FieldRef<"ChapterActivity", 'Json'>
    readonly summary: FieldRef<"ChapterActivity", 'String'>
    readonly createdAt: FieldRef<"ChapterActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChapterActivity findUnique
   */
  export type ChapterActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    /**
     * Filter, which ChapterActivity to fetch.
     */
    where: ChapterActivityWhereUniqueInput
  }

  /**
   * ChapterActivity findUniqueOrThrow
   */
  export type ChapterActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    /**
     * Filter, which ChapterActivity to fetch.
     */
    where: ChapterActivityWhereUniqueInput
  }

  /**
   * ChapterActivity findFirst
   */
  export type ChapterActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    /**
     * Filter, which ChapterActivity to fetch.
     */
    where?: ChapterActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterActivities to fetch.
     */
    orderBy?: ChapterActivityOrderByWithRelationInput | ChapterActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterActivities.
     */
    cursor?: ChapterActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterActivities.
     */
    distinct?: ChapterActivityScalarFieldEnum | ChapterActivityScalarFieldEnum[]
  }

  /**
   * ChapterActivity findFirstOrThrow
   */
  export type ChapterActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    /**
     * Filter, which ChapterActivity to fetch.
     */
    where?: ChapterActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterActivities to fetch.
     */
    orderBy?: ChapterActivityOrderByWithRelationInput | ChapterActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterActivities.
     */
    cursor?: ChapterActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterActivities.
     */
    distinct?: ChapterActivityScalarFieldEnum | ChapterActivityScalarFieldEnum[]
  }

  /**
   * ChapterActivity findMany
   */
  export type ChapterActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    /**
     * Filter, which ChapterActivities to fetch.
     */
    where?: ChapterActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterActivities to fetch.
     */
    orderBy?: ChapterActivityOrderByWithRelationInput | ChapterActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChapterActivities.
     */
    cursor?: ChapterActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterActivities.
     */
    skip?: number
    distinct?: ChapterActivityScalarFieldEnum | ChapterActivityScalarFieldEnum[]
  }

  /**
   * ChapterActivity create
   */
  export type ChapterActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a ChapterActivity.
     */
    data: XOR<ChapterActivityCreateInput, ChapterActivityUncheckedCreateInput>
  }

  /**
   * ChapterActivity createMany
   */
  export type ChapterActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChapterActivities.
     */
    data: ChapterActivityCreateManyInput | ChapterActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChapterActivity createManyAndReturn
   */
  export type ChapterActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChapterActivities.
     */
    data: ChapterActivityCreateManyInput | ChapterActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterActivity update
   */
  export type ChapterActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a ChapterActivity.
     */
    data: XOR<ChapterActivityUpdateInput, ChapterActivityUncheckedUpdateInput>
    /**
     * Choose, which ChapterActivity to update.
     */
    where: ChapterActivityWhereUniqueInput
  }

  /**
   * ChapterActivity updateMany
   */
  export type ChapterActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChapterActivities.
     */
    data: XOR<ChapterActivityUpdateManyMutationInput, ChapterActivityUncheckedUpdateManyInput>
    /**
     * Filter which ChapterActivities to update
     */
    where?: ChapterActivityWhereInput
  }

  /**
   * ChapterActivity upsert
   */
  export type ChapterActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the ChapterActivity to update in case it exists.
     */
    where: ChapterActivityWhereUniqueInput
    /**
     * In case the ChapterActivity found by the `where` argument doesn't exist, create a new ChapterActivity with this data.
     */
    create: XOR<ChapterActivityCreateInput, ChapterActivityUncheckedCreateInput>
    /**
     * In case the ChapterActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterActivityUpdateInput, ChapterActivityUncheckedUpdateInput>
  }

  /**
   * ChapterActivity delete
   */
  export type ChapterActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
    /**
     * Filter which ChapterActivity to delete.
     */
    where: ChapterActivityWhereUniqueInput
  }

  /**
   * ChapterActivity deleteMany
   */
  export type ChapterActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterActivities to delete
     */
    where?: ChapterActivityWhereInput
  }

  /**
   * ChapterActivity without action
   */
  export type ChapterActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterActivity
     */
    select?: ChapterActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterActivityInclude<ExtArgs> | null
  }


  /**
   * Model EditorProfile
   */

  export type AggregateEditorProfile = {
    _count: EditorProfileCountAggregateOutputType | null
    _avg: EditorProfileAvgAggregateOutputType | null
    _sum: EditorProfileSumAggregateOutputType | null
    _min: EditorProfileMinAggregateOutputType | null
    _max: EditorProfileMaxAggregateOutputType | null
  }

  export type EditorProfileAvgAggregateOutputType = {
    maxConcurrent: number | null
    completedProjects: number | null
    averageRating: number | null
    totalReviews: number | null
  }

  export type EditorProfileSumAggregateOutputType = {
    maxConcurrent: number | null
    completedProjects: number | null
    averageRating: number | null
    totalReviews: number | null
  }

  export type EditorProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    bio: string | null
    portfolioUrl: string | null
    availability: $Enums.EditorAvailability | null
    maxConcurrent: number | null
    completedProjects: number | null
    averageRating: number | null
    totalReviews: number | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EditorProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    bio: string | null
    portfolioUrl: string | null
    availability: $Enums.EditorAvailability | null
    maxConcurrent: number | null
    completedProjects: number | null
    averageRating: number | null
    totalReviews: number | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EditorProfileCountAggregateOutputType = {
    id: number
    userId: number
    displayName: number
    bio: number
    portfolioUrl: number
    specialtyGenres: number
    languages: number
    availability: number
    maxConcurrent: number
    completedProjects: number
    averageRating: number
    totalReviews: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EditorProfileAvgAggregateInputType = {
    maxConcurrent?: true
    completedProjects?: true
    averageRating?: true
    totalReviews?: true
  }

  export type EditorProfileSumAggregateInputType = {
    maxConcurrent?: true
    completedProjects?: true
    averageRating?: true
    totalReviews?: true
  }

  export type EditorProfileMinAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    portfolioUrl?: true
    availability?: true
    maxConcurrent?: true
    completedProjects?: true
    averageRating?: true
    totalReviews?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EditorProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    portfolioUrl?: true
    availability?: true
    maxConcurrent?: true
    completedProjects?: true
    averageRating?: true
    totalReviews?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EditorProfileCountAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    portfolioUrl?: true
    specialtyGenres?: true
    languages?: true
    availability?: true
    maxConcurrent?: true
    completedProjects?: true
    averageRating?: true
    totalReviews?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EditorProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EditorProfile to aggregate.
     */
    where?: EditorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditorProfiles to fetch.
     */
    orderBy?: EditorProfileOrderByWithRelationInput | EditorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EditorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EditorProfiles
    **/
    _count?: true | EditorProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EditorProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EditorProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EditorProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EditorProfileMaxAggregateInputType
  }

  export type GetEditorProfileAggregateType<T extends EditorProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateEditorProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEditorProfile[P]>
      : GetScalarType<T[P], AggregateEditorProfile[P]>
  }




  export type EditorProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EditorProfileWhereInput
    orderBy?: EditorProfileOrderByWithAggregationInput | EditorProfileOrderByWithAggregationInput[]
    by: EditorProfileScalarFieldEnum[] | EditorProfileScalarFieldEnum
    having?: EditorProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EditorProfileCountAggregateInputType | true
    _avg?: EditorProfileAvgAggregateInputType
    _sum?: EditorProfileSumAggregateInputType
    _min?: EditorProfileMinAggregateInputType
    _max?: EditorProfileMaxAggregateInputType
  }

  export type EditorProfileGroupByOutputType = {
    id: string
    userId: string
    displayName: string | null
    bio: string | null
    portfolioUrl: string | null
    specialtyGenres: string[]
    languages: string[]
    availability: $Enums.EditorAvailability
    maxConcurrent: number
    completedProjects: number
    averageRating: number | null
    totalReviews: number
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: EditorProfileCountAggregateOutputType | null
    _avg: EditorProfileAvgAggregateOutputType | null
    _sum: EditorProfileSumAggregateOutputType | null
    _min: EditorProfileMinAggregateOutputType | null
    _max: EditorProfileMaxAggregateOutputType | null
  }

  type GetEditorProfileGroupByPayload<T extends EditorProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EditorProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EditorProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EditorProfileGroupByOutputType[P]>
            : GetScalarType<T[P], EditorProfileGroupByOutputType[P]>
        }
      >
    >


  export type EditorProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    portfolioUrl?: boolean
    specialtyGenres?: boolean
    languages?: boolean
    availability?: boolean
    maxConcurrent?: boolean
    completedProjects?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    portfolioItems?: boolean | EditorProfile$portfolioItemsArgs<ExtArgs>
    applications?: boolean | EditorProfile$applicationsArgs<ExtArgs>
    reviews?: boolean | EditorProfile$reviewsArgs<ExtArgs>
    _count?: boolean | EditorProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["editorProfile"]>

  export type EditorProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    portfolioUrl?: boolean
    specialtyGenres?: boolean
    languages?: boolean
    availability?: boolean
    maxConcurrent?: boolean
    completedProjects?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["editorProfile"]>

  export type EditorProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    portfolioUrl?: boolean
    specialtyGenres?: boolean
    languages?: boolean
    availability?: boolean
    maxConcurrent?: boolean
    completedProjects?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EditorProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    portfolioItems?: boolean | EditorProfile$portfolioItemsArgs<ExtArgs>
    applications?: boolean | EditorProfile$applicationsArgs<ExtArgs>
    reviews?: boolean | EditorProfile$reviewsArgs<ExtArgs>
    _count?: boolean | EditorProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EditorProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EditorProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EditorProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      portfolioItems: Prisma.$PortfolioItemPayload<ExtArgs>[]
      applications: Prisma.$ProjectApplicationPayload<ExtArgs>[]
      reviews: Prisma.$EditorReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      displayName: string | null
      bio: string | null
      portfolioUrl: string | null
      specialtyGenres: string[]
      languages: string[]
      availability: $Enums.EditorAvailability
      maxConcurrent: number
      completedProjects: number
      averageRating: number | null
      totalReviews: number
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["editorProfile"]>
    composites: {}
  }

  type EditorProfileGetPayload<S extends boolean | null | undefined | EditorProfileDefaultArgs> = $Result.GetResult<Prisma.$EditorProfilePayload, S>

  type EditorProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EditorProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EditorProfileCountAggregateInputType | true
    }

  export interface EditorProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EditorProfile'], meta: { name: 'EditorProfile' } }
    /**
     * Find zero or one EditorProfile that matches the filter.
     * @param {EditorProfileFindUniqueArgs} args - Arguments to find a EditorProfile
     * @example
     * // Get one EditorProfile
     * const editorProfile = await prisma.editorProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EditorProfileFindUniqueArgs>(args: SelectSubset<T, EditorProfileFindUniqueArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EditorProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EditorProfileFindUniqueOrThrowArgs} args - Arguments to find a EditorProfile
     * @example
     * // Get one EditorProfile
     * const editorProfile = await prisma.editorProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EditorProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, EditorProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EditorProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorProfileFindFirstArgs} args - Arguments to find a EditorProfile
     * @example
     * // Get one EditorProfile
     * const editorProfile = await prisma.editorProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EditorProfileFindFirstArgs>(args?: SelectSubset<T, EditorProfileFindFirstArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EditorProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorProfileFindFirstOrThrowArgs} args - Arguments to find a EditorProfile
     * @example
     * // Get one EditorProfile
     * const editorProfile = await prisma.editorProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EditorProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, EditorProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EditorProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EditorProfiles
     * const editorProfiles = await prisma.editorProfile.findMany()
     * 
     * // Get first 10 EditorProfiles
     * const editorProfiles = await prisma.editorProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const editorProfileWithIdOnly = await prisma.editorProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EditorProfileFindManyArgs>(args?: SelectSubset<T, EditorProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EditorProfile.
     * @param {EditorProfileCreateArgs} args - Arguments to create a EditorProfile.
     * @example
     * // Create one EditorProfile
     * const EditorProfile = await prisma.editorProfile.create({
     *   data: {
     *     // ... data to create a EditorProfile
     *   }
     * })
     * 
     */
    create<T extends EditorProfileCreateArgs>(args: SelectSubset<T, EditorProfileCreateArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EditorProfiles.
     * @param {EditorProfileCreateManyArgs} args - Arguments to create many EditorProfiles.
     * @example
     * // Create many EditorProfiles
     * const editorProfile = await prisma.editorProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EditorProfileCreateManyArgs>(args?: SelectSubset<T, EditorProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EditorProfiles and returns the data saved in the database.
     * @param {EditorProfileCreateManyAndReturnArgs} args - Arguments to create many EditorProfiles.
     * @example
     * // Create many EditorProfiles
     * const editorProfile = await prisma.editorProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EditorProfiles and only return the `id`
     * const editorProfileWithIdOnly = await prisma.editorProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EditorProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, EditorProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EditorProfile.
     * @param {EditorProfileDeleteArgs} args - Arguments to delete one EditorProfile.
     * @example
     * // Delete one EditorProfile
     * const EditorProfile = await prisma.editorProfile.delete({
     *   where: {
     *     // ... filter to delete one EditorProfile
     *   }
     * })
     * 
     */
    delete<T extends EditorProfileDeleteArgs>(args: SelectSubset<T, EditorProfileDeleteArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EditorProfile.
     * @param {EditorProfileUpdateArgs} args - Arguments to update one EditorProfile.
     * @example
     * // Update one EditorProfile
     * const editorProfile = await prisma.editorProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EditorProfileUpdateArgs>(args: SelectSubset<T, EditorProfileUpdateArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EditorProfiles.
     * @param {EditorProfileDeleteManyArgs} args - Arguments to filter EditorProfiles to delete.
     * @example
     * // Delete a few EditorProfiles
     * const { count } = await prisma.editorProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EditorProfileDeleteManyArgs>(args?: SelectSubset<T, EditorProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EditorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EditorProfiles
     * const editorProfile = await prisma.editorProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EditorProfileUpdateManyArgs>(args: SelectSubset<T, EditorProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EditorProfile.
     * @param {EditorProfileUpsertArgs} args - Arguments to update or create a EditorProfile.
     * @example
     * // Update or create a EditorProfile
     * const editorProfile = await prisma.editorProfile.upsert({
     *   create: {
     *     // ... data to create a EditorProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EditorProfile we want to update
     *   }
     * })
     */
    upsert<T extends EditorProfileUpsertArgs>(args: SelectSubset<T, EditorProfileUpsertArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EditorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorProfileCountArgs} args - Arguments to filter EditorProfiles to count.
     * @example
     * // Count the number of EditorProfiles
     * const count = await prisma.editorProfile.count({
     *   where: {
     *     // ... the filter for the EditorProfiles we want to count
     *   }
     * })
    **/
    count<T extends EditorProfileCountArgs>(
      args?: Subset<T, EditorProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EditorProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EditorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EditorProfileAggregateArgs>(args: Subset<T, EditorProfileAggregateArgs>): Prisma.PrismaPromise<GetEditorProfileAggregateType<T>>

    /**
     * Group by EditorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EditorProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EditorProfileGroupByArgs['orderBy'] }
        : { orderBy?: EditorProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EditorProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEditorProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EditorProfile model
   */
  readonly fields: EditorProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EditorProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EditorProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    portfolioItems<T extends EditorProfile$portfolioItemsArgs<ExtArgs> = {}>(args?: Subset<T, EditorProfile$portfolioItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findMany"> | Null>
    applications<T extends EditorProfile$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, EditorProfile$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends EditorProfile$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, EditorProfile$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EditorProfile model
   */ 
  interface EditorProfileFieldRefs {
    readonly id: FieldRef<"EditorProfile", 'String'>
    readonly userId: FieldRef<"EditorProfile", 'String'>
    readonly displayName: FieldRef<"EditorProfile", 'String'>
    readonly bio: FieldRef<"EditorProfile", 'String'>
    readonly portfolioUrl: FieldRef<"EditorProfile", 'String'>
    readonly specialtyGenres: FieldRef<"EditorProfile", 'String[]'>
    readonly languages: FieldRef<"EditorProfile", 'String[]'>
    readonly availability: FieldRef<"EditorProfile", 'EditorAvailability'>
    readonly maxConcurrent: FieldRef<"EditorProfile", 'Int'>
    readonly completedProjects: FieldRef<"EditorProfile", 'Int'>
    readonly averageRating: FieldRef<"EditorProfile", 'Float'>
    readonly totalReviews: FieldRef<"EditorProfile", 'Int'>
    readonly isVerified: FieldRef<"EditorProfile", 'Boolean'>
    readonly createdAt: FieldRef<"EditorProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"EditorProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EditorProfile findUnique
   */
  export type EditorProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
    /**
     * Filter, which EditorProfile to fetch.
     */
    where: EditorProfileWhereUniqueInput
  }

  /**
   * EditorProfile findUniqueOrThrow
   */
  export type EditorProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
    /**
     * Filter, which EditorProfile to fetch.
     */
    where: EditorProfileWhereUniqueInput
  }

  /**
   * EditorProfile findFirst
   */
  export type EditorProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
    /**
     * Filter, which EditorProfile to fetch.
     */
    where?: EditorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditorProfiles to fetch.
     */
    orderBy?: EditorProfileOrderByWithRelationInput | EditorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EditorProfiles.
     */
    cursor?: EditorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EditorProfiles.
     */
    distinct?: EditorProfileScalarFieldEnum | EditorProfileScalarFieldEnum[]
  }

  /**
   * EditorProfile findFirstOrThrow
   */
  export type EditorProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
    /**
     * Filter, which EditorProfile to fetch.
     */
    where?: EditorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditorProfiles to fetch.
     */
    orderBy?: EditorProfileOrderByWithRelationInput | EditorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EditorProfiles.
     */
    cursor?: EditorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EditorProfiles.
     */
    distinct?: EditorProfileScalarFieldEnum | EditorProfileScalarFieldEnum[]
  }

  /**
   * EditorProfile findMany
   */
  export type EditorProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
    /**
     * Filter, which EditorProfiles to fetch.
     */
    where?: EditorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditorProfiles to fetch.
     */
    orderBy?: EditorProfileOrderByWithRelationInput | EditorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EditorProfiles.
     */
    cursor?: EditorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditorProfiles.
     */
    skip?: number
    distinct?: EditorProfileScalarFieldEnum | EditorProfileScalarFieldEnum[]
  }

  /**
   * EditorProfile create
   */
  export type EditorProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a EditorProfile.
     */
    data: XOR<EditorProfileCreateInput, EditorProfileUncheckedCreateInput>
  }

  /**
   * EditorProfile createMany
   */
  export type EditorProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EditorProfiles.
     */
    data: EditorProfileCreateManyInput | EditorProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EditorProfile createManyAndReturn
   */
  export type EditorProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EditorProfiles.
     */
    data: EditorProfileCreateManyInput | EditorProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EditorProfile update
   */
  export type EditorProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a EditorProfile.
     */
    data: XOR<EditorProfileUpdateInput, EditorProfileUncheckedUpdateInput>
    /**
     * Choose, which EditorProfile to update.
     */
    where: EditorProfileWhereUniqueInput
  }

  /**
   * EditorProfile updateMany
   */
  export type EditorProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EditorProfiles.
     */
    data: XOR<EditorProfileUpdateManyMutationInput, EditorProfileUncheckedUpdateManyInput>
    /**
     * Filter which EditorProfiles to update
     */
    where?: EditorProfileWhereInput
  }

  /**
   * EditorProfile upsert
   */
  export type EditorProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the EditorProfile to update in case it exists.
     */
    where: EditorProfileWhereUniqueInput
    /**
     * In case the EditorProfile found by the `where` argument doesn't exist, create a new EditorProfile with this data.
     */
    create: XOR<EditorProfileCreateInput, EditorProfileUncheckedCreateInput>
    /**
     * In case the EditorProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EditorProfileUpdateInput, EditorProfileUncheckedUpdateInput>
  }

  /**
   * EditorProfile delete
   */
  export type EditorProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
    /**
     * Filter which EditorProfile to delete.
     */
    where: EditorProfileWhereUniqueInput
  }

  /**
   * EditorProfile deleteMany
   */
  export type EditorProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EditorProfiles to delete
     */
    where?: EditorProfileWhereInput
  }

  /**
   * EditorProfile.portfolioItems
   */
  export type EditorProfile$portfolioItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    where?: PortfolioItemWhereInput
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    cursor?: PortfolioItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }

  /**
   * EditorProfile.applications
   */
  export type EditorProfile$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    where?: ProjectApplicationWhereInput
    orderBy?: ProjectApplicationOrderByWithRelationInput | ProjectApplicationOrderByWithRelationInput[]
    cursor?: ProjectApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectApplicationScalarFieldEnum | ProjectApplicationScalarFieldEnum[]
  }

  /**
   * EditorProfile.reviews
   */
  export type EditorProfile$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    where?: EditorReviewWhereInput
    orderBy?: EditorReviewOrderByWithRelationInput | EditorReviewOrderByWithRelationInput[]
    cursor?: EditorReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EditorReviewScalarFieldEnum | EditorReviewScalarFieldEnum[]
  }

  /**
   * EditorProfile without action
   */
  export type EditorProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorProfile
     */
    select?: EditorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorProfileInclude<ExtArgs> | null
  }


  /**
   * Model PortfolioItem
   */

  export type AggregatePortfolioItem = {
    _count: PortfolioItemCountAggregateOutputType | null
    _avg: PortfolioItemAvgAggregateOutputType | null
    _sum: PortfolioItemSumAggregateOutputType | null
    _min: PortfolioItemMinAggregateOutputType | null
    _max: PortfolioItemMaxAggregateOutputType | null
  }

  export type PortfolioItemAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type PortfolioItemSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type PortfolioItemMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    title: string | null
    description: string | null
    genre: string | null
    sampleText: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type PortfolioItemMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    title: string | null
    description: string | null
    genre: string | null
    sampleText: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type PortfolioItemCountAggregateOutputType = {
    id: number
    profileId: number
    title: number
    description: number
    genre: number
    sampleText: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type PortfolioItemAvgAggregateInputType = {
    sortOrder?: true
  }

  export type PortfolioItemSumAggregateInputType = {
    sortOrder?: true
  }

  export type PortfolioItemMinAggregateInputType = {
    id?: true
    profileId?: true
    title?: true
    description?: true
    genre?: true
    sampleText?: true
    sortOrder?: true
    createdAt?: true
  }

  export type PortfolioItemMaxAggregateInputType = {
    id?: true
    profileId?: true
    title?: true
    description?: true
    genre?: true
    sampleText?: true
    sortOrder?: true
    createdAt?: true
  }

  export type PortfolioItemCountAggregateInputType = {
    id?: true
    profileId?: true
    title?: true
    description?: true
    genre?: true
    sampleText?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type PortfolioItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioItem to aggregate.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioItems
    **/
    _count?: true | PortfolioItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortfolioItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortfolioItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioItemMaxAggregateInputType
  }

  export type GetPortfolioItemAggregateType<T extends PortfolioItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioItem[P]>
      : GetScalarType<T[P], AggregatePortfolioItem[P]>
  }




  export type PortfolioItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioItemWhereInput
    orderBy?: PortfolioItemOrderByWithAggregationInput | PortfolioItemOrderByWithAggregationInput[]
    by: PortfolioItemScalarFieldEnum[] | PortfolioItemScalarFieldEnum
    having?: PortfolioItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioItemCountAggregateInputType | true
    _avg?: PortfolioItemAvgAggregateInputType
    _sum?: PortfolioItemSumAggregateInputType
    _min?: PortfolioItemMinAggregateInputType
    _max?: PortfolioItemMaxAggregateInputType
  }

  export type PortfolioItemGroupByOutputType = {
    id: string
    profileId: string
    title: string
    description: string | null
    genre: string | null
    sampleText: string | null
    sortOrder: number
    createdAt: Date
    _count: PortfolioItemCountAggregateOutputType | null
    _avg: PortfolioItemAvgAggregateOutputType | null
    _sum: PortfolioItemSumAggregateOutputType | null
    _min: PortfolioItemMinAggregateOutputType | null
    _max: PortfolioItemMaxAggregateOutputType | null
  }

  type GetPortfolioItemGroupByPayload<T extends PortfolioItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioItemGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioItemGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    title?: boolean
    description?: boolean
    genre?: boolean
    sampleText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    profile?: boolean | EditorProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioItem"]>

  export type PortfolioItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    title?: boolean
    description?: boolean
    genre?: boolean
    sampleText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    profile?: boolean | EditorProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioItem"]>

  export type PortfolioItemSelectScalar = {
    id?: boolean
    profileId?: boolean
    title?: boolean
    description?: boolean
    genre?: boolean
    sampleText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type PortfolioItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | EditorProfileDefaultArgs<ExtArgs>
  }
  export type PortfolioItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | EditorProfileDefaultArgs<ExtArgs>
  }

  export type $PortfolioItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioItem"
    objects: {
      profile: Prisma.$EditorProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      title: string
      description: string | null
      genre: string | null
      sampleText: string | null
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["portfolioItem"]>
    composites: {}
  }

  type PortfolioItemGetPayload<S extends boolean | null | undefined | PortfolioItemDefaultArgs> = $Result.GetResult<Prisma.$PortfolioItemPayload, S>

  type PortfolioItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PortfolioItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PortfolioItemCountAggregateInputType | true
    }

  export interface PortfolioItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioItem'], meta: { name: 'PortfolioItem' } }
    /**
     * Find zero or one PortfolioItem that matches the filter.
     * @param {PortfolioItemFindUniqueArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioItemFindUniqueArgs>(args: SelectSubset<T, PortfolioItemFindUniqueArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PortfolioItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PortfolioItemFindUniqueOrThrowArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PortfolioItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemFindFirstArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioItemFindFirstArgs>(args?: SelectSubset<T, PortfolioItemFindFirstArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PortfolioItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemFindFirstOrThrowArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PortfolioItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioItems
     * const portfolioItems = await prisma.portfolioItem.findMany()
     * 
     * // Get first 10 PortfolioItems
     * const portfolioItems = await prisma.portfolioItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioItemWithIdOnly = await prisma.portfolioItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioItemFindManyArgs>(args?: SelectSubset<T, PortfolioItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PortfolioItem.
     * @param {PortfolioItemCreateArgs} args - Arguments to create a PortfolioItem.
     * @example
     * // Create one PortfolioItem
     * const PortfolioItem = await prisma.portfolioItem.create({
     *   data: {
     *     // ... data to create a PortfolioItem
     *   }
     * })
     * 
     */
    create<T extends PortfolioItemCreateArgs>(args: SelectSubset<T, PortfolioItemCreateArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PortfolioItems.
     * @param {PortfolioItemCreateManyArgs} args - Arguments to create many PortfolioItems.
     * @example
     * // Create many PortfolioItems
     * const portfolioItem = await prisma.portfolioItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioItemCreateManyArgs>(args?: SelectSubset<T, PortfolioItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioItems and returns the data saved in the database.
     * @param {PortfolioItemCreateManyAndReturnArgs} args - Arguments to create many PortfolioItems.
     * @example
     * // Create many PortfolioItems
     * const portfolioItem = await prisma.portfolioItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortfolioItems and only return the `id`
     * const portfolioItemWithIdOnly = await prisma.portfolioItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PortfolioItem.
     * @param {PortfolioItemDeleteArgs} args - Arguments to delete one PortfolioItem.
     * @example
     * // Delete one PortfolioItem
     * const PortfolioItem = await prisma.portfolioItem.delete({
     *   where: {
     *     // ... filter to delete one PortfolioItem
     *   }
     * })
     * 
     */
    delete<T extends PortfolioItemDeleteArgs>(args: SelectSubset<T, PortfolioItemDeleteArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PortfolioItem.
     * @param {PortfolioItemUpdateArgs} args - Arguments to update one PortfolioItem.
     * @example
     * // Update one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioItemUpdateArgs>(args: SelectSubset<T, PortfolioItemUpdateArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PortfolioItems.
     * @param {PortfolioItemDeleteManyArgs} args - Arguments to filter PortfolioItems to delete.
     * @example
     * // Delete a few PortfolioItems
     * const { count } = await prisma.portfolioItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioItemDeleteManyArgs>(args?: SelectSubset<T, PortfolioItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioItems
     * const portfolioItem = await prisma.portfolioItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioItemUpdateManyArgs>(args: SelectSubset<T, PortfolioItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PortfolioItem.
     * @param {PortfolioItemUpsertArgs} args - Arguments to update or create a PortfolioItem.
     * @example
     * // Update or create a PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.upsert({
     *   create: {
     *     // ... data to create a PortfolioItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioItem we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioItemUpsertArgs>(args: SelectSubset<T, PortfolioItemUpsertArgs<ExtArgs>>): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PortfolioItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemCountArgs} args - Arguments to filter PortfolioItems to count.
     * @example
     * // Count the number of PortfolioItems
     * const count = await prisma.portfolioItem.count({
     *   where: {
     *     // ... the filter for the PortfolioItems we want to count
     *   }
     * })
    **/
    count<T extends PortfolioItemCountArgs>(
      args?: Subset<T, PortfolioItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioItemAggregateArgs>(args: Subset<T, PortfolioItemAggregateArgs>): Prisma.PrismaPromise<GetPortfolioItemAggregateType<T>>

    /**
     * Group by PortfolioItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioItemGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioItem model
   */
  readonly fields: PortfolioItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends EditorProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EditorProfileDefaultArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortfolioItem model
   */ 
  interface PortfolioItemFieldRefs {
    readonly id: FieldRef<"PortfolioItem", 'String'>
    readonly profileId: FieldRef<"PortfolioItem", 'String'>
    readonly title: FieldRef<"PortfolioItem", 'String'>
    readonly description: FieldRef<"PortfolioItem", 'String'>
    readonly genre: FieldRef<"PortfolioItem", 'String'>
    readonly sampleText: FieldRef<"PortfolioItem", 'String'>
    readonly sortOrder: FieldRef<"PortfolioItem", 'Int'>
    readonly createdAt: FieldRef<"PortfolioItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PortfolioItem findUnique
   */
  export type PortfolioItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where: PortfolioItemWhereUniqueInput
  }

  /**
   * PortfolioItem findUniqueOrThrow
   */
  export type PortfolioItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where: PortfolioItemWhereUniqueInput
  }

  /**
   * PortfolioItem findFirst
   */
  export type PortfolioItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioItems.
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioItems.
     */
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }

  /**
   * PortfolioItem findFirstOrThrow
   */
  export type PortfolioItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioItems.
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioItems.
     */
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }

  /**
   * PortfolioItem findMany
   */
  export type PortfolioItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItems to fetch.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioItems.
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }

  /**
   * PortfolioItem create
   */
  export type PortfolioItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioItem.
     */
    data: XOR<PortfolioItemCreateInput, PortfolioItemUncheckedCreateInput>
  }

  /**
   * PortfolioItem createMany
   */
  export type PortfolioItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioItems.
     */
    data: PortfolioItemCreateManyInput | PortfolioItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioItem createManyAndReturn
   */
  export type PortfolioItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PortfolioItems.
     */
    data: PortfolioItemCreateManyInput | PortfolioItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioItem update
   */
  export type PortfolioItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioItem.
     */
    data: XOR<PortfolioItemUpdateInput, PortfolioItemUncheckedUpdateInput>
    /**
     * Choose, which PortfolioItem to update.
     */
    where: PortfolioItemWhereUniqueInput
  }

  /**
   * PortfolioItem updateMany
   */
  export type PortfolioItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioItems.
     */
    data: XOR<PortfolioItemUpdateManyMutationInput, PortfolioItemUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioItems to update
     */
    where?: PortfolioItemWhereInput
  }

  /**
   * PortfolioItem upsert
   */
  export type PortfolioItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioItem to update in case it exists.
     */
    where: PortfolioItemWhereUniqueInput
    /**
     * In case the PortfolioItem found by the `where` argument doesn't exist, create a new PortfolioItem with this data.
     */
    create: XOR<PortfolioItemCreateInput, PortfolioItemUncheckedCreateInput>
    /**
     * In case the PortfolioItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioItemUpdateInput, PortfolioItemUncheckedUpdateInput>
  }

  /**
   * PortfolioItem delete
   */
  export type PortfolioItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter which PortfolioItem to delete.
     */
    where: PortfolioItemWhereUniqueInput
  }

  /**
   * PortfolioItem deleteMany
   */
  export type PortfolioItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioItems to delete
     */
    where?: PortfolioItemWhereInput
  }

  /**
   * PortfolioItem without action
   */
  export type PortfolioItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioItemInclude<ExtArgs> | null
  }


  /**
   * Model ProjectListing
   */

  export type AggregateProjectListing = {
    _count: ProjectListingCountAggregateOutputType | null
    _avg: ProjectListingAvgAggregateOutputType | null
    _sum: ProjectListingSumAggregateOutputType | null
    _min: ProjectListingMinAggregateOutputType | null
    _max: ProjectListingMaxAggregateOutputType | null
  }

  export type ProjectListingAvgAggregateOutputType = {
    budgetMin: number | null
    budgetMax: number | null
    chapterStart: number | null
    chapterEnd: number | null
    viewCount: number | null
    applicationCount: number | null
  }

  export type ProjectListingSumAggregateOutputType = {
    budgetMin: number | null
    budgetMax: number | null
    chapterStart: number | null
    chapterEnd: number | null
    viewCount: number | null
    applicationCount: number | null
  }

  export type ProjectListingMinAggregateOutputType = {
    id: string | null
    workId: string | null
    authorId: string | null
    title: string | null
    description: string | null
    requirements: string | null
    status: $Enums.ProjectListingStatus | null
    budgetMin: number | null
    budgetMax: number | null
    deadline: Date | null
    chapterStart: number | null
    chapterEnd: number | null
    viewCount: number | null
    applicationCount: number | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectListingMaxAggregateOutputType = {
    id: string | null
    workId: string | null
    authorId: string | null
    title: string | null
    description: string | null
    requirements: string | null
    status: $Enums.ProjectListingStatus | null
    budgetMin: number | null
    budgetMax: number | null
    deadline: Date | null
    chapterStart: number | null
    chapterEnd: number | null
    viewCount: number | null
    applicationCount: number | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectListingCountAggregateOutputType = {
    id: number
    workId: number
    authorId: number
    title: number
    description: number
    requirements: number
    status: number
    budgetMin: number
    budgetMax: number
    deadline: number
    chapterStart: number
    chapterEnd: number
    viewCount: number
    applicationCount: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectListingAvgAggregateInputType = {
    budgetMin?: true
    budgetMax?: true
    chapterStart?: true
    chapterEnd?: true
    viewCount?: true
    applicationCount?: true
  }

  export type ProjectListingSumAggregateInputType = {
    budgetMin?: true
    budgetMax?: true
    chapterStart?: true
    chapterEnd?: true
    viewCount?: true
    applicationCount?: true
  }

  export type ProjectListingMinAggregateInputType = {
    id?: true
    workId?: true
    authorId?: true
    title?: true
    description?: true
    requirements?: true
    status?: true
    budgetMin?: true
    budgetMax?: true
    deadline?: true
    chapterStart?: true
    chapterEnd?: true
    viewCount?: true
    applicationCount?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectListingMaxAggregateInputType = {
    id?: true
    workId?: true
    authorId?: true
    title?: true
    description?: true
    requirements?: true
    status?: true
    budgetMin?: true
    budgetMax?: true
    deadline?: true
    chapterStart?: true
    chapterEnd?: true
    viewCount?: true
    applicationCount?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectListingCountAggregateInputType = {
    id?: true
    workId?: true
    authorId?: true
    title?: true
    description?: true
    requirements?: true
    status?: true
    budgetMin?: true
    budgetMax?: true
    deadline?: true
    chapterStart?: true
    chapterEnd?: true
    viewCount?: true
    applicationCount?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectListing to aggregate.
     */
    where?: ProjectListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectListings to fetch.
     */
    orderBy?: ProjectListingOrderByWithRelationInput | ProjectListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectListings
    **/
    _count?: true | ProjectListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectListingMaxAggregateInputType
  }

  export type GetProjectListingAggregateType<T extends ProjectListingAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectListing[P]>
      : GetScalarType<T[P], AggregateProjectListing[P]>
  }




  export type ProjectListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectListingWhereInput
    orderBy?: ProjectListingOrderByWithAggregationInput | ProjectListingOrderByWithAggregationInput[]
    by: ProjectListingScalarFieldEnum[] | ProjectListingScalarFieldEnum
    having?: ProjectListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectListingCountAggregateInputType | true
    _avg?: ProjectListingAvgAggregateInputType
    _sum?: ProjectListingSumAggregateInputType
    _min?: ProjectListingMinAggregateInputType
    _max?: ProjectListingMaxAggregateInputType
  }

  export type ProjectListingGroupByOutputType = {
    id: string
    workId: string
    authorId: string
    title: string
    description: string
    requirements: string | null
    status: $Enums.ProjectListingStatus
    budgetMin: number | null
    budgetMax: number | null
    deadline: Date | null
    chapterStart: number | null
    chapterEnd: number | null
    viewCount: number
    applicationCount: number
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectListingCountAggregateOutputType | null
    _avg: ProjectListingAvgAggregateOutputType | null
    _sum: ProjectListingSumAggregateOutputType | null
    _min: ProjectListingMinAggregateOutputType | null
    _max: ProjectListingMaxAggregateOutputType | null
  }

  type GetProjectListingGroupByPayload<T extends ProjectListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectListingGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectListingGroupByOutputType[P]>
        }
      >
    >


  export type ProjectListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workId?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    status?: boolean
    budgetMin?: boolean
    budgetMax?: boolean
    deadline?: boolean
    chapterStart?: boolean
    chapterEnd?: boolean
    viewCount?: boolean
    applicationCount?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    work?: boolean | WorkDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    applications?: boolean | ProjectListing$applicationsArgs<ExtArgs>
    contract?: boolean | ProjectListing$contractArgs<ExtArgs>
    _count?: boolean | ProjectListingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectListing"]>

  export type ProjectListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workId?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    status?: boolean
    budgetMin?: boolean
    budgetMax?: boolean
    deadline?: boolean
    chapterStart?: boolean
    chapterEnd?: boolean
    viewCount?: boolean
    applicationCount?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    work?: boolean | WorkDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectListing"]>

  export type ProjectListingSelectScalar = {
    id?: boolean
    workId?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    status?: boolean
    budgetMin?: boolean
    budgetMax?: boolean
    deadline?: boolean
    chapterStart?: boolean
    chapterEnd?: boolean
    viewCount?: boolean
    applicationCount?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work?: boolean | WorkDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    applications?: boolean | ProjectListing$applicationsArgs<ExtArgs>
    contract?: boolean | ProjectListing$contractArgs<ExtArgs>
    _count?: boolean | ProjectListingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work?: boolean | WorkDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectListing"
    objects: {
      work: Prisma.$WorkPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      applications: Prisma.$ProjectApplicationPayload<ExtArgs>[]
      contract: Prisma.$ProjectContractPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workId: string
      authorId: string
      title: string
      description: string
      requirements: string | null
      status: $Enums.ProjectListingStatus
      budgetMin: number | null
      budgetMax: number | null
      deadline: Date | null
      chapterStart: number | null
      chapterEnd: number | null
      viewCount: number
      applicationCount: number
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectListing"]>
    composites: {}
  }

  type ProjectListingGetPayload<S extends boolean | null | undefined | ProjectListingDefaultArgs> = $Result.GetResult<Prisma.$ProjectListingPayload, S>

  type ProjectListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectListingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectListingCountAggregateInputType | true
    }

  export interface ProjectListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectListing'], meta: { name: 'ProjectListing' } }
    /**
     * Find zero or one ProjectListing that matches the filter.
     * @param {ProjectListingFindUniqueArgs} args - Arguments to find a ProjectListing
     * @example
     * // Get one ProjectListing
     * const projectListing = await prisma.projectListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectListingFindUniqueArgs>(args: SelectSubset<T, ProjectListingFindUniqueArgs<ExtArgs>>): Prisma__ProjectListingClient<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectListing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectListingFindUniqueOrThrowArgs} args - Arguments to find a ProjectListing
     * @example
     * // Get one ProjectListing
     * const projectListing = await prisma.projectListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectListingFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectListingClient<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectListingFindFirstArgs} args - Arguments to find a ProjectListing
     * @example
     * // Get one ProjectListing
     * const projectListing = await prisma.projectListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectListingFindFirstArgs>(args?: SelectSubset<T, ProjectListingFindFirstArgs<ExtArgs>>): Prisma__ProjectListingClient<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectListingFindFirstOrThrowArgs} args - Arguments to find a ProjectListing
     * @example
     * // Get one ProjectListing
     * const projectListing = await prisma.projectListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectListingFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectListingClient<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectListings
     * const projectListings = await prisma.projectListing.findMany()
     * 
     * // Get first 10 ProjectListings
     * const projectListings = await prisma.projectListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectListingWithIdOnly = await prisma.projectListing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectListingFindManyArgs>(args?: SelectSubset<T, ProjectListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectListing.
     * @param {ProjectListingCreateArgs} args - Arguments to create a ProjectListing.
     * @example
     * // Create one ProjectListing
     * const ProjectListing = await prisma.projectListing.create({
     *   data: {
     *     // ... data to create a ProjectListing
     *   }
     * })
     * 
     */
    create<T extends ProjectListingCreateArgs>(args: SelectSubset<T, ProjectListingCreateArgs<ExtArgs>>): Prisma__ProjectListingClient<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectListings.
     * @param {ProjectListingCreateManyArgs} args - Arguments to create many ProjectListings.
     * @example
     * // Create many ProjectListings
     * const projectListing = await prisma.projectListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectListingCreateManyArgs>(args?: SelectSubset<T, ProjectListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectListings and returns the data saved in the database.
     * @param {ProjectListingCreateManyAndReturnArgs} args - Arguments to create many ProjectListings.
     * @example
     * // Create many ProjectListings
     * const projectListing = await prisma.projectListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectListings and only return the `id`
     * const projectListingWithIdOnly = await prisma.projectListing.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectListingCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectListing.
     * @param {ProjectListingDeleteArgs} args - Arguments to delete one ProjectListing.
     * @example
     * // Delete one ProjectListing
     * const ProjectListing = await prisma.projectListing.delete({
     *   where: {
     *     // ... filter to delete one ProjectListing
     *   }
     * })
     * 
     */
    delete<T extends ProjectListingDeleteArgs>(args: SelectSubset<T, ProjectListingDeleteArgs<ExtArgs>>): Prisma__ProjectListingClient<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectListing.
     * @param {ProjectListingUpdateArgs} args - Arguments to update one ProjectListing.
     * @example
     * // Update one ProjectListing
     * const projectListing = await prisma.projectListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectListingUpdateArgs>(args: SelectSubset<T, ProjectListingUpdateArgs<ExtArgs>>): Prisma__ProjectListingClient<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectListings.
     * @param {ProjectListingDeleteManyArgs} args - Arguments to filter ProjectListings to delete.
     * @example
     * // Delete a few ProjectListings
     * const { count } = await prisma.projectListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectListingDeleteManyArgs>(args?: SelectSubset<T, ProjectListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectListings
     * const projectListing = await prisma.projectListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectListingUpdateManyArgs>(args: SelectSubset<T, ProjectListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectListing.
     * @param {ProjectListingUpsertArgs} args - Arguments to update or create a ProjectListing.
     * @example
     * // Update or create a ProjectListing
     * const projectListing = await prisma.projectListing.upsert({
     *   create: {
     *     // ... data to create a ProjectListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectListing we want to update
     *   }
     * })
     */
    upsert<T extends ProjectListingUpsertArgs>(args: SelectSubset<T, ProjectListingUpsertArgs<ExtArgs>>): Prisma__ProjectListingClient<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectListingCountArgs} args - Arguments to filter ProjectListings to count.
     * @example
     * // Count the number of ProjectListings
     * const count = await prisma.projectListing.count({
     *   where: {
     *     // ... the filter for the ProjectListings we want to count
     *   }
     * })
    **/
    count<T extends ProjectListingCountArgs>(
      args?: Subset<T, ProjectListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectListingAggregateArgs>(args: Subset<T, ProjectListingAggregateArgs>): Prisma.PrismaPromise<GetProjectListingAggregateType<T>>

    /**
     * Group by ProjectListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectListingGroupByArgs['orderBy'] }
        : { orderBy?: ProjectListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectListing model
   */
  readonly fields: ProjectListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work<T extends WorkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkDefaultArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    applications<T extends ProjectListing$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, ProjectListing$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    contract<T extends ProjectListing$contractArgs<ExtArgs> = {}>(args?: Subset<T, ProjectListing$contractArgs<ExtArgs>>): Prisma__ProjectContractClient<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectListing model
   */ 
  interface ProjectListingFieldRefs {
    readonly id: FieldRef<"ProjectListing", 'String'>
    readonly workId: FieldRef<"ProjectListing", 'String'>
    readonly authorId: FieldRef<"ProjectListing", 'String'>
    readonly title: FieldRef<"ProjectListing", 'String'>
    readonly description: FieldRef<"ProjectListing", 'String'>
    readonly requirements: FieldRef<"ProjectListing", 'String'>
    readonly status: FieldRef<"ProjectListing", 'ProjectListingStatus'>
    readonly budgetMin: FieldRef<"ProjectListing", 'Int'>
    readonly budgetMax: FieldRef<"ProjectListing", 'Int'>
    readonly deadline: FieldRef<"ProjectListing", 'DateTime'>
    readonly chapterStart: FieldRef<"ProjectListing", 'Int'>
    readonly chapterEnd: FieldRef<"ProjectListing", 'Int'>
    readonly viewCount: FieldRef<"ProjectListing", 'Int'>
    readonly applicationCount: FieldRef<"ProjectListing", 'Int'>
    readonly publishedAt: FieldRef<"ProjectListing", 'DateTime'>
    readonly createdAt: FieldRef<"ProjectListing", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectListing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectListing findUnique
   */
  export type ProjectListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    /**
     * Filter, which ProjectListing to fetch.
     */
    where: ProjectListingWhereUniqueInput
  }

  /**
   * ProjectListing findUniqueOrThrow
   */
  export type ProjectListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    /**
     * Filter, which ProjectListing to fetch.
     */
    where: ProjectListingWhereUniqueInput
  }

  /**
   * ProjectListing findFirst
   */
  export type ProjectListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    /**
     * Filter, which ProjectListing to fetch.
     */
    where?: ProjectListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectListings to fetch.
     */
    orderBy?: ProjectListingOrderByWithRelationInput | ProjectListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectListings.
     */
    cursor?: ProjectListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectListings.
     */
    distinct?: ProjectListingScalarFieldEnum | ProjectListingScalarFieldEnum[]
  }

  /**
   * ProjectListing findFirstOrThrow
   */
  export type ProjectListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    /**
     * Filter, which ProjectListing to fetch.
     */
    where?: ProjectListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectListings to fetch.
     */
    orderBy?: ProjectListingOrderByWithRelationInput | ProjectListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectListings.
     */
    cursor?: ProjectListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectListings.
     */
    distinct?: ProjectListingScalarFieldEnum | ProjectListingScalarFieldEnum[]
  }

  /**
   * ProjectListing findMany
   */
  export type ProjectListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    /**
     * Filter, which ProjectListings to fetch.
     */
    where?: ProjectListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectListings to fetch.
     */
    orderBy?: ProjectListingOrderByWithRelationInput | ProjectListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectListings.
     */
    cursor?: ProjectListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectListings.
     */
    skip?: number
    distinct?: ProjectListingScalarFieldEnum | ProjectListingScalarFieldEnum[]
  }

  /**
   * ProjectListing create
   */
  export type ProjectListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectListing.
     */
    data: XOR<ProjectListingCreateInput, ProjectListingUncheckedCreateInput>
  }

  /**
   * ProjectListing createMany
   */
  export type ProjectListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectListings.
     */
    data: ProjectListingCreateManyInput | ProjectListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectListing createManyAndReturn
   */
  export type ProjectListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectListings.
     */
    data: ProjectListingCreateManyInput | ProjectListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectListing update
   */
  export type ProjectListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectListing.
     */
    data: XOR<ProjectListingUpdateInput, ProjectListingUncheckedUpdateInput>
    /**
     * Choose, which ProjectListing to update.
     */
    where: ProjectListingWhereUniqueInput
  }

  /**
   * ProjectListing updateMany
   */
  export type ProjectListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectListings.
     */
    data: XOR<ProjectListingUpdateManyMutationInput, ProjectListingUncheckedUpdateManyInput>
    /**
     * Filter which ProjectListings to update
     */
    where?: ProjectListingWhereInput
  }

  /**
   * ProjectListing upsert
   */
  export type ProjectListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectListing to update in case it exists.
     */
    where: ProjectListingWhereUniqueInput
    /**
     * In case the ProjectListing found by the `where` argument doesn't exist, create a new ProjectListing with this data.
     */
    create: XOR<ProjectListingCreateInput, ProjectListingUncheckedCreateInput>
    /**
     * In case the ProjectListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectListingUpdateInput, ProjectListingUncheckedUpdateInput>
  }

  /**
   * ProjectListing delete
   */
  export type ProjectListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
    /**
     * Filter which ProjectListing to delete.
     */
    where: ProjectListingWhereUniqueInput
  }

  /**
   * ProjectListing deleteMany
   */
  export type ProjectListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectListings to delete
     */
    where?: ProjectListingWhereInput
  }

  /**
   * ProjectListing.applications
   */
  export type ProjectListing$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    where?: ProjectApplicationWhereInput
    orderBy?: ProjectApplicationOrderByWithRelationInput | ProjectApplicationOrderByWithRelationInput[]
    cursor?: ProjectApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectApplicationScalarFieldEnum | ProjectApplicationScalarFieldEnum[]
  }

  /**
   * ProjectListing.contract
   */
  export type ProjectListing$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    where?: ProjectContractWhereInput
  }

  /**
   * ProjectListing without action
   */
  export type ProjectListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectListing
     */
    select?: ProjectListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectListingInclude<ExtArgs> | null
  }


  /**
   * Model ProjectApplication
   */

  export type AggregateProjectApplication = {
    _count: ProjectApplicationCountAggregateOutputType | null
    _avg: ProjectApplicationAvgAggregateOutputType | null
    _sum: ProjectApplicationSumAggregateOutputType | null
    _min: ProjectApplicationMinAggregateOutputType | null
    _max: ProjectApplicationMaxAggregateOutputType | null
  }

  export type ProjectApplicationAvgAggregateOutputType = {
    priceQuote: number | null
    estimatedDays: number | null
  }

  export type ProjectApplicationSumAggregateOutputType = {
    priceQuote: number | null
    estimatedDays: number | null
  }

  export type ProjectApplicationMinAggregateOutputType = {
    id: string | null
    listingId: string | null
    editorProfileId: string | null
    proposalMessage: string | null
    priceQuote: number | null
    estimatedDays: number | null
    status: $Enums.ApplicationStatus | null
    authorNote: string | null
    submittedAt: Date | null
    reviewedAt: Date | null
  }

  export type ProjectApplicationMaxAggregateOutputType = {
    id: string | null
    listingId: string | null
    editorProfileId: string | null
    proposalMessage: string | null
    priceQuote: number | null
    estimatedDays: number | null
    status: $Enums.ApplicationStatus | null
    authorNote: string | null
    submittedAt: Date | null
    reviewedAt: Date | null
  }

  export type ProjectApplicationCountAggregateOutputType = {
    id: number
    listingId: number
    editorProfileId: number
    proposalMessage: number
    priceQuote: number
    estimatedDays: number
    status: number
    authorNote: number
    submittedAt: number
    reviewedAt: number
    _all: number
  }


  export type ProjectApplicationAvgAggregateInputType = {
    priceQuote?: true
    estimatedDays?: true
  }

  export type ProjectApplicationSumAggregateInputType = {
    priceQuote?: true
    estimatedDays?: true
  }

  export type ProjectApplicationMinAggregateInputType = {
    id?: true
    listingId?: true
    editorProfileId?: true
    proposalMessage?: true
    priceQuote?: true
    estimatedDays?: true
    status?: true
    authorNote?: true
    submittedAt?: true
    reviewedAt?: true
  }

  export type ProjectApplicationMaxAggregateInputType = {
    id?: true
    listingId?: true
    editorProfileId?: true
    proposalMessage?: true
    priceQuote?: true
    estimatedDays?: true
    status?: true
    authorNote?: true
    submittedAt?: true
    reviewedAt?: true
  }

  export type ProjectApplicationCountAggregateInputType = {
    id?: true
    listingId?: true
    editorProfileId?: true
    proposalMessage?: true
    priceQuote?: true
    estimatedDays?: true
    status?: true
    authorNote?: true
    submittedAt?: true
    reviewedAt?: true
    _all?: true
  }

  export type ProjectApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectApplication to aggregate.
     */
    where?: ProjectApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectApplications to fetch.
     */
    orderBy?: ProjectApplicationOrderByWithRelationInput | ProjectApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectApplications
    **/
    _count?: true | ProjectApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectApplicationMaxAggregateInputType
  }

  export type GetProjectApplicationAggregateType<T extends ProjectApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectApplication[P]>
      : GetScalarType<T[P], AggregateProjectApplication[P]>
  }




  export type ProjectApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectApplicationWhereInput
    orderBy?: ProjectApplicationOrderByWithAggregationInput | ProjectApplicationOrderByWithAggregationInput[]
    by: ProjectApplicationScalarFieldEnum[] | ProjectApplicationScalarFieldEnum
    having?: ProjectApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectApplicationCountAggregateInputType | true
    _avg?: ProjectApplicationAvgAggregateInputType
    _sum?: ProjectApplicationSumAggregateInputType
    _min?: ProjectApplicationMinAggregateInputType
    _max?: ProjectApplicationMaxAggregateInputType
  }

  export type ProjectApplicationGroupByOutputType = {
    id: string
    listingId: string
    editorProfileId: string
    proposalMessage: string
    priceQuote: number | null
    estimatedDays: number | null
    status: $Enums.ApplicationStatus
    authorNote: string | null
    submittedAt: Date
    reviewedAt: Date | null
    _count: ProjectApplicationCountAggregateOutputType | null
    _avg: ProjectApplicationAvgAggregateOutputType | null
    _sum: ProjectApplicationSumAggregateOutputType | null
    _min: ProjectApplicationMinAggregateOutputType | null
    _max: ProjectApplicationMaxAggregateOutputType | null
  }

  type GetProjectApplicationGroupByPayload<T extends ProjectApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ProjectApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    editorProfileId?: boolean
    proposalMessage?: boolean
    priceQuote?: boolean
    estimatedDays?: boolean
    status?: boolean
    authorNote?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    listing?: boolean | ProjectListingDefaultArgs<ExtArgs>
    editorProfile?: boolean | EditorProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectApplication"]>

  export type ProjectApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    editorProfileId?: boolean
    proposalMessage?: boolean
    priceQuote?: boolean
    estimatedDays?: boolean
    status?: boolean
    authorNote?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    listing?: boolean | ProjectListingDefaultArgs<ExtArgs>
    editorProfile?: boolean | EditorProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectApplication"]>

  export type ProjectApplicationSelectScalar = {
    id?: boolean
    listingId?: boolean
    editorProfileId?: boolean
    proposalMessage?: boolean
    priceQuote?: boolean
    estimatedDays?: boolean
    status?: boolean
    authorNote?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
  }

  export type ProjectApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | ProjectListingDefaultArgs<ExtArgs>
    editorProfile?: boolean | EditorProfileDefaultArgs<ExtArgs>
  }
  export type ProjectApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | ProjectListingDefaultArgs<ExtArgs>
    editorProfile?: boolean | EditorProfileDefaultArgs<ExtArgs>
  }

  export type $ProjectApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectApplication"
    objects: {
      listing: Prisma.$ProjectListingPayload<ExtArgs>
      editorProfile: Prisma.$EditorProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listingId: string
      editorProfileId: string
      proposalMessage: string
      priceQuote: number | null
      estimatedDays: number | null
      status: $Enums.ApplicationStatus
      authorNote: string | null
      submittedAt: Date
      reviewedAt: Date | null
    }, ExtArgs["result"]["projectApplication"]>
    composites: {}
  }

  type ProjectApplicationGetPayload<S extends boolean | null | undefined | ProjectApplicationDefaultArgs> = $Result.GetResult<Prisma.$ProjectApplicationPayload, S>

  type ProjectApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectApplicationCountAggregateInputType | true
    }

  export interface ProjectApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectApplication'], meta: { name: 'ProjectApplication' } }
    /**
     * Find zero or one ProjectApplication that matches the filter.
     * @param {ProjectApplicationFindUniqueArgs} args - Arguments to find a ProjectApplication
     * @example
     * // Get one ProjectApplication
     * const projectApplication = await prisma.projectApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectApplicationFindUniqueArgs>(args: SelectSubset<T, ProjectApplicationFindUniqueArgs<ExtArgs>>): Prisma__ProjectApplicationClient<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectApplicationFindUniqueOrThrowArgs} args - Arguments to find a ProjectApplication
     * @example
     * // Get one ProjectApplication
     * const projectApplication = await prisma.projectApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectApplicationClient<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectApplicationFindFirstArgs} args - Arguments to find a ProjectApplication
     * @example
     * // Get one ProjectApplication
     * const projectApplication = await prisma.projectApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectApplicationFindFirstArgs>(args?: SelectSubset<T, ProjectApplicationFindFirstArgs<ExtArgs>>): Prisma__ProjectApplicationClient<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectApplicationFindFirstOrThrowArgs} args - Arguments to find a ProjectApplication
     * @example
     * // Get one ProjectApplication
     * const projectApplication = await prisma.projectApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectApplicationClient<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectApplications
     * const projectApplications = await prisma.projectApplication.findMany()
     * 
     * // Get first 10 ProjectApplications
     * const projectApplications = await prisma.projectApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectApplicationWithIdOnly = await prisma.projectApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectApplicationFindManyArgs>(args?: SelectSubset<T, ProjectApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectApplication.
     * @param {ProjectApplicationCreateArgs} args - Arguments to create a ProjectApplication.
     * @example
     * // Create one ProjectApplication
     * const ProjectApplication = await prisma.projectApplication.create({
     *   data: {
     *     // ... data to create a ProjectApplication
     *   }
     * })
     * 
     */
    create<T extends ProjectApplicationCreateArgs>(args: SelectSubset<T, ProjectApplicationCreateArgs<ExtArgs>>): Prisma__ProjectApplicationClient<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectApplications.
     * @param {ProjectApplicationCreateManyArgs} args - Arguments to create many ProjectApplications.
     * @example
     * // Create many ProjectApplications
     * const projectApplication = await prisma.projectApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectApplicationCreateManyArgs>(args?: SelectSubset<T, ProjectApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectApplications and returns the data saved in the database.
     * @param {ProjectApplicationCreateManyAndReturnArgs} args - Arguments to create many ProjectApplications.
     * @example
     * // Create many ProjectApplications
     * const projectApplication = await prisma.projectApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectApplications and only return the `id`
     * const projectApplicationWithIdOnly = await prisma.projectApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectApplication.
     * @param {ProjectApplicationDeleteArgs} args - Arguments to delete one ProjectApplication.
     * @example
     * // Delete one ProjectApplication
     * const ProjectApplication = await prisma.projectApplication.delete({
     *   where: {
     *     // ... filter to delete one ProjectApplication
     *   }
     * })
     * 
     */
    delete<T extends ProjectApplicationDeleteArgs>(args: SelectSubset<T, ProjectApplicationDeleteArgs<ExtArgs>>): Prisma__ProjectApplicationClient<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectApplication.
     * @param {ProjectApplicationUpdateArgs} args - Arguments to update one ProjectApplication.
     * @example
     * // Update one ProjectApplication
     * const projectApplication = await prisma.projectApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectApplicationUpdateArgs>(args: SelectSubset<T, ProjectApplicationUpdateArgs<ExtArgs>>): Prisma__ProjectApplicationClient<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectApplications.
     * @param {ProjectApplicationDeleteManyArgs} args - Arguments to filter ProjectApplications to delete.
     * @example
     * // Delete a few ProjectApplications
     * const { count } = await prisma.projectApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectApplicationDeleteManyArgs>(args?: SelectSubset<T, ProjectApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectApplications
     * const projectApplication = await prisma.projectApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectApplicationUpdateManyArgs>(args: SelectSubset<T, ProjectApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectApplication.
     * @param {ProjectApplicationUpsertArgs} args - Arguments to update or create a ProjectApplication.
     * @example
     * // Update or create a ProjectApplication
     * const projectApplication = await prisma.projectApplication.upsert({
     *   create: {
     *     // ... data to create a ProjectApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectApplication we want to update
     *   }
     * })
     */
    upsert<T extends ProjectApplicationUpsertArgs>(args: SelectSubset<T, ProjectApplicationUpsertArgs<ExtArgs>>): Prisma__ProjectApplicationClient<$Result.GetResult<Prisma.$ProjectApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectApplicationCountArgs} args - Arguments to filter ProjectApplications to count.
     * @example
     * // Count the number of ProjectApplications
     * const count = await prisma.projectApplication.count({
     *   where: {
     *     // ... the filter for the ProjectApplications we want to count
     *   }
     * })
    **/
    count<T extends ProjectApplicationCountArgs>(
      args?: Subset<T, ProjectApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectApplicationAggregateArgs>(args: Subset<T, ProjectApplicationAggregateArgs>): Prisma.PrismaPromise<GetProjectApplicationAggregateType<T>>

    /**
     * Group by ProjectApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ProjectApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectApplication model
   */
  readonly fields: ProjectApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listing<T extends ProjectListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectListingDefaultArgs<ExtArgs>>): Prisma__ProjectListingClient<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    editorProfile<T extends EditorProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EditorProfileDefaultArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectApplication model
   */ 
  interface ProjectApplicationFieldRefs {
    readonly id: FieldRef<"ProjectApplication", 'String'>
    readonly listingId: FieldRef<"ProjectApplication", 'String'>
    readonly editorProfileId: FieldRef<"ProjectApplication", 'String'>
    readonly proposalMessage: FieldRef<"ProjectApplication", 'String'>
    readonly priceQuote: FieldRef<"ProjectApplication", 'Int'>
    readonly estimatedDays: FieldRef<"ProjectApplication", 'Int'>
    readonly status: FieldRef<"ProjectApplication", 'ApplicationStatus'>
    readonly authorNote: FieldRef<"ProjectApplication", 'String'>
    readonly submittedAt: FieldRef<"ProjectApplication", 'DateTime'>
    readonly reviewedAt: FieldRef<"ProjectApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectApplication findUnique
   */
  export type ProjectApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectApplication to fetch.
     */
    where: ProjectApplicationWhereUniqueInput
  }

  /**
   * ProjectApplication findUniqueOrThrow
   */
  export type ProjectApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectApplication to fetch.
     */
    where: ProjectApplicationWhereUniqueInput
  }

  /**
   * ProjectApplication findFirst
   */
  export type ProjectApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectApplication to fetch.
     */
    where?: ProjectApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectApplications to fetch.
     */
    orderBy?: ProjectApplicationOrderByWithRelationInput | ProjectApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectApplications.
     */
    cursor?: ProjectApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectApplications.
     */
    distinct?: ProjectApplicationScalarFieldEnum | ProjectApplicationScalarFieldEnum[]
  }

  /**
   * ProjectApplication findFirstOrThrow
   */
  export type ProjectApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectApplication to fetch.
     */
    where?: ProjectApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectApplications to fetch.
     */
    orderBy?: ProjectApplicationOrderByWithRelationInput | ProjectApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectApplications.
     */
    cursor?: ProjectApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectApplications.
     */
    distinct?: ProjectApplicationScalarFieldEnum | ProjectApplicationScalarFieldEnum[]
  }

  /**
   * ProjectApplication findMany
   */
  export type ProjectApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectApplications to fetch.
     */
    where?: ProjectApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectApplications to fetch.
     */
    orderBy?: ProjectApplicationOrderByWithRelationInput | ProjectApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectApplications.
     */
    cursor?: ProjectApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectApplications.
     */
    skip?: number
    distinct?: ProjectApplicationScalarFieldEnum | ProjectApplicationScalarFieldEnum[]
  }

  /**
   * ProjectApplication create
   */
  export type ProjectApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectApplication.
     */
    data: XOR<ProjectApplicationCreateInput, ProjectApplicationUncheckedCreateInput>
  }

  /**
   * ProjectApplication createMany
   */
  export type ProjectApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectApplications.
     */
    data: ProjectApplicationCreateManyInput | ProjectApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectApplication createManyAndReturn
   */
  export type ProjectApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectApplications.
     */
    data: ProjectApplicationCreateManyInput | ProjectApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectApplication update
   */
  export type ProjectApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectApplication.
     */
    data: XOR<ProjectApplicationUpdateInput, ProjectApplicationUncheckedUpdateInput>
    /**
     * Choose, which ProjectApplication to update.
     */
    where: ProjectApplicationWhereUniqueInput
  }

  /**
   * ProjectApplication updateMany
   */
  export type ProjectApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectApplications.
     */
    data: XOR<ProjectApplicationUpdateManyMutationInput, ProjectApplicationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectApplications to update
     */
    where?: ProjectApplicationWhereInput
  }

  /**
   * ProjectApplication upsert
   */
  export type ProjectApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectApplication to update in case it exists.
     */
    where: ProjectApplicationWhereUniqueInput
    /**
     * In case the ProjectApplication found by the `where` argument doesn't exist, create a new ProjectApplication with this data.
     */
    create: XOR<ProjectApplicationCreateInput, ProjectApplicationUncheckedCreateInput>
    /**
     * In case the ProjectApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectApplicationUpdateInput, ProjectApplicationUncheckedUpdateInput>
  }

  /**
   * ProjectApplication delete
   */
  export type ProjectApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
    /**
     * Filter which ProjectApplication to delete.
     */
    where: ProjectApplicationWhereUniqueInput
  }

  /**
   * ProjectApplication deleteMany
   */
  export type ProjectApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectApplications to delete
     */
    where?: ProjectApplicationWhereInput
  }

  /**
   * ProjectApplication without action
   */
  export type ProjectApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectApplication
     */
    select?: ProjectApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectApplicationInclude<ExtArgs> | null
  }


  /**
   * Model ProjectContract
   */

  export type AggregateProjectContract = {
    _count: ProjectContractCountAggregateOutputType | null
    _avg: ProjectContractAvgAggregateOutputType | null
    _sum: ProjectContractSumAggregateOutputType | null
    _min: ProjectContractMinAggregateOutputType | null
    _max: ProjectContractMaxAggregateOutputType | null
  }

  export type ProjectContractAvgAggregateOutputType = {
    totalAmount: number | null
    chapterStart: number | null
    chapterEnd: number | null
  }

  export type ProjectContractSumAggregateOutputType = {
    totalAmount: number | null
    chapterStart: number | null
    chapterEnd: number | null
  }

  export type ProjectContractMinAggregateOutputType = {
    id: string | null
    listingId: string | null
    workId: string | null
    authorId: string | null
    editorId: string | null
    totalAmount: number | null
    startDate: Date | null
    expectedEndDate: Date | null
    chapterStart: number | null
    chapterEnd: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ProjectContractMaxAggregateOutputType = {
    id: string | null
    listingId: string | null
    workId: string | null
    authorId: string | null
    editorId: string | null
    totalAmount: number | null
    startDate: Date | null
    expectedEndDate: Date | null
    chapterStart: number | null
    chapterEnd: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ProjectContractCountAggregateOutputType = {
    id: number
    listingId: number
    workId: number
    authorId: number
    editorId: number
    totalAmount: number
    startDate: number
    expectedEndDate: number
    chapterStart: number
    chapterEnd: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ProjectContractAvgAggregateInputType = {
    totalAmount?: true
    chapterStart?: true
    chapterEnd?: true
  }

  export type ProjectContractSumAggregateInputType = {
    totalAmount?: true
    chapterStart?: true
    chapterEnd?: true
  }

  export type ProjectContractMinAggregateInputType = {
    id?: true
    listingId?: true
    workId?: true
    authorId?: true
    editorId?: true
    totalAmount?: true
    startDate?: true
    expectedEndDate?: true
    chapterStart?: true
    chapterEnd?: true
    isActive?: true
    createdAt?: true
  }

  export type ProjectContractMaxAggregateInputType = {
    id?: true
    listingId?: true
    workId?: true
    authorId?: true
    editorId?: true
    totalAmount?: true
    startDate?: true
    expectedEndDate?: true
    chapterStart?: true
    chapterEnd?: true
    isActive?: true
    createdAt?: true
  }

  export type ProjectContractCountAggregateInputType = {
    id?: true
    listingId?: true
    workId?: true
    authorId?: true
    editorId?: true
    totalAmount?: true
    startDate?: true
    expectedEndDate?: true
    chapterStart?: true
    chapterEnd?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectContract to aggregate.
     */
    where?: ProjectContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectContracts to fetch.
     */
    orderBy?: ProjectContractOrderByWithRelationInput | ProjectContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectContracts
    **/
    _count?: true | ProjectContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectContractMaxAggregateInputType
  }

  export type GetProjectContractAggregateType<T extends ProjectContractAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectContract[P]>
      : GetScalarType<T[P], AggregateProjectContract[P]>
  }




  export type ProjectContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectContractWhereInput
    orderBy?: ProjectContractOrderByWithAggregationInput | ProjectContractOrderByWithAggregationInput[]
    by: ProjectContractScalarFieldEnum[] | ProjectContractScalarFieldEnum
    having?: ProjectContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectContractCountAggregateInputType | true
    _avg?: ProjectContractAvgAggregateInputType
    _sum?: ProjectContractSumAggregateInputType
    _min?: ProjectContractMinAggregateInputType
    _max?: ProjectContractMaxAggregateInputType
  }

  export type ProjectContractGroupByOutputType = {
    id: string
    listingId: string
    workId: string
    authorId: string
    editorId: string
    totalAmount: number | null
    startDate: Date
    expectedEndDate: Date | null
    chapterStart: number
    chapterEnd: number | null
    isActive: boolean
    createdAt: Date
    _count: ProjectContractCountAggregateOutputType | null
    _avg: ProjectContractAvgAggregateOutputType | null
    _sum: ProjectContractSumAggregateOutputType | null
    _min: ProjectContractMinAggregateOutputType | null
    _max: ProjectContractMaxAggregateOutputType | null
  }

  type GetProjectContractGroupByPayload<T extends ProjectContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectContractGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectContractGroupByOutputType[P]>
        }
      >
    >


  export type ProjectContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    workId?: boolean
    authorId?: boolean
    editorId?: boolean
    totalAmount?: boolean
    startDate?: boolean
    expectedEndDate?: boolean
    chapterStart?: boolean
    chapterEnd?: boolean
    isActive?: boolean
    createdAt?: boolean
    listing?: boolean | ProjectListingDefaultArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    editor?: boolean | UserDefaultArgs<ExtArgs>
    revisionRequests?: boolean | ProjectContract$revisionRequestsArgs<ExtArgs>
    _count?: boolean | ProjectContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectContract"]>

  export type ProjectContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    workId?: boolean
    authorId?: boolean
    editorId?: boolean
    totalAmount?: boolean
    startDate?: boolean
    expectedEndDate?: boolean
    chapterStart?: boolean
    chapterEnd?: boolean
    isActive?: boolean
    createdAt?: boolean
    listing?: boolean | ProjectListingDefaultArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    editor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectContract"]>

  export type ProjectContractSelectScalar = {
    id?: boolean
    listingId?: boolean
    workId?: boolean
    authorId?: boolean
    editorId?: boolean
    totalAmount?: boolean
    startDate?: boolean
    expectedEndDate?: boolean
    chapterStart?: boolean
    chapterEnd?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ProjectContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | ProjectListingDefaultArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    editor?: boolean | UserDefaultArgs<ExtArgs>
    revisionRequests?: boolean | ProjectContract$revisionRequestsArgs<ExtArgs>
    _count?: boolean | ProjectContractCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | ProjectListingDefaultArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    editor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectContract"
    objects: {
      listing: Prisma.$ProjectListingPayload<ExtArgs>
      work: Prisma.$WorkPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      editor: Prisma.$UserPayload<ExtArgs>
      revisionRequests: Prisma.$ChapterRevisionRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listingId: string
      workId: string
      authorId: string
      editorId: string
      totalAmount: number | null
      startDate: Date
      expectedEndDate: Date | null
      chapterStart: number
      chapterEnd: number | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["projectContract"]>
    composites: {}
  }

  type ProjectContractGetPayload<S extends boolean | null | undefined | ProjectContractDefaultArgs> = $Result.GetResult<Prisma.$ProjectContractPayload, S>

  type ProjectContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectContractCountAggregateInputType | true
    }

  export interface ProjectContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectContract'], meta: { name: 'ProjectContract' } }
    /**
     * Find zero or one ProjectContract that matches the filter.
     * @param {ProjectContractFindUniqueArgs} args - Arguments to find a ProjectContract
     * @example
     * // Get one ProjectContract
     * const projectContract = await prisma.projectContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectContractFindUniqueArgs>(args: SelectSubset<T, ProjectContractFindUniqueArgs<ExtArgs>>): Prisma__ProjectContractClient<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectContract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectContractFindUniqueOrThrowArgs} args - Arguments to find a ProjectContract
     * @example
     * // Get one ProjectContract
     * const projectContract = await prisma.projectContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectContractClient<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectContractFindFirstArgs} args - Arguments to find a ProjectContract
     * @example
     * // Get one ProjectContract
     * const projectContract = await prisma.projectContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectContractFindFirstArgs>(args?: SelectSubset<T, ProjectContractFindFirstArgs<ExtArgs>>): Prisma__ProjectContractClient<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectContractFindFirstOrThrowArgs} args - Arguments to find a ProjectContract
     * @example
     * // Get one ProjectContract
     * const projectContract = await prisma.projectContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectContractClient<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectContracts
     * const projectContracts = await prisma.projectContract.findMany()
     * 
     * // Get first 10 ProjectContracts
     * const projectContracts = await prisma.projectContract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectContractWithIdOnly = await prisma.projectContract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectContractFindManyArgs>(args?: SelectSubset<T, ProjectContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectContract.
     * @param {ProjectContractCreateArgs} args - Arguments to create a ProjectContract.
     * @example
     * // Create one ProjectContract
     * const ProjectContract = await prisma.projectContract.create({
     *   data: {
     *     // ... data to create a ProjectContract
     *   }
     * })
     * 
     */
    create<T extends ProjectContractCreateArgs>(args: SelectSubset<T, ProjectContractCreateArgs<ExtArgs>>): Prisma__ProjectContractClient<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectContracts.
     * @param {ProjectContractCreateManyArgs} args - Arguments to create many ProjectContracts.
     * @example
     * // Create many ProjectContracts
     * const projectContract = await prisma.projectContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectContractCreateManyArgs>(args?: SelectSubset<T, ProjectContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectContracts and returns the data saved in the database.
     * @param {ProjectContractCreateManyAndReturnArgs} args - Arguments to create many ProjectContracts.
     * @example
     * // Create many ProjectContracts
     * const projectContract = await prisma.projectContract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectContracts and only return the `id`
     * const projectContractWithIdOnly = await prisma.projectContract.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectContract.
     * @param {ProjectContractDeleteArgs} args - Arguments to delete one ProjectContract.
     * @example
     * // Delete one ProjectContract
     * const ProjectContract = await prisma.projectContract.delete({
     *   where: {
     *     // ... filter to delete one ProjectContract
     *   }
     * })
     * 
     */
    delete<T extends ProjectContractDeleteArgs>(args: SelectSubset<T, ProjectContractDeleteArgs<ExtArgs>>): Prisma__ProjectContractClient<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectContract.
     * @param {ProjectContractUpdateArgs} args - Arguments to update one ProjectContract.
     * @example
     * // Update one ProjectContract
     * const projectContract = await prisma.projectContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectContractUpdateArgs>(args: SelectSubset<T, ProjectContractUpdateArgs<ExtArgs>>): Prisma__ProjectContractClient<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectContracts.
     * @param {ProjectContractDeleteManyArgs} args - Arguments to filter ProjectContracts to delete.
     * @example
     * // Delete a few ProjectContracts
     * const { count } = await prisma.projectContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectContractDeleteManyArgs>(args?: SelectSubset<T, ProjectContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectContracts
     * const projectContract = await prisma.projectContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectContractUpdateManyArgs>(args: SelectSubset<T, ProjectContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectContract.
     * @param {ProjectContractUpsertArgs} args - Arguments to update or create a ProjectContract.
     * @example
     * // Update or create a ProjectContract
     * const projectContract = await prisma.projectContract.upsert({
     *   create: {
     *     // ... data to create a ProjectContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectContract we want to update
     *   }
     * })
     */
    upsert<T extends ProjectContractUpsertArgs>(args: SelectSubset<T, ProjectContractUpsertArgs<ExtArgs>>): Prisma__ProjectContractClient<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectContractCountArgs} args - Arguments to filter ProjectContracts to count.
     * @example
     * // Count the number of ProjectContracts
     * const count = await prisma.projectContract.count({
     *   where: {
     *     // ... the filter for the ProjectContracts we want to count
     *   }
     * })
    **/
    count<T extends ProjectContractCountArgs>(
      args?: Subset<T, ProjectContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectContractAggregateArgs>(args: Subset<T, ProjectContractAggregateArgs>): Prisma.PrismaPromise<GetProjectContractAggregateType<T>>

    /**
     * Group by ProjectContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectContractGroupByArgs['orderBy'] }
        : { orderBy?: ProjectContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectContract model
   */
  readonly fields: ProjectContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listing<T extends ProjectListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectListingDefaultArgs<ExtArgs>>): Prisma__ProjectListingClient<$Result.GetResult<Prisma.$ProjectListingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    work<T extends WorkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkDefaultArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    editor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    revisionRequests<T extends ProjectContract$revisionRequestsArgs<ExtArgs> = {}>(args?: Subset<T, ProjectContract$revisionRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectContract model
   */ 
  interface ProjectContractFieldRefs {
    readonly id: FieldRef<"ProjectContract", 'String'>
    readonly listingId: FieldRef<"ProjectContract", 'String'>
    readonly workId: FieldRef<"ProjectContract", 'String'>
    readonly authorId: FieldRef<"ProjectContract", 'String'>
    readonly editorId: FieldRef<"ProjectContract", 'String'>
    readonly totalAmount: FieldRef<"ProjectContract", 'Int'>
    readonly startDate: FieldRef<"ProjectContract", 'DateTime'>
    readonly expectedEndDate: FieldRef<"ProjectContract", 'DateTime'>
    readonly chapterStart: FieldRef<"ProjectContract", 'Int'>
    readonly chapterEnd: FieldRef<"ProjectContract", 'Int'>
    readonly isActive: FieldRef<"ProjectContract", 'Boolean'>
    readonly createdAt: FieldRef<"ProjectContract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectContract findUnique
   */
  export type ProjectContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    /**
     * Filter, which ProjectContract to fetch.
     */
    where: ProjectContractWhereUniqueInput
  }

  /**
   * ProjectContract findUniqueOrThrow
   */
  export type ProjectContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    /**
     * Filter, which ProjectContract to fetch.
     */
    where: ProjectContractWhereUniqueInput
  }

  /**
   * ProjectContract findFirst
   */
  export type ProjectContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    /**
     * Filter, which ProjectContract to fetch.
     */
    where?: ProjectContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectContracts to fetch.
     */
    orderBy?: ProjectContractOrderByWithRelationInput | ProjectContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectContracts.
     */
    cursor?: ProjectContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectContracts.
     */
    distinct?: ProjectContractScalarFieldEnum | ProjectContractScalarFieldEnum[]
  }

  /**
   * ProjectContract findFirstOrThrow
   */
  export type ProjectContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    /**
     * Filter, which ProjectContract to fetch.
     */
    where?: ProjectContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectContracts to fetch.
     */
    orderBy?: ProjectContractOrderByWithRelationInput | ProjectContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectContracts.
     */
    cursor?: ProjectContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectContracts.
     */
    distinct?: ProjectContractScalarFieldEnum | ProjectContractScalarFieldEnum[]
  }

  /**
   * ProjectContract findMany
   */
  export type ProjectContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    /**
     * Filter, which ProjectContracts to fetch.
     */
    where?: ProjectContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectContracts to fetch.
     */
    orderBy?: ProjectContractOrderByWithRelationInput | ProjectContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectContracts.
     */
    cursor?: ProjectContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectContracts.
     */
    skip?: number
    distinct?: ProjectContractScalarFieldEnum | ProjectContractScalarFieldEnum[]
  }

  /**
   * ProjectContract create
   */
  export type ProjectContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectContract.
     */
    data: XOR<ProjectContractCreateInput, ProjectContractUncheckedCreateInput>
  }

  /**
   * ProjectContract createMany
   */
  export type ProjectContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectContracts.
     */
    data: ProjectContractCreateManyInput | ProjectContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectContract createManyAndReturn
   */
  export type ProjectContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectContracts.
     */
    data: ProjectContractCreateManyInput | ProjectContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectContract update
   */
  export type ProjectContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectContract.
     */
    data: XOR<ProjectContractUpdateInput, ProjectContractUncheckedUpdateInput>
    /**
     * Choose, which ProjectContract to update.
     */
    where: ProjectContractWhereUniqueInput
  }

  /**
   * ProjectContract updateMany
   */
  export type ProjectContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectContracts.
     */
    data: XOR<ProjectContractUpdateManyMutationInput, ProjectContractUncheckedUpdateManyInput>
    /**
     * Filter which ProjectContracts to update
     */
    where?: ProjectContractWhereInput
  }

  /**
   * ProjectContract upsert
   */
  export type ProjectContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectContract to update in case it exists.
     */
    where: ProjectContractWhereUniqueInput
    /**
     * In case the ProjectContract found by the `where` argument doesn't exist, create a new ProjectContract with this data.
     */
    create: XOR<ProjectContractCreateInput, ProjectContractUncheckedCreateInput>
    /**
     * In case the ProjectContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectContractUpdateInput, ProjectContractUncheckedUpdateInput>
  }

  /**
   * ProjectContract delete
   */
  export type ProjectContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
    /**
     * Filter which ProjectContract to delete.
     */
    where: ProjectContractWhereUniqueInput
  }

  /**
   * ProjectContract deleteMany
   */
  export type ProjectContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectContracts to delete
     */
    where?: ProjectContractWhereInput
  }

  /**
   * ProjectContract.revisionRequests
   */
  export type ProjectContract$revisionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    where?: ChapterRevisionRequestWhereInput
    orderBy?: ChapterRevisionRequestOrderByWithRelationInput | ChapterRevisionRequestOrderByWithRelationInput[]
    cursor?: ChapterRevisionRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterRevisionRequestScalarFieldEnum | ChapterRevisionRequestScalarFieldEnum[]
  }

  /**
   * ProjectContract without action
   */
  export type ProjectContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectContract
     */
    select?: ProjectContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectContractInclude<ExtArgs> | null
  }


  /**
   * Model ChapterRevisionRequest
   */

  export type AggregateChapterRevisionRequest = {
    _count: ChapterRevisionRequestCountAggregateOutputType | null
    _avg: ChapterRevisionRequestAvgAggregateOutputType | null
    _sum: ChapterRevisionRequestSumAggregateOutputType | null
    _min: ChapterRevisionRequestMinAggregateOutputType | null
    _max: ChapterRevisionRequestMaxAggregateOutputType | null
  }

  export type ChapterRevisionRequestAvgAggregateOutputType = {
    revisionCount: number | null
  }

  export type ChapterRevisionRequestSumAggregateOutputType = {
    revisionCount: number | null
  }

  export type ChapterRevisionRequestMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    chapterId: string | null
    requestedById: string | null
    reason: string | null
    specificFeedback: string | null
    status: $Enums.RevisionRequestStatus | null
    response: string | null
    requestedAt: Date | null
    completedAt: Date | null
    revisionCount: number | null
  }

  export type ChapterRevisionRequestMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    chapterId: string | null
    requestedById: string | null
    reason: string | null
    specificFeedback: string | null
    status: $Enums.RevisionRequestStatus | null
    response: string | null
    requestedAt: Date | null
    completedAt: Date | null
    revisionCount: number | null
  }

  export type ChapterRevisionRequestCountAggregateOutputType = {
    id: number
    contractId: number
    chapterId: number
    requestedById: number
    reason: number
    specificFeedback: number
    status: number
    response: number
    requestedAt: number
    completedAt: number
    revisionCount: number
    _all: number
  }


  export type ChapterRevisionRequestAvgAggregateInputType = {
    revisionCount?: true
  }

  export type ChapterRevisionRequestSumAggregateInputType = {
    revisionCount?: true
  }

  export type ChapterRevisionRequestMinAggregateInputType = {
    id?: true
    contractId?: true
    chapterId?: true
    requestedById?: true
    reason?: true
    specificFeedback?: true
    status?: true
    response?: true
    requestedAt?: true
    completedAt?: true
    revisionCount?: true
  }

  export type ChapterRevisionRequestMaxAggregateInputType = {
    id?: true
    contractId?: true
    chapterId?: true
    requestedById?: true
    reason?: true
    specificFeedback?: true
    status?: true
    response?: true
    requestedAt?: true
    completedAt?: true
    revisionCount?: true
  }

  export type ChapterRevisionRequestCountAggregateInputType = {
    id?: true
    contractId?: true
    chapterId?: true
    requestedById?: true
    reason?: true
    specificFeedback?: true
    status?: true
    response?: true
    requestedAt?: true
    completedAt?: true
    revisionCount?: true
    _all?: true
  }

  export type ChapterRevisionRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterRevisionRequest to aggregate.
     */
    where?: ChapterRevisionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterRevisionRequests to fetch.
     */
    orderBy?: ChapterRevisionRequestOrderByWithRelationInput | ChapterRevisionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterRevisionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterRevisionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterRevisionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChapterRevisionRequests
    **/
    _count?: true | ChapterRevisionRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterRevisionRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterRevisionRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterRevisionRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterRevisionRequestMaxAggregateInputType
  }

  export type GetChapterRevisionRequestAggregateType<T extends ChapterRevisionRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateChapterRevisionRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapterRevisionRequest[P]>
      : GetScalarType<T[P], AggregateChapterRevisionRequest[P]>
  }




  export type ChapterRevisionRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterRevisionRequestWhereInput
    orderBy?: ChapterRevisionRequestOrderByWithAggregationInput | ChapterRevisionRequestOrderByWithAggregationInput[]
    by: ChapterRevisionRequestScalarFieldEnum[] | ChapterRevisionRequestScalarFieldEnum
    having?: ChapterRevisionRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterRevisionRequestCountAggregateInputType | true
    _avg?: ChapterRevisionRequestAvgAggregateInputType
    _sum?: ChapterRevisionRequestSumAggregateInputType
    _min?: ChapterRevisionRequestMinAggregateInputType
    _max?: ChapterRevisionRequestMaxAggregateInputType
  }

  export type ChapterRevisionRequestGroupByOutputType = {
    id: string
    contractId: string
    chapterId: string
    requestedById: string
    reason: string
    specificFeedback: string | null
    status: $Enums.RevisionRequestStatus
    response: string | null
    requestedAt: Date
    completedAt: Date | null
    revisionCount: number
    _count: ChapterRevisionRequestCountAggregateOutputType | null
    _avg: ChapterRevisionRequestAvgAggregateOutputType | null
    _sum: ChapterRevisionRequestSumAggregateOutputType | null
    _min: ChapterRevisionRequestMinAggregateOutputType | null
    _max: ChapterRevisionRequestMaxAggregateOutputType | null
  }

  type GetChapterRevisionRequestGroupByPayload<T extends ChapterRevisionRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterRevisionRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterRevisionRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterRevisionRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterRevisionRequestGroupByOutputType[P]>
        }
      >
    >


  export type ChapterRevisionRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    chapterId?: boolean
    requestedById?: boolean
    reason?: boolean
    specificFeedback?: boolean
    status?: boolean
    response?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    revisionCount?: boolean
    contract?: boolean | ProjectContractDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterRevisionRequest"]>

  export type ChapterRevisionRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    chapterId?: boolean
    requestedById?: boolean
    reason?: boolean
    specificFeedback?: boolean
    status?: boolean
    response?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    revisionCount?: boolean
    contract?: boolean | ProjectContractDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterRevisionRequest"]>

  export type ChapterRevisionRequestSelectScalar = {
    id?: boolean
    contractId?: boolean
    chapterId?: boolean
    requestedById?: boolean
    reason?: boolean
    specificFeedback?: boolean
    status?: boolean
    response?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    revisionCount?: boolean
  }

  export type ChapterRevisionRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ProjectContractDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChapterRevisionRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ProjectContractDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChapterRevisionRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChapterRevisionRequest"
    objects: {
      contract: Prisma.$ProjectContractPayload<ExtArgs>
      chapter: Prisma.$ChapterPayload<ExtArgs>
      requestedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      chapterId: string
      requestedById: string
      reason: string
      specificFeedback: string | null
      status: $Enums.RevisionRequestStatus
      response: string | null
      requestedAt: Date
      completedAt: Date | null
      revisionCount: number
    }, ExtArgs["result"]["chapterRevisionRequest"]>
    composites: {}
  }

  type ChapterRevisionRequestGetPayload<S extends boolean | null | undefined | ChapterRevisionRequestDefaultArgs> = $Result.GetResult<Prisma.$ChapterRevisionRequestPayload, S>

  type ChapterRevisionRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChapterRevisionRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChapterRevisionRequestCountAggregateInputType | true
    }

  export interface ChapterRevisionRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChapterRevisionRequest'], meta: { name: 'ChapterRevisionRequest' } }
    /**
     * Find zero or one ChapterRevisionRequest that matches the filter.
     * @param {ChapterRevisionRequestFindUniqueArgs} args - Arguments to find a ChapterRevisionRequest
     * @example
     * // Get one ChapterRevisionRequest
     * const chapterRevisionRequest = await prisma.chapterRevisionRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterRevisionRequestFindUniqueArgs>(args: SelectSubset<T, ChapterRevisionRequestFindUniqueArgs<ExtArgs>>): Prisma__ChapterRevisionRequestClient<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChapterRevisionRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChapterRevisionRequestFindUniqueOrThrowArgs} args - Arguments to find a ChapterRevisionRequest
     * @example
     * // Get one ChapterRevisionRequest
     * const chapterRevisionRequest = await prisma.chapterRevisionRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterRevisionRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterRevisionRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterRevisionRequestClient<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChapterRevisionRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterRevisionRequestFindFirstArgs} args - Arguments to find a ChapterRevisionRequest
     * @example
     * // Get one ChapterRevisionRequest
     * const chapterRevisionRequest = await prisma.chapterRevisionRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterRevisionRequestFindFirstArgs>(args?: SelectSubset<T, ChapterRevisionRequestFindFirstArgs<ExtArgs>>): Prisma__ChapterRevisionRequestClient<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChapterRevisionRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterRevisionRequestFindFirstOrThrowArgs} args - Arguments to find a ChapterRevisionRequest
     * @example
     * // Get one ChapterRevisionRequest
     * const chapterRevisionRequest = await prisma.chapterRevisionRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterRevisionRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterRevisionRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterRevisionRequestClient<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChapterRevisionRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterRevisionRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChapterRevisionRequests
     * const chapterRevisionRequests = await prisma.chapterRevisionRequest.findMany()
     * 
     * // Get first 10 ChapterRevisionRequests
     * const chapterRevisionRequests = await prisma.chapterRevisionRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterRevisionRequestWithIdOnly = await prisma.chapterRevisionRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterRevisionRequestFindManyArgs>(args?: SelectSubset<T, ChapterRevisionRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChapterRevisionRequest.
     * @param {ChapterRevisionRequestCreateArgs} args - Arguments to create a ChapterRevisionRequest.
     * @example
     * // Create one ChapterRevisionRequest
     * const ChapterRevisionRequest = await prisma.chapterRevisionRequest.create({
     *   data: {
     *     // ... data to create a ChapterRevisionRequest
     *   }
     * })
     * 
     */
    create<T extends ChapterRevisionRequestCreateArgs>(args: SelectSubset<T, ChapterRevisionRequestCreateArgs<ExtArgs>>): Prisma__ChapterRevisionRequestClient<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChapterRevisionRequests.
     * @param {ChapterRevisionRequestCreateManyArgs} args - Arguments to create many ChapterRevisionRequests.
     * @example
     * // Create many ChapterRevisionRequests
     * const chapterRevisionRequest = await prisma.chapterRevisionRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterRevisionRequestCreateManyArgs>(args?: SelectSubset<T, ChapterRevisionRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChapterRevisionRequests and returns the data saved in the database.
     * @param {ChapterRevisionRequestCreateManyAndReturnArgs} args - Arguments to create many ChapterRevisionRequests.
     * @example
     * // Create many ChapterRevisionRequests
     * const chapterRevisionRequest = await prisma.chapterRevisionRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChapterRevisionRequests and only return the `id`
     * const chapterRevisionRequestWithIdOnly = await prisma.chapterRevisionRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterRevisionRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterRevisionRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChapterRevisionRequest.
     * @param {ChapterRevisionRequestDeleteArgs} args - Arguments to delete one ChapterRevisionRequest.
     * @example
     * // Delete one ChapterRevisionRequest
     * const ChapterRevisionRequest = await prisma.chapterRevisionRequest.delete({
     *   where: {
     *     // ... filter to delete one ChapterRevisionRequest
     *   }
     * })
     * 
     */
    delete<T extends ChapterRevisionRequestDeleteArgs>(args: SelectSubset<T, ChapterRevisionRequestDeleteArgs<ExtArgs>>): Prisma__ChapterRevisionRequestClient<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChapterRevisionRequest.
     * @param {ChapterRevisionRequestUpdateArgs} args - Arguments to update one ChapterRevisionRequest.
     * @example
     * // Update one ChapterRevisionRequest
     * const chapterRevisionRequest = await prisma.chapterRevisionRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterRevisionRequestUpdateArgs>(args: SelectSubset<T, ChapterRevisionRequestUpdateArgs<ExtArgs>>): Prisma__ChapterRevisionRequestClient<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChapterRevisionRequests.
     * @param {ChapterRevisionRequestDeleteManyArgs} args - Arguments to filter ChapterRevisionRequests to delete.
     * @example
     * // Delete a few ChapterRevisionRequests
     * const { count } = await prisma.chapterRevisionRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterRevisionRequestDeleteManyArgs>(args?: SelectSubset<T, ChapterRevisionRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterRevisionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterRevisionRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChapterRevisionRequests
     * const chapterRevisionRequest = await prisma.chapterRevisionRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterRevisionRequestUpdateManyArgs>(args: SelectSubset<T, ChapterRevisionRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChapterRevisionRequest.
     * @param {ChapterRevisionRequestUpsertArgs} args - Arguments to update or create a ChapterRevisionRequest.
     * @example
     * // Update or create a ChapterRevisionRequest
     * const chapterRevisionRequest = await prisma.chapterRevisionRequest.upsert({
     *   create: {
     *     // ... data to create a ChapterRevisionRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChapterRevisionRequest we want to update
     *   }
     * })
     */
    upsert<T extends ChapterRevisionRequestUpsertArgs>(args: SelectSubset<T, ChapterRevisionRequestUpsertArgs<ExtArgs>>): Prisma__ChapterRevisionRequestClient<$Result.GetResult<Prisma.$ChapterRevisionRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChapterRevisionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterRevisionRequestCountArgs} args - Arguments to filter ChapterRevisionRequests to count.
     * @example
     * // Count the number of ChapterRevisionRequests
     * const count = await prisma.chapterRevisionRequest.count({
     *   where: {
     *     // ... the filter for the ChapterRevisionRequests we want to count
     *   }
     * })
    **/
    count<T extends ChapterRevisionRequestCountArgs>(
      args?: Subset<T, ChapterRevisionRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterRevisionRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChapterRevisionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterRevisionRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterRevisionRequestAggregateArgs>(args: Subset<T, ChapterRevisionRequestAggregateArgs>): Prisma.PrismaPromise<GetChapterRevisionRequestAggregateType<T>>

    /**
     * Group by ChapterRevisionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterRevisionRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterRevisionRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterRevisionRequestGroupByArgs['orderBy'] }
        : { orderBy?: ChapterRevisionRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterRevisionRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterRevisionRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChapterRevisionRequest model
   */
  readonly fields: ChapterRevisionRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChapterRevisionRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterRevisionRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ProjectContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectContractDefaultArgs<ExtArgs>>): Prisma__ProjectContractClient<$Result.GetResult<Prisma.$ProjectContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requestedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChapterRevisionRequest model
   */ 
  interface ChapterRevisionRequestFieldRefs {
    readonly id: FieldRef<"ChapterRevisionRequest", 'String'>
    readonly contractId: FieldRef<"ChapterRevisionRequest", 'String'>
    readonly chapterId: FieldRef<"ChapterRevisionRequest", 'String'>
    readonly requestedById: FieldRef<"ChapterRevisionRequest", 'String'>
    readonly reason: FieldRef<"ChapterRevisionRequest", 'String'>
    readonly specificFeedback: FieldRef<"ChapterRevisionRequest", 'String'>
    readonly status: FieldRef<"ChapterRevisionRequest", 'RevisionRequestStatus'>
    readonly response: FieldRef<"ChapterRevisionRequest", 'String'>
    readonly requestedAt: FieldRef<"ChapterRevisionRequest", 'DateTime'>
    readonly completedAt: FieldRef<"ChapterRevisionRequest", 'DateTime'>
    readonly revisionCount: FieldRef<"ChapterRevisionRequest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChapterRevisionRequest findUnique
   */
  export type ChapterRevisionRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChapterRevisionRequest to fetch.
     */
    where: ChapterRevisionRequestWhereUniqueInput
  }

  /**
   * ChapterRevisionRequest findUniqueOrThrow
   */
  export type ChapterRevisionRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChapterRevisionRequest to fetch.
     */
    where: ChapterRevisionRequestWhereUniqueInput
  }

  /**
   * ChapterRevisionRequest findFirst
   */
  export type ChapterRevisionRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChapterRevisionRequest to fetch.
     */
    where?: ChapterRevisionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterRevisionRequests to fetch.
     */
    orderBy?: ChapterRevisionRequestOrderByWithRelationInput | ChapterRevisionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterRevisionRequests.
     */
    cursor?: ChapterRevisionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterRevisionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterRevisionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterRevisionRequests.
     */
    distinct?: ChapterRevisionRequestScalarFieldEnum | ChapterRevisionRequestScalarFieldEnum[]
  }

  /**
   * ChapterRevisionRequest findFirstOrThrow
   */
  export type ChapterRevisionRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChapterRevisionRequest to fetch.
     */
    where?: ChapterRevisionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterRevisionRequests to fetch.
     */
    orderBy?: ChapterRevisionRequestOrderByWithRelationInput | ChapterRevisionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterRevisionRequests.
     */
    cursor?: ChapterRevisionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterRevisionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterRevisionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterRevisionRequests.
     */
    distinct?: ChapterRevisionRequestScalarFieldEnum | ChapterRevisionRequestScalarFieldEnum[]
  }

  /**
   * ChapterRevisionRequest findMany
   */
  export type ChapterRevisionRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChapterRevisionRequests to fetch.
     */
    where?: ChapterRevisionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterRevisionRequests to fetch.
     */
    orderBy?: ChapterRevisionRequestOrderByWithRelationInput | ChapterRevisionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChapterRevisionRequests.
     */
    cursor?: ChapterRevisionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterRevisionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterRevisionRequests.
     */
    skip?: number
    distinct?: ChapterRevisionRequestScalarFieldEnum | ChapterRevisionRequestScalarFieldEnum[]
  }

  /**
   * ChapterRevisionRequest create
   */
  export type ChapterRevisionRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ChapterRevisionRequest.
     */
    data: XOR<ChapterRevisionRequestCreateInput, ChapterRevisionRequestUncheckedCreateInput>
  }

  /**
   * ChapterRevisionRequest createMany
   */
  export type ChapterRevisionRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChapterRevisionRequests.
     */
    data: ChapterRevisionRequestCreateManyInput | ChapterRevisionRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChapterRevisionRequest createManyAndReturn
   */
  export type ChapterRevisionRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChapterRevisionRequests.
     */
    data: ChapterRevisionRequestCreateManyInput | ChapterRevisionRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterRevisionRequest update
   */
  export type ChapterRevisionRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ChapterRevisionRequest.
     */
    data: XOR<ChapterRevisionRequestUpdateInput, ChapterRevisionRequestUncheckedUpdateInput>
    /**
     * Choose, which ChapterRevisionRequest to update.
     */
    where: ChapterRevisionRequestWhereUniqueInput
  }

  /**
   * ChapterRevisionRequest updateMany
   */
  export type ChapterRevisionRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChapterRevisionRequests.
     */
    data: XOR<ChapterRevisionRequestUpdateManyMutationInput, ChapterRevisionRequestUncheckedUpdateManyInput>
    /**
     * Filter which ChapterRevisionRequests to update
     */
    where?: ChapterRevisionRequestWhereInput
  }

  /**
   * ChapterRevisionRequest upsert
   */
  export type ChapterRevisionRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ChapterRevisionRequest to update in case it exists.
     */
    where: ChapterRevisionRequestWhereUniqueInput
    /**
     * In case the ChapterRevisionRequest found by the `where` argument doesn't exist, create a new ChapterRevisionRequest with this data.
     */
    create: XOR<ChapterRevisionRequestCreateInput, ChapterRevisionRequestUncheckedCreateInput>
    /**
     * In case the ChapterRevisionRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterRevisionRequestUpdateInput, ChapterRevisionRequestUncheckedUpdateInput>
  }

  /**
   * ChapterRevisionRequest delete
   */
  export type ChapterRevisionRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
    /**
     * Filter which ChapterRevisionRequest to delete.
     */
    where: ChapterRevisionRequestWhereUniqueInput
  }

  /**
   * ChapterRevisionRequest deleteMany
   */
  export type ChapterRevisionRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterRevisionRequests to delete
     */
    where?: ChapterRevisionRequestWhereInput
  }

  /**
   * ChapterRevisionRequest without action
   */
  export type ChapterRevisionRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterRevisionRequest
     */
    select?: ChapterRevisionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterRevisionRequestInclude<ExtArgs> | null
  }


  /**
   * Model EditorReview
   */

  export type AggregateEditorReview = {
    _count: EditorReviewCountAggregateOutputType | null
    _avg: EditorReviewAvgAggregateOutputType | null
    _sum: EditorReviewSumAggregateOutputType | null
    _min: EditorReviewMinAggregateOutputType | null
    _max: EditorReviewMaxAggregateOutputType | null
  }

  export type EditorReviewAvgAggregateOutputType = {
    overallRating: number | null
    qualityRating: number | null
    speedRating: number | null
    communicationRating: number | null
  }

  export type EditorReviewSumAggregateOutputType = {
    overallRating: number | null
    qualityRating: number | null
    speedRating: number | null
    communicationRating: number | null
  }

  export type EditorReviewMinAggregateOutputType = {
    id: string | null
    editorProfileId: string | null
    authorId: string | null
    workId: string | null
    overallRating: number | null
    qualityRating: number | null
    speedRating: number | null
    communicationRating: number | null
    content: string | null
    isPublic: boolean | null
    createdAt: Date | null
  }

  export type EditorReviewMaxAggregateOutputType = {
    id: string | null
    editorProfileId: string | null
    authorId: string | null
    workId: string | null
    overallRating: number | null
    qualityRating: number | null
    speedRating: number | null
    communicationRating: number | null
    content: string | null
    isPublic: boolean | null
    createdAt: Date | null
  }

  export type EditorReviewCountAggregateOutputType = {
    id: number
    editorProfileId: number
    authorId: number
    workId: number
    overallRating: number
    qualityRating: number
    speedRating: number
    communicationRating: number
    content: number
    isPublic: number
    createdAt: number
    _all: number
  }


  export type EditorReviewAvgAggregateInputType = {
    overallRating?: true
    qualityRating?: true
    speedRating?: true
    communicationRating?: true
  }

  export type EditorReviewSumAggregateInputType = {
    overallRating?: true
    qualityRating?: true
    speedRating?: true
    communicationRating?: true
  }

  export type EditorReviewMinAggregateInputType = {
    id?: true
    editorProfileId?: true
    authorId?: true
    workId?: true
    overallRating?: true
    qualityRating?: true
    speedRating?: true
    communicationRating?: true
    content?: true
    isPublic?: true
    createdAt?: true
  }

  export type EditorReviewMaxAggregateInputType = {
    id?: true
    editorProfileId?: true
    authorId?: true
    workId?: true
    overallRating?: true
    qualityRating?: true
    speedRating?: true
    communicationRating?: true
    content?: true
    isPublic?: true
    createdAt?: true
  }

  export type EditorReviewCountAggregateInputType = {
    id?: true
    editorProfileId?: true
    authorId?: true
    workId?: true
    overallRating?: true
    qualityRating?: true
    speedRating?: true
    communicationRating?: true
    content?: true
    isPublic?: true
    createdAt?: true
    _all?: true
  }

  export type EditorReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EditorReview to aggregate.
     */
    where?: EditorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditorReviews to fetch.
     */
    orderBy?: EditorReviewOrderByWithRelationInput | EditorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EditorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EditorReviews
    **/
    _count?: true | EditorReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EditorReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EditorReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EditorReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EditorReviewMaxAggregateInputType
  }

  export type GetEditorReviewAggregateType<T extends EditorReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateEditorReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEditorReview[P]>
      : GetScalarType<T[P], AggregateEditorReview[P]>
  }




  export type EditorReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EditorReviewWhereInput
    orderBy?: EditorReviewOrderByWithAggregationInput | EditorReviewOrderByWithAggregationInput[]
    by: EditorReviewScalarFieldEnum[] | EditorReviewScalarFieldEnum
    having?: EditorReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EditorReviewCountAggregateInputType | true
    _avg?: EditorReviewAvgAggregateInputType
    _sum?: EditorReviewSumAggregateInputType
    _min?: EditorReviewMinAggregateInputType
    _max?: EditorReviewMaxAggregateInputType
  }

  export type EditorReviewGroupByOutputType = {
    id: string
    editorProfileId: string
    authorId: string
    workId: string
    overallRating: number
    qualityRating: number | null
    speedRating: number | null
    communicationRating: number | null
    content: string | null
    isPublic: boolean
    createdAt: Date
    _count: EditorReviewCountAggregateOutputType | null
    _avg: EditorReviewAvgAggregateOutputType | null
    _sum: EditorReviewSumAggregateOutputType | null
    _min: EditorReviewMinAggregateOutputType | null
    _max: EditorReviewMaxAggregateOutputType | null
  }

  type GetEditorReviewGroupByPayload<T extends EditorReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EditorReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EditorReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EditorReviewGroupByOutputType[P]>
            : GetScalarType<T[P], EditorReviewGroupByOutputType[P]>
        }
      >
    >


  export type EditorReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    editorProfileId?: boolean
    authorId?: boolean
    workId?: boolean
    overallRating?: boolean
    qualityRating?: boolean
    speedRating?: boolean
    communicationRating?: boolean
    content?: boolean
    isPublic?: boolean
    createdAt?: boolean
    editorProfile?: boolean | EditorProfileDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["editorReview"]>

  export type EditorReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    editorProfileId?: boolean
    authorId?: boolean
    workId?: boolean
    overallRating?: boolean
    qualityRating?: boolean
    speedRating?: boolean
    communicationRating?: boolean
    content?: boolean
    isPublic?: boolean
    createdAt?: boolean
    editorProfile?: boolean | EditorProfileDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["editorReview"]>

  export type EditorReviewSelectScalar = {
    id?: boolean
    editorProfileId?: boolean
    authorId?: boolean
    workId?: boolean
    overallRating?: boolean
    qualityRating?: boolean
    speedRating?: boolean
    communicationRating?: boolean
    content?: boolean
    isPublic?: boolean
    createdAt?: boolean
  }

  export type EditorReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    editorProfile?: boolean | EditorProfileDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }
  export type EditorReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    editorProfile?: boolean | EditorProfileDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    work?: boolean | WorkDefaultArgs<ExtArgs>
  }

  export type $EditorReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EditorReview"
    objects: {
      editorProfile: Prisma.$EditorProfilePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      work: Prisma.$WorkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      editorProfileId: string
      authorId: string
      workId: string
      overallRating: number
      qualityRating: number | null
      speedRating: number | null
      communicationRating: number | null
      content: string | null
      isPublic: boolean
      createdAt: Date
    }, ExtArgs["result"]["editorReview"]>
    composites: {}
  }

  type EditorReviewGetPayload<S extends boolean | null | undefined | EditorReviewDefaultArgs> = $Result.GetResult<Prisma.$EditorReviewPayload, S>

  type EditorReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EditorReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EditorReviewCountAggregateInputType | true
    }

  export interface EditorReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EditorReview'], meta: { name: 'EditorReview' } }
    /**
     * Find zero or one EditorReview that matches the filter.
     * @param {EditorReviewFindUniqueArgs} args - Arguments to find a EditorReview
     * @example
     * // Get one EditorReview
     * const editorReview = await prisma.editorReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EditorReviewFindUniqueArgs>(args: SelectSubset<T, EditorReviewFindUniqueArgs<ExtArgs>>): Prisma__EditorReviewClient<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EditorReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EditorReviewFindUniqueOrThrowArgs} args - Arguments to find a EditorReview
     * @example
     * // Get one EditorReview
     * const editorReview = await prisma.editorReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EditorReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, EditorReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EditorReviewClient<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EditorReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorReviewFindFirstArgs} args - Arguments to find a EditorReview
     * @example
     * // Get one EditorReview
     * const editorReview = await prisma.editorReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EditorReviewFindFirstArgs>(args?: SelectSubset<T, EditorReviewFindFirstArgs<ExtArgs>>): Prisma__EditorReviewClient<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EditorReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorReviewFindFirstOrThrowArgs} args - Arguments to find a EditorReview
     * @example
     * // Get one EditorReview
     * const editorReview = await prisma.editorReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EditorReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, EditorReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__EditorReviewClient<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EditorReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EditorReviews
     * const editorReviews = await prisma.editorReview.findMany()
     * 
     * // Get first 10 EditorReviews
     * const editorReviews = await prisma.editorReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const editorReviewWithIdOnly = await prisma.editorReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EditorReviewFindManyArgs>(args?: SelectSubset<T, EditorReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EditorReview.
     * @param {EditorReviewCreateArgs} args - Arguments to create a EditorReview.
     * @example
     * // Create one EditorReview
     * const EditorReview = await prisma.editorReview.create({
     *   data: {
     *     // ... data to create a EditorReview
     *   }
     * })
     * 
     */
    create<T extends EditorReviewCreateArgs>(args: SelectSubset<T, EditorReviewCreateArgs<ExtArgs>>): Prisma__EditorReviewClient<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EditorReviews.
     * @param {EditorReviewCreateManyArgs} args - Arguments to create many EditorReviews.
     * @example
     * // Create many EditorReviews
     * const editorReview = await prisma.editorReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EditorReviewCreateManyArgs>(args?: SelectSubset<T, EditorReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EditorReviews and returns the data saved in the database.
     * @param {EditorReviewCreateManyAndReturnArgs} args - Arguments to create many EditorReviews.
     * @example
     * // Create many EditorReviews
     * const editorReview = await prisma.editorReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EditorReviews and only return the `id`
     * const editorReviewWithIdOnly = await prisma.editorReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EditorReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, EditorReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EditorReview.
     * @param {EditorReviewDeleteArgs} args - Arguments to delete one EditorReview.
     * @example
     * // Delete one EditorReview
     * const EditorReview = await prisma.editorReview.delete({
     *   where: {
     *     // ... filter to delete one EditorReview
     *   }
     * })
     * 
     */
    delete<T extends EditorReviewDeleteArgs>(args: SelectSubset<T, EditorReviewDeleteArgs<ExtArgs>>): Prisma__EditorReviewClient<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EditorReview.
     * @param {EditorReviewUpdateArgs} args - Arguments to update one EditorReview.
     * @example
     * // Update one EditorReview
     * const editorReview = await prisma.editorReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EditorReviewUpdateArgs>(args: SelectSubset<T, EditorReviewUpdateArgs<ExtArgs>>): Prisma__EditorReviewClient<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EditorReviews.
     * @param {EditorReviewDeleteManyArgs} args - Arguments to filter EditorReviews to delete.
     * @example
     * // Delete a few EditorReviews
     * const { count } = await prisma.editorReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EditorReviewDeleteManyArgs>(args?: SelectSubset<T, EditorReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EditorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EditorReviews
     * const editorReview = await prisma.editorReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EditorReviewUpdateManyArgs>(args: SelectSubset<T, EditorReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EditorReview.
     * @param {EditorReviewUpsertArgs} args - Arguments to update or create a EditorReview.
     * @example
     * // Update or create a EditorReview
     * const editorReview = await prisma.editorReview.upsert({
     *   create: {
     *     // ... data to create a EditorReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EditorReview we want to update
     *   }
     * })
     */
    upsert<T extends EditorReviewUpsertArgs>(args: SelectSubset<T, EditorReviewUpsertArgs<ExtArgs>>): Prisma__EditorReviewClient<$Result.GetResult<Prisma.$EditorReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EditorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorReviewCountArgs} args - Arguments to filter EditorReviews to count.
     * @example
     * // Count the number of EditorReviews
     * const count = await prisma.editorReview.count({
     *   where: {
     *     // ... the filter for the EditorReviews we want to count
     *   }
     * })
    **/
    count<T extends EditorReviewCountArgs>(
      args?: Subset<T, EditorReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EditorReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EditorReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EditorReviewAggregateArgs>(args: Subset<T, EditorReviewAggregateArgs>): Prisma.PrismaPromise<GetEditorReviewAggregateType<T>>

    /**
     * Group by EditorReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditorReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EditorReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EditorReviewGroupByArgs['orderBy'] }
        : { orderBy?: EditorReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EditorReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEditorReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EditorReview model
   */
  readonly fields: EditorReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EditorReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EditorReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    editorProfile<T extends EditorProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EditorProfileDefaultArgs<ExtArgs>>): Prisma__EditorProfileClient<$Result.GetResult<Prisma.$EditorProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    work<T extends WorkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkDefaultArgs<ExtArgs>>): Prisma__WorkClient<$Result.GetResult<Prisma.$WorkPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EditorReview model
   */ 
  interface EditorReviewFieldRefs {
    readonly id: FieldRef<"EditorReview", 'String'>
    readonly editorProfileId: FieldRef<"EditorReview", 'String'>
    readonly authorId: FieldRef<"EditorReview", 'String'>
    readonly workId: FieldRef<"EditorReview", 'String'>
    readonly overallRating: FieldRef<"EditorReview", 'Int'>
    readonly qualityRating: FieldRef<"EditorReview", 'Int'>
    readonly speedRating: FieldRef<"EditorReview", 'Int'>
    readonly communicationRating: FieldRef<"EditorReview", 'Int'>
    readonly content: FieldRef<"EditorReview", 'String'>
    readonly isPublic: FieldRef<"EditorReview", 'Boolean'>
    readonly createdAt: FieldRef<"EditorReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EditorReview findUnique
   */
  export type EditorReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    /**
     * Filter, which EditorReview to fetch.
     */
    where: EditorReviewWhereUniqueInput
  }

  /**
   * EditorReview findUniqueOrThrow
   */
  export type EditorReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    /**
     * Filter, which EditorReview to fetch.
     */
    where: EditorReviewWhereUniqueInput
  }

  /**
   * EditorReview findFirst
   */
  export type EditorReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    /**
     * Filter, which EditorReview to fetch.
     */
    where?: EditorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditorReviews to fetch.
     */
    orderBy?: EditorReviewOrderByWithRelationInput | EditorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EditorReviews.
     */
    cursor?: EditorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EditorReviews.
     */
    distinct?: EditorReviewScalarFieldEnum | EditorReviewScalarFieldEnum[]
  }

  /**
   * EditorReview findFirstOrThrow
   */
  export type EditorReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    /**
     * Filter, which EditorReview to fetch.
     */
    where?: EditorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditorReviews to fetch.
     */
    orderBy?: EditorReviewOrderByWithRelationInput | EditorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EditorReviews.
     */
    cursor?: EditorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EditorReviews.
     */
    distinct?: EditorReviewScalarFieldEnum | EditorReviewScalarFieldEnum[]
  }

  /**
   * EditorReview findMany
   */
  export type EditorReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    /**
     * Filter, which EditorReviews to fetch.
     */
    where?: EditorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditorReviews to fetch.
     */
    orderBy?: EditorReviewOrderByWithRelationInput | EditorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EditorReviews.
     */
    cursor?: EditorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditorReviews.
     */
    skip?: number
    distinct?: EditorReviewScalarFieldEnum | EditorReviewScalarFieldEnum[]
  }

  /**
   * EditorReview create
   */
  export type EditorReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a EditorReview.
     */
    data: XOR<EditorReviewCreateInput, EditorReviewUncheckedCreateInput>
  }

  /**
   * EditorReview createMany
   */
  export type EditorReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EditorReviews.
     */
    data: EditorReviewCreateManyInput | EditorReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EditorReview createManyAndReturn
   */
  export type EditorReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EditorReviews.
     */
    data: EditorReviewCreateManyInput | EditorReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EditorReview update
   */
  export type EditorReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a EditorReview.
     */
    data: XOR<EditorReviewUpdateInput, EditorReviewUncheckedUpdateInput>
    /**
     * Choose, which EditorReview to update.
     */
    where: EditorReviewWhereUniqueInput
  }

  /**
   * EditorReview updateMany
   */
  export type EditorReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EditorReviews.
     */
    data: XOR<EditorReviewUpdateManyMutationInput, EditorReviewUncheckedUpdateManyInput>
    /**
     * Filter which EditorReviews to update
     */
    where?: EditorReviewWhereInput
  }

  /**
   * EditorReview upsert
   */
  export type EditorReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the EditorReview to update in case it exists.
     */
    where: EditorReviewWhereUniqueInput
    /**
     * In case the EditorReview found by the `where` argument doesn't exist, create a new EditorReview with this data.
     */
    create: XOR<EditorReviewCreateInput, EditorReviewUncheckedCreateInput>
    /**
     * In case the EditorReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EditorReviewUpdateInput, EditorReviewUncheckedUpdateInput>
  }

  /**
   * EditorReview delete
   */
  export type EditorReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
    /**
     * Filter which EditorReview to delete.
     */
    where: EditorReviewWhereUniqueInput
  }

  /**
   * EditorReview deleteMany
   */
  export type EditorReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EditorReviews to delete
     */
    where?: EditorReviewWhereInput
  }

  /**
   * EditorReview without action
   */
  export type EditorReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditorReview
     */
    select?: EditorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EditorReviewInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    image: 'image',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const WorkScalarFieldEnum: {
    id: 'id',
    titleKo: 'titleKo',
    titleOriginal: 'titleOriginal',
    publisher: 'publisher',
    ageRating: 'ageRating',
    status: 'status',
    coverImage: 'coverImage',
    synopsis: 'synopsis',
    genres: 'genres',
    originalStatus: 'originalStatus',
    sourceLanguage: 'sourceLanguage',
    expectedChapters: 'expectedChapters',
    platformName: 'platformName',
    platformUrl: 'platformUrl',
    publishedAt: 'publishedAt',
    totalChapters: 'totalChapters',
    authorId: 'authorId',
    editorId: 'editorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkScalarFieldEnum = (typeof WorkScalarFieldEnum)[keyof typeof WorkScalarFieldEnum]


  export const CreatorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    workId: 'workId'
  };

  export type CreatorScalarFieldEnum = (typeof CreatorScalarFieldEnum)[keyof typeof CreatorScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    number: 'number',
    title: 'title',
    originalContent: 'originalContent',
    translatedContent: 'translatedContent',
    editedContent: 'editedContent',
    status: 'status',
    wordCount: 'wordCount',
    translationMeta: 'translationMeta',
    trackChangesState: 'trackChangesState',
    lastEditedById: 'lastEditedById',
    lastEditedAt: 'lastEditedAt',
    workId: 'workId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const GlossaryItemScalarFieldEnum: {
    id: 'id',
    original: 'original',
    translated: 'translated',
    category: 'category',
    note: 'note',
    workId: 'workId'
  };

  export type GlossaryItemScalarFieldEnum = (typeof GlossaryItemScalarFieldEnum)[keyof typeof GlossaryItemScalarFieldEnum]


  export const TranslationLogScalarFieldEnum: {
    id: 'id',
    level: 'level',
    category: 'category',
    jobId: 'jobId',
    workId: 'workId',
    chapterId: 'chapterId',
    chapterNum: 'chapterNum',
    chunkIndex: 'chunkIndex',
    userId: 'userId',
    userEmail: 'userEmail',
    message: 'message',
    errorCode: 'errorCode',
    errorStack: 'errorStack',
    metadata: 'metadata',
    durationMs: 'durationMs',
    retryCount: 'retryCount',
    clientIp: 'clientIp',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type TranslationLogScalarFieldEnum = (typeof TranslationLogScalarFieldEnum)[keyof typeof TranslationLogScalarFieldEnum]


  export const ActiveTranslationJobScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    workId: 'workId',
    workTitle: 'workTitle',
    userId: 'userId',
    userEmail: 'userEmail',
    status: 'status',
    isPauseRequested: 'isPauseRequested',
    batchPlan: 'batchPlan',
    totalBatches: 'totalBatches',
    currentBatchIndex: 'currentBatchIndex',
    retryCount: 'retryCount',
    maxRetries: 'maxRetries',
    lastError: 'lastError',
    totalChapters: 'totalChapters',
    completedChapters: 'completedChapters',
    failedChapters: 'failedChapters',
    currentChapterNum: 'currentChapterNum',
    currentChunkIndex: 'currentChunkIndex',
    totalChunks: 'totalChunks',
    chaptersProgress: 'chaptersProgress',
    failedChapterNums: 'failedChapterNums',
    autoRetryCount: 'autoRetryCount',
    maxAutoRetries: 'maxAutoRetries',
    errorMessage: 'errorMessage',
    lockedAt: 'lockedAt',
    lockedBy: 'lockedBy',
    startedAt: 'startedAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type ActiveTranslationJobScalarFieldEnum = (typeof ActiveTranslationJobScalarFieldEnum)[keyof typeof ActiveTranslationJobScalarFieldEnum]


  export const TranslationJobHistoryScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    workId: 'workId',
    workTitle: 'workTitle',
    userId: 'userId',
    userEmail: 'userEmail',
    status: 'status',
    totalChapters: 'totalChapters',
    completedChapters: 'completedChapters',
    failedChapters: 'failedChapters',
    errorMessage: 'errorMessage',
    failedChapterNums: 'failedChapterNums',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    durationMs: 'durationMs',
    createdAt: 'createdAt'
  };

  export type TranslationJobHistoryScalarFieldEnum = (typeof TranslationJobHistoryScalarFieldEnum)[keyof typeof TranslationJobHistoryScalarFieldEnum]


  export const SettingBibleScalarFieldEnum: {
    id: 'id',
    workId: 'workId',
    status: 'status',
    version: 'version',
    translationGuide: 'translationGuide',
    analyzedChapters: 'analyzedChapters',
    generatedAt: 'generatedAt',
    confirmedAt: 'confirmedAt',
    confirmedBy: 'confirmedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingBibleScalarFieldEnum = (typeof SettingBibleScalarFieldEnum)[keyof typeof SettingBibleScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    bibleId: 'bibleId',
    nameOriginal: 'nameOriginal',
    nameKorean: 'nameKorean',
    nameHanja: 'nameHanja',
    titles: 'titles',
    aliases: 'aliases',
    personality: 'personality',
    speechStyle: 'speechStyle',
    role: 'role',
    description: 'description',
    relationships: 'relationships',
    firstAppearance: 'firstAppearance',
    sortOrder: 'sortOrder',
    isConfirmed: 'isConfirmed'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const SettingTermScalarFieldEnum: {
    id: 'id',
    bibleId: 'bibleId',
    original: 'original',
    translated: 'translated',
    category: 'category',
    note: 'note',
    context: 'context',
    firstAppearance: 'firstAppearance',
    frequency: 'frequency',
    isConfirmed: 'isConfirmed'
  };

  export type SettingTermScalarFieldEnum = (typeof SettingTermScalarFieldEnum)[keyof typeof SettingTermScalarFieldEnum]


  export const TimelineEventScalarFieldEnum: {
    id: 'id',
    bibleId: 'bibleId',
    title: 'title',
    description: 'description',
    chapterStart: 'chapterStart',
    chapterEnd: 'chapterEnd',
    eventType: 'eventType',
    importance: 'importance',
    isForeshadowing: 'isForeshadowing',
    foreshadowNote: 'foreshadowNote',
    involvedCharacterIds: 'involvedCharacterIds'
  };

  export type TimelineEventScalarFieldEnum = (typeof TimelineEventScalarFieldEnum)[keyof typeof TimelineEventScalarFieldEnum]


  export const BibleGenerationJobScalarFieldEnum: {
    id: 'id',
    workId: 'workId',
    userId: 'userId',
    status: 'status',
    batchPlan: 'batchPlan',
    totalBatches: 'totalBatches',
    currentBatchIndex: 'currentBatchIndex',
    analyzedChapters: 'analyzedChapters',
    retryCount: 'retryCount',
    maxRetries: 'maxRetries',
    errorMessage: 'errorMessage',
    lastError: 'lastError',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    lockedAt: 'lockedAt',
    lockedBy: 'lockedBy'
  };

  export type BibleGenerationJobScalarFieldEnum = (typeof BibleGenerationJobScalarFieldEnum)[keyof typeof BibleGenerationJobScalarFieldEnum]


  export const ChapterCommentScalarFieldEnum: {
    id: 'id',
    chapterId: 'chapterId',
    authorId: 'authorId',
    parentId: 'parentId',
    content: 'content',
    textRange: 'textRange',
    quotedText: 'quotedText',
    isResolved: 'isResolved',
    resolvedAt: 'resolvedAt',
    resolvedById: 'resolvedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChapterCommentScalarFieldEnum = (typeof ChapterCommentScalarFieldEnum)[keyof typeof ChapterCommentScalarFieldEnum]


  export const ChapterSnapshotScalarFieldEnum: {
    id: 'id',
    chapterId: 'chapterId',
    authorId: 'authorId',
    name: 'name',
    description: 'description',
    snapshotType: 'snapshotType',
    originalContent: 'originalContent',
    translatedContent: 'translatedContent',
    editedContent: 'editedContent',
    status: 'status',
    triggerEvent: 'triggerEvent',
    createdAt: 'createdAt'
  };

  export type ChapterSnapshotScalarFieldEnum = (typeof ChapterSnapshotScalarFieldEnum)[keyof typeof ChapterSnapshotScalarFieldEnum]


  export const ChapterChangeScalarFieldEnum: {
    id: 'id',
    chapterId: 'chapterId',
    authorId: 'authorId',
    changeType: 'changeType',
    fromPos: 'fromPos',
    toPos: 'toPos',
    oldText: 'oldText',
    newText: 'newText',
    status: 'status',
    reviewedById: 'reviewedById',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt'
  };

  export type ChapterChangeScalarFieldEnum = (typeof ChapterChangeScalarFieldEnum)[keyof typeof ChapterChangeScalarFieldEnum]


  export const ChapterActivityScalarFieldEnum: {
    id: 'id',
    chapterId: 'chapterId',
    actorId: 'actorId',
    activityType: 'activityType',
    metadata: 'metadata',
    summary: 'summary',
    createdAt: 'createdAt'
  };

  export type ChapterActivityScalarFieldEnum = (typeof ChapterActivityScalarFieldEnum)[keyof typeof ChapterActivityScalarFieldEnum]


  export const EditorProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    displayName: 'displayName',
    bio: 'bio',
    portfolioUrl: 'portfolioUrl',
    specialtyGenres: 'specialtyGenres',
    languages: 'languages',
    availability: 'availability',
    maxConcurrent: 'maxConcurrent',
    completedProjects: 'completedProjects',
    averageRating: 'averageRating',
    totalReviews: 'totalReviews',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EditorProfileScalarFieldEnum = (typeof EditorProfileScalarFieldEnum)[keyof typeof EditorProfileScalarFieldEnum]


  export const PortfolioItemScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    title: 'title',
    description: 'description',
    genre: 'genre',
    sampleText: 'sampleText',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type PortfolioItemScalarFieldEnum = (typeof PortfolioItemScalarFieldEnum)[keyof typeof PortfolioItemScalarFieldEnum]


  export const ProjectListingScalarFieldEnum: {
    id: 'id',
    workId: 'workId',
    authorId: 'authorId',
    title: 'title',
    description: 'description',
    requirements: 'requirements',
    status: 'status',
    budgetMin: 'budgetMin',
    budgetMax: 'budgetMax',
    deadline: 'deadline',
    chapterStart: 'chapterStart',
    chapterEnd: 'chapterEnd',
    viewCount: 'viewCount',
    applicationCount: 'applicationCount',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectListingScalarFieldEnum = (typeof ProjectListingScalarFieldEnum)[keyof typeof ProjectListingScalarFieldEnum]


  export const ProjectApplicationScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    editorProfileId: 'editorProfileId',
    proposalMessage: 'proposalMessage',
    priceQuote: 'priceQuote',
    estimatedDays: 'estimatedDays',
    status: 'status',
    authorNote: 'authorNote',
    submittedAt: 'submittedAt',
    reviewedAt: 'reviewedAt'
  };

  export type ProjectApplicationScalarFieldEnum = (typeof ProjectApplicationScalarFieldEnum)[keyof typeof ProjectApplicationScalarFieldEnum]


  export const ProjectContractScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    workId: 'workId',
    authorId: 'authorId',
    editorId: 'editorId',
    totalAmount: 'totalAmount',
    startDate: 'startDate',
    expectedEndDate: 'expectedEndDate',
    chapterStart: 'chapterStart',
    chapterEnd: 'chapterEnd',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ProjectContractScalarFieldEnum = (typeof ProjectContractScalarFieldEnum)[keyof typeof ProjectContractScalarFieldEnum]


  export const ChapterRevisionRequestScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    chapterId: 'chapterId',
    requestedById: 'requestedById',
    reason: 'reason',
    specificFeedback: 'specificFeedback',
    status: 'status',
    response: 'response',
    requestedAt: 'requestedAt',
    completedAt: 'completedAt',
    revisionCount: 'revisionCount'
  };

  export type ChapterRevisionRequestScalarFieldEnum = (typeof ChapterRevisionRequestScalarFieldEnum)[keyof typeof ChapterRevisionRequestScalarFieldEnum]


  export const EditorReviewScalarFieldEnum: {
    id: 'id',
    editorProfileId: 'editorProfileId',
    authorId: 'authorId',
    workId: 'workId',
    overallRating: 'overallRating',
    qualityRating: 'qualityRating',
    speedRating: 'speedRating',
    communicationRating: 'communicationRating',
    content: 'content',
    isPublic: 'isPublic',
    createdAt: 'createdAt'
  };

  export type EditorReviewScalarFieldEnum = (typeof EditorReviewScalarFieldEnum)[keyof typeof EditorReviewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AgeRating'
   */
  export type EnumAgeRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeRating'>
    


  /**
   * Reference to a field of type 'AgeRating[]'
   */
  export type ListEnumAgeRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeRating[]'>
    


  /**
   * Reference to a field of type 'WorkStatus'
   */
  export type EnumWorkStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkStatus'>
    


  /**
   * Reference to a field of type 'WorkStatus[]'
   */
  export type ListEnumWorkStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkStatus[]'>
    


  /**
   * Reference to a field of type 'OriginalStatus'
   */
  export type EnumOriginalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OriginalStatus'>
    


  /**
   * Reference to a field of type 'OriginalStatus[]'
   */
  export type ListEnumOriginalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OriginalStatus[]'>
    


  /**
   * Reference to a field of type 'SourceLanguage'
   */
  export type EnumSourceLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceLanguage'>
    


  /**
   * Reference to a field of type 'SourceLanguage[]'
   */
  export type ListEnumSourceLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceLanguage[]'>
    


  /**
   * Reference to a field of type 'ChapterStatus'
   */
  export type EnumChapterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChapterStatus'>
    


  /**
   * Reference to a field of type 'ChapterStatus[]'
   */
  export type ListEnumChapterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChapterStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'LogLevel'
   */
  export type EnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel'>
    


  /**
   * Reference to a field of type 'LogLevel[]'
   */
  export type ListEnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel[]'>
    


  /**
   * Reference to a field of type 'LogCategory'
   */
  export type EnumLogCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogCategory'>
    


  /**
   * Reference to a field of type 'LogCategory[]'
   */
  export type ListEnumLogCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogCategory[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BibleStatus'
   */
  export type EnumBibleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BibleStatus'>
    


  /**
   * Reference to a field of type 'BibleStatus[]'
   */
  export type ListEnumBibleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BibleStatus[]'>
    


  /**
   * Reference to a field of type 'CharacterRole'
   */
  export type EnumCharacterRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CharacterRole'>
    


  /**
   * Reference to a field of type 'CharacterRole[]'
   */
  export type ListEnumCharacterRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CharacterRole[]'>
    


  /**
   * Reference to a field of type 'TermCategory'
   */
  export type EnumTermCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TermCategory'>
    


  /**
   * Reference to a field of type 'TermCategory[]'
   */
  export type ListEnumTermCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TermCategory[]'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'BibleJobStatus'
   */
  export type EnumBibleJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BibleJobStatus'>
    


  /**
   * Reference to a field of type 'BibleJobStatus[]'
   */
  export type ListEnumBibleJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BibleJobStatus[]'>
    


  /**
   * Reference to a field of type 'SnapshotType'
   */
  export type EnumSnapshotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnapshotType'>
    


  /**
   * Reference to a field of type 'SnapshotType[]'
   */
  export type ListEnumSnapshotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnapshotType[]'>
    


  /**
   * Reference to a field of type 'ChangeType'
   */
  export type EnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType'>
    


  /**
   * Reference to a field of type 'ChangeType[]'
   */
  export type ListEnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType[]'>
    


  /**
   * Reference to a field of type 'ChangeStatus'
   */
  export type EnumChangeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeStatus'>
    


  /**
   * Reference to a field of type 'ChangeStatus[]'
   */
  export type ListEnumChangeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeStatus[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'EditorAvailability'
   */
  export type EnumEditorAvailabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EditorAvailability'>
    


  /**
   * Reference to a field of type 'EditorAvailability[]'
   */
  export type ListEnumEditorAvailabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EditorAvailability[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProjectListingStatus'
   */
  export type EnumProjectListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectListingStatus'>
    


  /**
   * Reference to a field of type 'ProjectListingStatus[]'
   */
  export type ListEnumProjectListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectListingStatus[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'RevisionRequestStatus'
   */
  export type EnumRevisionRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionRequestStatus'>
    


  /**
   * Reference to a field of type 'RevisionRequestStatus[]'
   */
  export type ListEnumRevisionRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionRequestStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    image?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    works?: WorkListRelationFilter
    editingWorks?: WorkListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    lastEditedChapters?: ChapterListRelationFilter
    comments?: ChapterCommentListRelationFilter
    resolvedComments?: ChapterCommentListRelationFilter
    snapshots?: ChapterSnapshotListRelationFilter
    changes?: ChapterChangeListRelationFilter
    reviewedChanges?: ChapterChangeListRelationFilter
    activities?: ChapterActivityListRelationFilter
    editorProfile?: XOR<EditorProfileNullableRelationFilter, EditorProfileWhereInput> | null
    authorListings?: ProjectListingListRelationFilter
    authorContracts?: ProjectContractListRelationFilter
    editorContracts?: ProjectContractListRelationFilter
    revisionRequests?: ChapterRevisionRequestListRelationFilter
    authorReviews?: EditorReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrder
    role?: SortOrder
    image?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    works?: WorkOrderByRelationAggregateInput
    editingWorks?: WorkOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    lastEditedChapters?: ChapterOrderByRelationAggregateInput
    comments?: ChapterCommentOrderByRelationAggregateInput
    resolvedComments?: ChapterCommentOrderByRelationAggregateInput
    snapshots?: ChapterSnapshotOrderByRelationAggregateInput
    changes?: ChapterChangeOrderByRelationAggregateInput
    reviewedChanges?: ChapterChangeOrderByRelationAggregateInput
    activities?: ChapterActivityOrderByRelationAggregateInput
    editorProfile?: EditorProfileOrderByWithRelationInput
    authorListings?: ProjectListingOrderByRelationAggregateInput
    authorContracts?: ProjectContractOrderByRelationAggregateInput
    editorContracts?: ProjectContractOrderByRelationAggregateInput
    revisionRequests?: ChapterRevisionRequestOrderByRelationAggregateInput
    authorReviews?: EditorReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    image?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    works?: WorkListRelationFilter
    editingWorks?: WorkListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    lastEditedChapters?: ChapterListRelationFilter
    comments?: ChapterCommentListRelationFilter
    resolvedComments?: ChapterCommentListRelationFilter
    snapshots?: ChapterSnapshotListRelationFilter
    changes?: ChapterChangeListRelationFilter
    reviewedChanges?: ChapterChangeListRelationFilter
    activities?: ChapterActivityListRelationFilter
    editorProfile?: XOR<EditorProfileNullableRelationFilter, EditorProfileWhereInput> | null
    authorListings?: ProjectListingListRelationFilter
    authorContracts?: ProjectContractListRelationFilter
    editorContracts?: ProjectContractListRelationFilter
    revisionRequests?: ChapterRevisionRequestListRelationFilter
    authorReviews?: EditorReviewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrder
    role?: SortOrder
    image?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: PasswordResetTokenEmailTokenCompoundUniqueInput
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    email?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type WorkWhereInput = {
    AND?: WorkWhereInput | WorkWhereInput[]
    OR?: WorkWhereInput[]
    NOT?: WorkWhereInput | WorkWhereInput[]
    id?: StringFilter<"Work"> | string
    titleKo?: StringFilter<"Work"> | string
    titleOriginal?: StringFilter<"Work"> | string
    publisher?: StringFilter<"Work"> | string
    ageRating?: EnumAgeRatingFilter<"Work"> | $Enums.AgeRating
    status?: EnumWorkStatusFilter<"Work"> | $Enums.WorkStatus
    coverImage?: StringNullableFilter<"Work"> | string | null
    synopsis?: StringFilter<"Work"> | string
    genres?: StringNullableListFilter<"Work">
    originalStatus?: EnumOriginalStatusFilter<"Work"> | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFilter<"Work"> | $Enums.SourceLanguage
    expectedChapters?: IntNullableFilter<"Work"> | number | null
    platformName?: StringNullableFilter<"Work"> | string | null
    platformUrl?: StringNullableFilter<"Work"> | string | null
    publishedAt?: DateTimeNullableFilter<"Work"> | Date | string | null
    totalChapters?: IntFilter<"Work"> | number
    authorId?: StringFilter<"Work"> | string
    editorId?: StringNullableFilter<"Work"> | string | null
    createdAt?: DateTimeFilter<"Work"> | Date | string
    updatedAt?: DateTimeFilter<"Work"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    editor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    chapters?: ChapterListRelationFilter
    glossary?: GlossaryItemListRelationFilter
    creators?: CreatorListRelationFilter
    settingBible?: XOR<SettingBibleNullableRelationFilter, SettingBibleWhereInput> | null
    bibleJobs?: BibleGenerationJobListRelationFilter
    listings?: ProjectListingListRelationFilter
    contracts?: ProjectContractListRelationFilter
    reviews?: EditorReviewListRelationFilter
  }

  export type WorkOrderByWithRelationInput = {
    id?: SortOrder
    titleKo?: SortOrder
    titleOriginal?: SortOrder
    publisher?: SortOrder
    ageRating?: SortOrder
    status?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    synopsis?: SortOrder
    genres?: SortOrder
    originalStatus?: SortOrder
    sourceLanguage?: SortOrder
    expectedChapters?: SortOrderInput | SortOrder
    platformName?: SortOrderInput | SortOrder
    platformUrl?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    totalChapters?: SortOrder
    authorId?: SortOrder
    editorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    editor?: UserOrderByWithRelationInput
    chapters?: ChapterOrderByRelationAggregateInput
    glossary?: GlossaryItemOrderByRelationAggregateInput
    creators?: CreatorOrderByRelationAggregateInput
    settingBible?: SettingBibleOrderByWithRelationInput
    bibleJobs?: BibleGenerationJobOrderByRelationAggregateInput
    listings?: ProjectListingOrderByRelationAggregateInput
    contracts?: ProjectContractOrderByRelationAggregateInput
    reviews?: EditorReviewOrderByRelationAggregateInput
  }

  export type WorkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkWhereInput | WorkWhereInput[]
    OR?: WorkWhereInput[]
    NOT?: WorkWhereInput | WorkWhereInput[]
    titleKo?: StringFilter<"Work"> | string
    titleOriginal?: StringFilter<"Work"> | string
    publisher?: StringFilter<"Work"> | string
    ageRating?: EnumAgeRatingFilter<"Work"> | $Enums.AgeRating
    status?: EnumWorkStatusFilter<"Work"> | $Enums.WorkStatus
    coverImage?: StringNullableFilter<"Work"> | string | null
    synopsis?: StringFilter<"Work"> | string
    genres?: StringNullableListFilter<"Work">
    originalStatus?: EnumOriginalStatusFilter<"Work"> | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFilter<"Work"> | $Enums.SourceLanguage
    expectedChapters?: IntNullableFilter<"Work"> | number | null
    platformName?: StringNullableFilter<"Work"> | string | null
    platformUrl?: StringNullableFilter<"Work"> | string | null
    publishedAt?: DateTimeNullableFilter<"Work"> | Date | string | null
    totalChapters?: IntFilter<"Work"> | number
    authorId?: StringFilter<"Work"> | string
    editorId?: StringNullableFilter<"Work"> | string | null
    createdAt?: DateTimeFilter<"Work"> | Date | string
    updatedAt?: DateTimeFilter<"Work"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    editor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    chapters?: ChapterListRelationFilter
    glossary?: GlossaryItemListRelationFilter
    creators?: CreatorListRelationFilter
    settingBible?: XOR<SettingBibleNullableRelationFilter, SettingBibleWhereInput> | null
    bibleJobs?: BibleGenerationJobListRelationFilter
    listings?: ProjectListingListRelationFilter
    contracts?: ProjectContractListRelationFilter
    reviews?: EditorReviewListRelationFilter
  }, "id">

  export type WorkOrderByWithAggregationInput = {
    id?: SortOrder
    titleKo?: SortOrder
    titleOriginal?: SortOrder
    publisher?: SortOrder
    ageRating?: SortOrder
    status?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    synopsis?: SortOrder
    genres?: SortOrder
    originalStatus?: SortOrder
    sourceLanguage?: SortOrder
    expectedChapters?: SortOrderInput | SortOrder
    platformName?: SortOrderInput | SortOrder
    platformUrl?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    totalChapters?: SortOrder
    authorId?: SortOrder
    editorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkCountOrderByAggregateInput
    _avg?: WorkAvgOrderByAggregateInput
    _max?: WorkMaxOrderByAggregateInput
    _min?: WorkMinOrderByAggregateInput
    _sum?: WorkSumOrderByAggregateInput
  }

  export type WorkScalarWhereWithAggregatesInput = {
    AND?: WorkScalarWhereWithAggregatesInput | WorkScalarWhereWithAggregatesInput[]
    OR?: WorkScalarWhereWithAggregatesInput[]
    NOT?: WorkScalarWhereWithAggregatesInput | WorkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Work"> | string
    titleKo?: StringWithAggregatesFilter<"Work"> | string
    titleOriginal?: StringWithAggregatesFilter<"Work"> | string
    publisher?: StringWithAggregatesFilter<"Work"> | string
    ageRating?: EnumAgeRatingWithAggregatesFilter<"Work"> | $Enums.AgeRating
    status?: EnumWorkStatusWithAggregatesFilter<"Work"> | $Enums.WorkStatus
    coverImage?: StringNullableWithAggregatesFilter<"Work"> | string | null
    synopsis?: StringWithAggregatesFilter<"Work"> | string
    genres?: StringNullableListFilter<"Work">
    originalStatus?: EnumOriginalStatusWithAggregatesFilter<"Work"> | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageWithAggregatesFilter<"Work"> | $Enums.SourceLanguage
    expectedChapters?: IntNullableWithAggregatesFilter<"Work"> | number | null
    platformName?: StringNullableWithAggregatesFilter<"Work"> | string | null
    platformUrl?: StringNullableWithAggregatesFilter<"Work"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Work"> | Date | string | null
    totalChapters?: IntWithAggregatesFilter<"Work"> | number
    authorId?: StringWithAggregatesFilter<"Work"> | string
    editorId?: StringNullableWithAggregatesFilter<"Work"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Work"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Work"> | Date | string
  }

  export type CreatorWhereInput = {
    AND?: CreatorWhereInput | CreatorWhereInput[]
    OR?: CreatorWhereInput[]
    NOT?: CreatorWhereInput | CreatorWhereInput[]
    id?: StringFilter<"Creator"> | string
    name?: StringFilter<"Creator"> | string
    role?: StringFilter<"Creator"> | string
    workId?: StringFilter<"Creator"> | string
    work?: XOR<WorkRelationFilter, WorkWhereInput>
  }

  export type CreatorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    workId?: SortOrder
    work?: WorkOrderByWithRelationInput
  }

  export type CreatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreatorWhereInput | CreatorWhereInput[]
    OR?: CreatorWhereInput[]
    NOT?: CreatorWhereInput | CreatorWhereInput[]
    name?: StringFilter<"Creator"> | string
    role?: StringFilter<"Creator"> | string
    workId?: StringFilter<"Creator"> | string
    work?: XOR<WorkRelationFilter, WorkWhereInput>
  }, "id">

  export type CreatorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    workId?: SortOrder
    _count?: CreatorCountOrderByAggregateInput
    _max?: CreatorMaxOrderByAggregateInput
    _min?: CreatorMinOrderByAggregateInput
  }

  export type CreatorScalarWhereWithAggregatesInput = {
    AND?: CreatorScalarWhereWithAggregatesInput | CreatorScalarWhereWithAggregatesInput[]
    OR?: CreatorScalarWhereWithAggregatesInput[]
    NOT?: CreatorScalarWhereWithAggregatesInput | CreatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Creator"> | string
    name?: StringWithAggregatesFilter<"Creator"> | string
    role?: StringWithAggregatesFilter<"Creator"> | string
    workId?: StringWithAggregatesFilter<"Creator"> | string
  }

  export type ChapterWhereInput = {
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    id?: StringFilter<"Chapter"> | string
    number?: IntFilter<"Chapter"> | number
    title?: StringNullableFilter<"Chapter"> | string | null
    originalContent?: StringFilter<"Chapter"> | string
    translatedContent?: StringNullableFilter<"Chapter"> | string | null
    editedContent?: StringNullableFilter<"Chapter"> | string | null
    status?: EnumChapterStatusFilter<"Chapter"> | $Enums.ChapterStatus
    wordCount?: IntFilter<"Chapter"> | number
    translationMeta?: JsonNullableFilter<"Chapter">
    trackChangesState?: JsonNullableFilter<"Chapter">
    lastEditedById?: StringNullableFilter<"Chapter"> | string | null
    lastEditedAt?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    workId?: StringFilter<"Chapter"> | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
    lastEditedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    work?: XOR<WorkRelationFilter, WorkWhereInput>
    comments?: ChapterCommentListRelationFilter
    snapshots?: ChapterSnapshotListRelationFilter
    changes?: ChapterChangeListRelationFilter
    activities?: ChapterActivityListRelationFilter
    revisionRequests?: ChapterRevisionRequestListRelationFilter
  }

  export type ChapterOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrderInput | SortOrder
    originalContent?: SortOrder
    translatedContent?: SortOrderInput | SortOrder
    editedContent?: SortOrderInput | SortOrder
    status?: SortOrder
    wordCount?: SortOrder
    translationMeta?: SortOrderInput | SortOrder
    trackChangesState?: SortOrderInput | SortOrder
    lastEditedById?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    workId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastEditedBy?: UserOrderByWithRelationInput
    work?: WorkOrderByWithRelationInput
    comments?: ChapterCommentOrderByRelationAggregateInput
    snapshots?: ChapterSnapshotOrderByRelationAggregateInput
    changes?: ChapterChangeOrderByRelationAggregateInput
    activities?: ChapterActivityOrderByRelationAggregateInput
    revisionRequests?: ChapterRevisionRequestOrderByRelationAggregateInput
  }

  export type ChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workId_number?: ChapterWorkIdNumberCompoundUniqueInput
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    number?: IntFilter<"Chapter"> | number
    title?: StringNullableFilter<"Chapter"> | string | null
    originalContent?: StringFilter<"Chapter"> | string
    translatedContent?: StringNullableFilter<"Chapter"> | string | null
    editedContent?: StringNullableFilter<"Chapter"> | string | null
    status?: EnumChapterStatusFilter<"Chapter"> | $Enums.ChapterStatus
    wordCount?: IntFilter<"Chapter"> | number
    translationMeta?: JsonNullableFilter<"Chapter">
    trackChangesState?: JsonNullableFilter<"Chapter">
    lastEditedById?: StringNullableFilter<"Chapter"> | string | null
    lastEditedAt?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    workId?: StringFilter<"Chapter"> | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
    lastEditedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    work?: XOR<WorkRelationFilter, WorkWhereInput>
    comments?: ChapterCommentListRelationFilter
    snapshots?: ChapterSnapshotListRelationFilter
    changes?: ChapterChangeListRelationFilter
    activities?: ChapterActivityListRelationFilter
    revisionRequests?: ChapterRevisionRequestListRelationFilter
  }, "id" | "workId_number">

  export type ChapterOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrderInput | SortOrder
    originalContent?: SortOrder
    translatedContent?: SortOrderInput | SortOrder
    editedContent?: SortOrderInput | SortOrder
    status?: SortOrder
    wordCount?: SortOrder
    translationMeta?: SortOrderInput | SortOrder
    trackChangesState?: SortOrderInput | SortOrder
    lastEditedById?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    workId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChapterCountOrderByAggregateInput
    _avg?: ChapterAvgOrderByAggregateInput
    _max?: ChapterMaxOrderByAggregateInput
    _min?: ChapterMinOrderByAggregateInput
    _sum?: ChapterSumOrderByAggregateInput
  }

  export type ChapterScalarWhereWithAggregatesInput = {
    AND?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    OR?: ChapterScalarWhereWithAggregatesInput[]
    NOT?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chapter"> | string
    number?: IntWithAggregatesFilter<"Chapter"> | number
    title?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    originalContent?: StringWithAggregatesFilter<"Chapter"> | string
    translatedContent?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    editedContent?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    status?: EnumChapterStatusWithAggregatesFilter<"Chapter"> | $Enums.ChapterStatus
    wordCount?: IntWithAggregatesFilter<"Chapter"> | number
    translationMeta?: JsonNullableWithAggregatesFilter<"Chapter">
    trackChangesState?: JsonNullableWithAggregatesFilter<"Chapter">
    lastEditedById?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"Chapter"> | Date | string | null
    workId?: StringWithAggregatesFilter<"Chapter"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
  }

  export type GlossaryItemWhereInput = {
    AND?: GlossaryItemWhereInput | GlossaryItemWhereInput[]
    OR?: GlossaryItemWhereInput[]
    NOT?: GlossaryItemWhereInput | GlossaryItemWhereInput[]
    id?: StringFilter<"GlossaryItem"> | string
    original?: StringFilter<"GlossaryItem"> | string
    translated?: StringFilter<"GlossaryItem"> | string
    category?: StringNullableFilter<"GlossaryItem"> | string | null
    note?: StringNullableFilter<"GlossaryItem"> | string | null
    workId?: StringFilter<"GlossaryItem"> | string
    work?: XOR<WorkRelationFilter, WorkWhereInput>
  }

  export type GlossaryItemOrderByWithRelationInput = {
    id?: SortOrder
    original?: SortOrder
    translated?: SortOrder
    category?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    workId?: SortOrder
    work?: WorkOrderByWithRelationInput
  }

  export type GlossaryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workId_original?: GlossaryItemWorkIdOriginalCompoundUniqueInput
    AND?: GlossaryItemWhereInput | GlossaryItemWhereInput[]
    OR?: GlossaryItemWhereInput[]
    NOT?: GlossaryItemWhereInput | GlossaryItemWhereInput[]
    original?: StringFilter<"GlossaryItem"> | string
    translated?: StringFilter<"GlossaryItem"> | string
    category?: StringNullableFilter<"GlossaryItem"> | string | null
    note?: StringNullableFilter<"GlossaryItem"> | string | null
    workId?: StringFilter<"GlossaryItem"> | string
    work?: XOR<WorkRelationFilter, WorkWhereInput>
  }, "id" | "workId_original">

  export type GlossaryItemOrderByWithAggregationInput = {
    id?: SortOrder
    original?: SortOrder
    translated?: SortOrder
    category?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    workId?: SortOrder
    _count?: GlossaryItemCountOrderByAggregateInput
    _max?: GlossaryItemMaxOrderByAggregateInput
    _min?: GlossaryItemMinOrderByAggregateInput
  }

  export type GlossaryItemScalarWhereWithAggregatesInput = {
    AND?: GlossaryItemScalarWhereWithAggregatesInput | GlossaryItemScalarWhereWithAggregatesInput[]
    OR?: GlossaryItemScalarWhereWithAggregatesInput[]
    NOT?: GlossaryItemScalarWhereWithAggregatesInput | GlossaryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GlossaryItem"> | string
    original?: StringWithAggregatesFilter<"GlossaryItem"> | string
    translated?: StringWithAggregatesFilter<"GlossaryItem"> | string
    category?: StringNullableWithAggregatesFilter<"GlossaryItem"> | string | null
    note?: StringNullableWithAggregatesFilter<"GlossaryItem"> | string | null
    workId?: StringWithAggregatesFilter<"GlossaryItem"> | string
  }

  export type TranslationLogWhereInput = {
    AND?: TranslationLogWhereInput | TranslationLogWhereInput[]
    OR?: TranslationLogWhereInput[]
    NOT?: TranslationLogWhereInput | TranslationLogWhereInput[]
    id?: StringFilter<"TranslationLog"> | string
    level?: EnumLogLevelFilter<"TranslationLog"> | $Enums.LogLevel
    category?: EnumLogCategoryFilter<"TranslationLog"> | $Enums.LogCategory
    jobId?: StringNullableFilter<"TranslationLog"> | string | null
    workId?: StringNullableFilter<"TranslationLog"> | string | null
    chapterId?: StringNullableFilter<"TranslationLog"> | string | null
    chapterNum?: IntNullableFilter<"TranslationLog"> | number | null
    chunkIndex?: IntNullableFilter<"TranslationLog"> | number | null
    userId?: StringNullableFilter<"TranslationLog"> | string | null
    userEmail?: StringNullableFilter<"TranslationLog"> | string | null
    message?: StringFilter<"TranslationLog"> | string
    errorCode?: StringNullableFilter<"TranslationLog"> | string | null
    errorStack?: StringNullableFilter<"TranslationLog"> | string | null
    metadata?: JsonNullableFilter<"TranslationLog">
    durationMs?: IntNullableFilter<"TranslationLog"> | number | null
    retryCount?: IntNullableFilter<"TranslationLog"> | number | null
    clientIp?: StringNullableFilter<"TranslationLog"> | string | null
    userAgent?: StringNullableFilter<"TranslationLog"> | string | null
    createdAt?: DateTimeFilter<"TranslationLog"> | Date | string
  }

  export type TranslationLogOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    jobId?: SortOrderInput | SortOrder
    workId?: SortOrderInput | SortOrder
    chapterId?: SortOrderInput | SortOrder
    chapterNum?: SortOrderInput | SortOrder
    chunkIndex?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    message?: SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    retryCount?: SortOrderInput | SortOrder
    clientIp?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type TranslationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranslationLogWhereInput | TranslationLogWhereInput[]
    OR?: TranslationLogWhereInput[]
    NOT?: TranslationLogWhereInput | TranslationLogWhereInput[]
    level?: EnumLogLevelFilter<"TranslationLog"> | $Enums.LogLevel
    category?: EnumLogCategoryFilter<"TranslationLog"> | $Enums.LogCategory
    jobId?: StringNullableFilter<"TranslationLog"> | string | null
    workId?: StringNullableFilter<"TranslationLog"> | string | null
    chapterId?: StringNullableFilter<"TranslationLog"> | string | null
    chapterNum?: IntNullableFilter<"TranslationLog"> | number | null
    chunkIndex?: IntNullableFilter<"TranslationLog"> | number | null
    userId?: StringNullableFilter<"TranslationLog"> | string | null
    userEmail?: StringNullableFilter<"TranslationLog"> | string | null
    message?: StringFilter<"TranslationLog"> | string
    errorCode?: StringNullableFilter<"TranslationLog"> | string | null
    errorStack?: StringNullableFilter<"TranslationLog"> | string | null
    metadata?: JsonNullableFilter<"TranslationLog">
    durationMs?: IntNullableFilter<"TranslationLog"> | number | null
    retryCount?: IntNullableFilter<"TranslationLog"> | number | null
    clientIp?: StringNullableFilter<"TranslationLog"> | string | null
    userAgent?: StringNullableFilter<"TranslationLog"> | string | null
    createdAt?: DateTimeFilter<"TranslationLog"> | Date | string
  }, "id">

  export type TranslationLogOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    jobId?: SortOrderInput | SortOrder
    workId?: SortOrderInput | SortOrder
    chapterId?: SortOrderInput | SortOrder
    chapterNum?: SortOrderInput | SortOrder
    chunkIndex?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    message?: SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    retryCount?: SortOrderInput | SortOrder
    clientIp?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TranslationLogCountOrderByAggregateInput
    _avg?: TranslationLogAvgOrderByAggregateInput
    _max?: TranslationLogMaxOrderByAggregateInput
    _min?: TranslationLogMinOrderByAggregateInput
    _sum?: TranslationLogSumOrderByAggregateInput
  }

  export type TranslationLogScalarWhereWithAggregatesInput = {
    AND?: TranslationLogScalarWhereWithAggregatesInput | TranslationLogScalarWhereWithAggregatesInput[]
    OR?: TranslationLogScalarWhereWithAggregatesInput[]
    NOT?: TranslationLogScalarWhereWithAggregatesInput | TranslationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TranslationLog"> | string
    level?: EnumLogLevelWithAggregatesFilter<"TranslationLog"> | $Enums.LogLevel
    category?: EnumLogCategoryWithAggregatesFilter<"TranslationLog"> | $Enums.LogCategory
    jobId?: StringNullableWithAggregatesFilter<"TranslationLog"> | string | null
    workId?: StringNullableWithAggregatesFilter<"TranslationLog"> | string | null
    chapterId?: StringNullableWithAggregatesFilter<"TranslationLog"> | string | null
    chapterNum?: IntNullableWithAggregatesFilter<"TranslationLog"> | number | null
    chunkIndex?: IntNullableWithAggregatesFilter<"TranslationLog"> | number | null
    userId?: StringNullableWithAggregatesFilter<"TranslationLog"> | string | null
    userEmail?: StringNullableWithAggregatesFilter<"TranslationLog"> | string | null
    message?: StringWithAggregatesFilter<"TranslationLog"> | string
    errorCode?: StringNullableWithAggregatesFilter<"TranslationLog"> | string | null
    errorStack?: StringNullableWithAggregatesFilter<"TranslationLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"TranslationLog">
    durationMs?: IntNullableWithAggregatesFilter<"TranslationLog"> | number | null
    retryCount?: IntNullableWithAggregatesFilter<"TranslationLog"> | number | null
    clientIp?: StringNullableWithAggregatesFilter<"TranslationLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"TranslationLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TranslationLog"> | Date | string
  }

  export type ActiveTranslationJobWhereInput = {
    AND?: ActiveTranslationJobWhereInput | ActiveTranslationJobWhereInput[]
    OR?: ActiveTranslationJobWhereInput[]
    NOT?: ActiveTranslationJobWhereInput | ActiveTranslationJobWhereInput[]
    id?: StringFilter<"ActiveTranslationJob"> | string
    jobId?: StringFilter<"ActiveTranslationJob"> | string
    workId?: StringFilter<"ActiveTranslationJob"> | string
    workTitle?: StringFilter<"ActiveTranslationJob"> | string
    userId?: StringFilter<"ActiveTranslationJob"> | string
    userEmail?: StringNullableFilter<"ActiveTranslationJob"> | string | null
    status?: StringFilter<"ActiveTranslationJob"> | string
    isPauseRequested?: BoolFilter<"ActiveTranslationJob"> | boolean
    batchPlan?: JsonNullableFilter<"ActiveTranslationJob">
    totalBatches?: IntFilter<"ActiveTranslationJob"> | number
    currentBatchIndex?: IntFilter<"ActiveTranslationJob"> | number
    retryCount?: IntFilter<"ActiveTranslationJob"> | number
    maxRetries?: IntFilter<"ActiveTranslationJob"> | number
    lastError?: StringNullableFilter<"ActiveTranslationJob"> | string | null
    totalChapters?: IntFilter<"ActiveTranslationJob"> | number
    completedChapters?: IntFilter<"ActiveTranslationJob"> | number
    failedChapters?: IntFilter<"ActiveTranslationJob"> | number
    currentChapterNum?: IntNullableFilter<"ActiveTranslationJob"> | number | null
    currentChunkIndex?: IntNullableFilter<"ActiveTranslationJob"> | number | null
    totalChunks?: IntNullableFilter<"ActiveTranslationJob"> | number | null
    chaptersProgress?: JsonNullableFilter<"ActiveTranslationJob">
    failedChapterNums?: IntNullableListFilter<"ActiveTranslationJob">
    autoRetryCount?: IntFilter<"ActiveTranslationJob"> | number
    maxAutoRetries?: IntFilter<"ActiveTranslationJob"> | number
    errorMessage?: StringNullableFilter<"ActiveTranslationJob"> | string | null
    lockedAt?: DateTimeNullableFilter<"ActiveTranslationJob"> | Date | string | null
    lockedBy?: StringNullableFilter<"ActiveTranslationJob"> | string | null
    startedAt?: DateTimeFilter<"ActiveTranslationJob"> | Date | string
    updatedAt?: DateTimeFilter<"ActiveTranslationJob"> | Date | string
    completedAt?: DateTimeNullableFilter<"ActiveTranslationJob"> | Date | string | null
  }

  export type ActiveTranslationJobOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    workTitle?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrderInput | SortOrder
    status?: SortOrder
    isPauseRequested?: SortOrder
    batchPlan?: SortOrderInput | SortOrder
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lastError?: SortOrderInput | SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    currentChapterNum?: SortOrderInput | SortOrder
    currentChunkIndex?: SortOrderInput | SortOrder
    totalChunks?: SortOrderInput | SortOrder
    chaptersProgress?: SortOrderInput | SortOrder
    failedChapterNums?: SortOrder
    autoRetryCount?: SortOrder
    maxAutoRetries?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type ActiveTranslationJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId?: string
    AND?: ActiveTranslationJobWhereInput | ActiveTranslationJobWhereInput[]
    OR?: ActiveTranslationJobWhereInput[]
    NOT?: ActiveTranslationJobWhereInput | ActiveTranslationJobWhereInput[]
    workId?: StringFilter<"ActiveTranslationJob"> | string
    workTitle?: StringFilter<"ActiveTranslationJob"> | string
    userId?: StringFilter<"ActiveTranslationJob"> | string
    userEmail?: StringNullableFilter<"ActiveTranslationJob"> | string | null
    status?: StringFilter<"ActiveTranslationJob"> | string
    isPauseRequested?: BoolFilter<"ActiveTranslationJob"> | boolean
    batchPlan?: JsonNullableFilter<"ActiveTranslationJob">
    totalBatches?: IntFilter<"ActiveTranslationJob"> | number
    currentBatchIndex?: IntFilter<"ActiveTranslationJob"> | number
    retryCount?: IntFilter<"ActiveTranslationJob"> | number
    maxRetries?: IntFilter<"ActiveTranslationJob"> | number
    lastError?: StringNullableFilter<"ActiveTranslationJob"> | string | null
    totalChapters?: IntFilter<"ActiveTranslationJob"> | number
    completedChapters?: IntFilter<"ActiveTranslationJob"> | number
    failedChapters?: IntFilter<"ActiveTranslationJob"> | number
    currentChapterNum?: IntNullableFilter<"ActiveTranslationJob"> | number | null
    currentChunkIndex?: IntNullableFilter<"ActiveTranslationJob"> | number | null
    totalChunks?: IntNullableFilter<"ActiveTranslationJob"> | number | null
    chaptersProgress?: JsonNullableFilter<"ActiveTranslationJob">
    failedChapterNums?: IntNullableListFilter<"ActiveTranslationJob">
    autoRetryCount?: IntFilter<"ActiveTranslationJob"> | number
    maxAutoRetries?: IntFilter<"ActiveTranslationJob"> | number
    errorMessage?: StringNullableFilter<"ActiveTranslationJob"> | string | null
    lockedAt?: DateTimeNullableFilter<"ActiveTranslationJob"> | Date | string | null
    lockedBy?: StringNullableFilter<"ActiveTranslationJob"> | string | null
    startedAt?: DateTimeFilter<"ActiveTranslationJob"> | Date | string
    updatedAt?: DateTimeFilter<"ActiveTranslationJob"> | Date | string
    completedAt?: DateTimeNullableFilter<"ActiveTranslationJob"> | Date | string | null
  }, "id" | "jobId">

  export type ActiveTranslationJobOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    workTitle?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrderInput | SortOrder
    status?: SortOrder
    isPauseRequested?: SortOrder
    batchPlan?: SortOrderInput | SortOrder
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lastError?: SortOrderInput | SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    currentChapterNum?: SortOrderInput | SortOrder
    currentChunkIndex?: SortOrderInput | SortOrder
    totalChunks?: SortOrderInput | SortOrder
    chaptersProgress?: SortOrderInput | SortOrder
    failedChapterNums?: SortOrder
    autoRetryCount?: SortOrder
    maxAutoRetries?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ActiveTranslationJobCountOrderByAggregateInput
    _avg?: ActiveTranslationJobAvgOrderByAggregateInput
    _max?: ActiveTranslationJobMaxOrderByAggregateInput
    _min?: ActiveTranslationJobMinOrderByAggregateInput
    _sum?: ActiveTranslationJobSumOrderByAggregateInput
  }

  export type ActiveTranslationJobScalarWhereWithAggregatesInput = {
    AND?: ActiveTranslationJobScalarWhereWithAggregatesInput | ActiveTranslationJobScalarWhereWithAggregatesInput[]
    OR?: ActiveTranslationJobScalarWhereWithAggregatesInput[]
    NOT?: ActiveTranslationJobScalarWhereWithAggregatesInput | ActiveTranslationJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActiveTranslationJob"> | string
    jobId?: StringWithAggregatesFilter<"ActiveTranslationJob"> | string
    workId?: StringWithAggregatesFilter<"ActiveTranslationJob"> | string
    workTitle?: StringWithAggregatesFilter<"ActiveTranslationJob"> | string
    userId?: StringWithAggregatesFilter<"ActiveTranslationJob"> | string
    userEmail?: StringNullableWithAggregatesFilter<"ActiveTranslationJob"> | string | null
    status?: StringWithAggregatesFilter<"ActiveTranslationJob"> | string
    isPauseRequested?: BoolWithAggregatesFilter<"ActiveTranslationJob"> | boolean
    batchPlan?: JsonNullableWithAggregatesFilter<"ActiveTranslationJob">
    totalBatches?: IntWithAggregatesFilter<"ActiveTranslationJob"> | number
    currentBatchIndex?: IntWithAggregatesFilter<"ActiveTranslationJob"> | number
    retryCount?: IntWithAggregatesFilter<"ActiveTranslationJob"> | number
    maxRetries?: IntWithAggregatesFilter<"ActiveTranslationJob"> | number
    lastError?: StringNullableWithAggregatesFilter<"ActiveTranslationJob"> | string | null
    totalChapters?: IntWithAggregatesFilter<"ActiveTranslationJob"> | number
    completedChapters?: IntWithAggregatesFilter<"ActiveTranslationJob"> | number
    failedChapters?: IntWithAggregatesFilter<"ActiveTranslationJob"> | number
    currentChapterNum?: IntNullableWithAggregatesFilter<"ActiveTranslationJob"> | number | null
    currentChunkIndex?: IntNullableWithAggregatesFilter<"ActiveTranslationJob"> | number | null
    totalChunks?: IntNullableWithAggregatesFilter<"ActiveTranslationJob"> | number | null
    chaptersProgress?: JsonNullableWithAggregatesFilter<"ActiveTranslationJob">
    failedChapterNums?: IntNullableListFilter<"ActiveTranslationJob">
    autoRetryCount?: IntWithAggregatesFilter<"ActiveTranslationJob"> | number
    maxAutoRetries?: IntWithAggregatesFilter<"ActiveTranslationJob"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"ActiveTranslationJob"> | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"ActiveTranslationJob"> | Date | string | null
    lockedBy?: StringNullableWithAggregatesFilter<"ActiveTranslationJob"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"ActiveTranslationJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActiveTranslationJob"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ActiveTranslationJob"> | Date | string | null
  }

  export type TranslationJobHistoryWhereInput = {
    AND?: TranslationJobHistoryWhereInput | TranslationJobHistoryWhereInput[]
    OR?: TranslationJobHistoryWhereInput[]
    NOT?: TranslationJobHistoryWhereInput | TranslationJobHistoryWhereInput[]
    id?: StringFilter<"TranslationJobHistory"> | string
    jobId?: StringFilter<"TranslationJobHistory"> | string
    workId?: StringFilter<"TranslationJobHistory"> | string
    workTitle?: StringFilter<"TranslationJobHistory"> | string
    userId?: StringFilter<"TranslationJobHistory"> | string
    userEmail?: StringNullableFilter<"TranslationJobHistory"> | string | null
    status?: StringFilter<"TranslationJobHistory"> | string
    totalChapters?: IntFilter<"TranslationJobHistory"> | number
    completedChapters?: IntFilter<"TranslationJobHistory"> | number
    failedChapters?: IntFilter<"TranslationJobHistory"> | number
    errorMessage?: StringNullableFilter<"TranslationJobHistory"> | string | null
    failedChapterNums?: IntNullableListFilter<"TranslationJobHistory">
    startedAt?: DateTimeFilter<"TranslationJobHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"TranslationJobHistory"> | Date | string | null
    durationMs?: IntNullableFilter<"TranslationJobHistory"> | number | null
    createdAt?: DateTimeFilter<"TranslationJobHistory"> | Date | string
  }

  export type TranslationJobHistoryOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    workTitle?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrderInput | SortOrder
    status?: SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    failedChapterNums?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type TranslationJobHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId?: string
    AND?: TranslationJobHistoryWhereInput | TranslationJobHistoryWhereInput[]
    OR?: TranslationJobHistoryWhereInput[]
    NOT?: TranslationJobHistoryWhereInput | TranslationJobHistoryWhereInput[]
    workId?: StringFilter<"TranslationJobHistory"> | string
    workTitle?: StringFilter<"TranslationJobHistory"> | string
    userId?: StringFilter<"TranslationJobHistory"> | string
    userEmail?: StringNullableFilter<"TranslationJobHistory"> | string | null
    status?: StringFilter<"TranslationJobHistory"> | string
    totalChapters?: IntFilter<"TranslationJobHistory"> | number
    completedChapters?: IntFilter<"TranslationJobHistory"> | number
    failedChapters?: IntFilter<"TranslationJobHistory"> | number
    errorMessage?: StringNullableFilter<"TranslationJobHistory"> | string | null
    failedChapterNums?: IntNullableListFilter<"TranslationJobHistory">
    startedAt?: DateTimeFilter<"TranslationJobHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"TranslationJobHistory"> | Date | string | null
    durationMs?: IntNullableFilter<"TranslationJobHistory"> | number | null
    createdAt?: DateTimeFilter<"TranslationJobHistory"> | Date | string
  }, "id" | "jobId">

  export type TranslationJobHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    workTitle?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrderInput | SortOrder
    status?: SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    failedChapterNums?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TranslationJobHistoryCountOrderByAggregateInput
    _avg?: TranslationJobHistoryAvgOrderByAggregateInput
    _max?: TranslationJobHistoryMaxOrderByAggregateInput
    _min?: TranslationJobHistoryMinOrderByAggregateInput
    _sum?: TranslationJobHistorySumOrderByAggregateInput
  }

  export type TranslationJobHistoryScalarWhereWithAggregatesInput = {
    AND?: TranslationJobHistoryScalarWhereWithAggregatesInput | TranslationJobHistoryScalarWhereWithAggregatesInput[]
    OR?: TranslationJobHistoryScalarWhereWithAggregatesInput[]
    NOT?: TranslationJobHistoryScalarWhereWithAggregatesInput | TranslationJobHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TranslationJobHistory"> | string
    jobId?: StringWithAggregatesFilter<"TranslationJobHistory"> | string
    workId?: StringWithAggregatesFilter<"TranslationJobHistory"> | string
    workTitle?: StringWithAggregatesFilter<"TranslationJobHistory"> | string
    userId?: StringWithAggregatesFilter<"TranslationJobHistory"> | string
    userEmail?: StringNullableWithAggregatesFilter<"TranslationJobHistory"> | string | null
    status?: StringWithAggregatesFilter<"TranslationJobHistory"> | string
    totalChapters?: IntWithAggregatesFilter<"TranslationJobHistory"> | number
    completedChapters?: IntWithAggregatesFilter<"TranslationJobHistory"> | number
    failedChapters?: IntWithAggregatesFilter<"TranslationJobHistory"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"TranslationJobHistory"> | string | null
    failedChapterNums?: IntNullableListFilter<"TranslationJobHistory">
    startedAt?: DateTimeWithAggregatesFilter<"TranslationJobHistory"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"TranslationJobHistory"> | Date | string | null
    durationMs?: IntNullableWithAggregatesFilter<"TranslationJobHistory"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TranslationJobHistory"> | Date | string
  }

  export type SettingBibleWhereInput = {
    AND?: SettingBibleWhereInput | SettingBibleWhereInput[]
    OR?: SettingBibleWhereInput[]
    NOT?: SettingBibleWhereInput | SettingBibleWhereInput[]
    id?: StringFilter<"SettingBible"> | string
    workId?: StringFilter<"SettingBible"> | string
    status?: EnumBibleStatusFilter<"SettingBible"> | $Enums.BibleStatus
    version?: IntFilter<"SettingBible"> | number
    translationGuide?: StringNullableFilter<"SettingBible"> | string | null
    analyzedChapters?: IntFilter<"SettingBible"> | number
    generatedAt?: DateTimeNullableFilter<"SettingBible"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"SettingBible"> | Date | string | null
    confirmedBy?: StringNullableFilter<"SettingBible"> | string | null
    createdAt?: DateTimeFilter<"SettingBible"> | Date | string
    updatedAt?: DateTimeFilter<"SettingBible"> | Date | string
    work?: XOR<WorkRelationFilter, WorkWhereInput>
    characters?: CharacterListRelationFilter
    terms?: SettingTermListRelationFilter
    events?: TimelineEventListRelationFilter
  }

  export type SettingBibleOrderByWithRelationInput = {
    id?: SortOrder
    workId?: SortOrder
    status?: SortOrder
    version?: SortOrder
    translationGuide?: SortOrderInput | SortOrder
    analyzedChapters?: SortOrder
    generatedAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    work?: WorkOrderByWithRelationInput
    characters?: CharacterOrderByRelationAggregateInput
    terms?: SettingTermOrderByRelationAggregateInput
    events?: TimelineEventOrderByRelationAggregateInput
  }

  export type SettingBibleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workId?: string
    AND?: SettingBibleWhereInput | SettingBibleWhereInput[]
    OR?: SettingBibleWhereInput[]
    NOT?: SettingBibleWhereInput | SettingBibleWhereInput[]
    status?: EnumBibleStatusFilter<"SettingBible"> | $Enums.BibleStatus
    version?: IntFilter<"SettingBible"> | number
    translationGuide?: StringNullableFilter<"SettingBible"> | string | null
    analyzedChapters?: IntFilter<"SettingBible"> | number
    generatedAt?: DateTimeNullableFilter<"SettingBible"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"SettingBible"> | Date | string | null
    confirmedBy?: StringNullableFilter<"SettingBible"> | string | null
    createdAt?: DateTimeFilter<"SettingBible"> | Date | string
    updatedAt?: DateTimeFilter<"SettingBible"> | Date | string
    work?: XOR<WorkRelationFilter, WorkWhereInput>
    characters?: CharacterListRelationFilter
    terms?: SettingTermListRelationFilter
    events?: TimelineEventListRelationFilter
  }, "id" | "workId">

  export type SettingBibleOrderByWithAggregationInput = {
    id?: SortOrder
    workId?: SortOrder
    status?: SortOrder
    version?: SortOrder
    translationGuide?: SortOrderInput | SortOrder
    analyzedChapters?: SortOrder
    generatedAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingBibleCountOrderByAggregateInput
    _avg?: SettingBibleAvgOrderByAggregateInput
    _max?: SettingBibleMaxOrderByAggregateInput
    _min?: SettingBibleMinOrderByAggregateInput
    _sum?: SettingBibleSumOrderByAggregateInput
  }

  export type SettingBibleScalarWhereWithAggregatesInput = {
    AND?: SettingBibleScalarWhereWithAggregatesInput | SettingBibleScalarWhereWithAggregatesInput[]
    OR?: SettingBibleScalarWhereWithAggregatesInput[]
    NOT?: SettingBibleScalarWhereWithAggregatesInput | SettingBibleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SettingBible"> | string
    workId?: StringWithAggregatesFilter<"SettingBible"> | string
    status?: EnumBibleStatusWithAggregatesFilter<"SettingBible"> | $Enums.BibleStatus
    version?: IntWithAggregatesFilter<"SettingBible"> | number
    translationGuide?: StringNullableWithAggregatesFilter<"SettingBible"> | string | null
    analyzedChapters?: IntWithAggregatesFilter<"SettingBible"> | number
    generatedAt?: DateTimeNullableWithAggregatesFilter<"SettingBible"> | Date | string | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"SettingBible"> | Date | string | null
    confirmedBy?: StringNullableWithAggregatesFilter<"SettingBible"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SettingBible"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SettingBible"> | Date | string
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    id?: StringFilter<"Character"> | string
    bibleId?: StringFilter<"Character"> | string
    nameOriginal?: StringFilter<"Character"> | string
    nameKorean?: StringFilter<"Character"> | string
    nameHanja?: StringNullableFilter<"Character"> | string | null
    titles?: StringNullableListFilter<"Character">
    aliases?: StringNullableListFilter<"Character">
    personality?: StringNullableFilter<"Character"> | string | null
    speechStyle?: StringNullableFilter<"Character"> | string | null
    role?: EnumCharacterRoleFilter<"Character"> | $Enums.CharacterRole
    description?: StringNullableFilter<"Character"> | string | null
    relationships?: JsonNullableFilter<"Character">
    firstAppearance?: IntNullableFilter<"Character"> | number | null
    sortOrder?: IntFilter<"Character"> | number
    isConfirmed?: BoolFilter<"Character"> | boolean
    bible?: XOR<SettingBibleRelationFilter, SettingBibleWhereInput>
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    bibleId?: SortOrder
    nameOriginal?: SortOrder
    nameKorean?: SortOrder
    nameHanja?: SortOrderInput | SortOrder
    titles?: SortOrder
    aliases?: SortOrder
    personality?: SortOrderInput | SortOrder
    speechStyle?: SortOrderInput | SortOrder
    role?: SortOrder
    description?: SortOrderInput | SortOrder
    relationships?: SortOrderInput | SortOrder
    firstAppearance?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isConfirmed?: SortOrder
    bible?: SettingBibleOrderByWithRelationInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bibleId_nameOriginal?: CharacterBibleIdNameOriginalCompoundUniqueInput
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    bibleId?: StringFilter<"Character"> | string
    nameOriginal?: StringFilter<"Character"> | string
    nameKorean?: StringFilter<"Character"> | string
    nameHanja?: StringNullableFilter<"Character"> | string | null
    titles?: StringNullableListFilter<"Character">
    aliases?: StringNullableListFilter<"Character">
    personality?: StringNullableFilter<"Character"> | string | null
    speechStyle?: StringNullableFilter<"Character"> | string | null
    role?: EnumCharacterRoleFilter<"Character"> | $Enums.CharacterRole
    description?: StringNullableFilter<"Character"> | string | null
    relationships?: JsonNullableFilter<"Character">
    firstAppearance?: IntNullableFilter<"Character"> | number | null
    sortOrder?: IntFilter<"Character"> | number
    isConfirmed?: BoolFilter<"Character"> | boolean
    bible?: XOR<SettingBibleRelationFilter, SettingBibleWhereInput>
  }, "id" | "bibleId_nameOriginal">

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    bibleId?: SortOrder
    nameOriginal?: SortOrder
    nameKorean?: SortOrder
    nameHanja?: SortOrderInput | SortOrder
    titles?: SortOrder
    aliases?: SortOrder
    personality?: SortOrderInput | SortOrder
    speechStyle?: SortOrderInput | SortOrder
    role?: SortOrder
    description?: SortOrderInput | SortOrder
    relationships?: SortOrderInput | SortOrder
    firstAppearance?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isConfirmed?: SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Character"> | string
    bibleId?: StringWithAggregatesFilter<"Character"> | string
    nameOriginal?: StringWithAggregatesFilter<"Character"> | string
    nameKorean?: StringWithAggregatesFilter<"Character"> | string
    nameHanja?: StringNullableWithAggregatesFilter<"Character"> | string | null
    titles?: StringNullableListFilter<"Character">
    aliases?: StringNullableListFilter<"Character">
    personality?: StringNullableWithAggregatesFilter<"Character"> | string | null
    speechStyle?: StringNullableWithAggregatesFilter<"Character"> | string | null
    role?: EnumCharacterRoleWithAggregatesFilter<"Character"> | $Enums.CharacterRole
    description?: StringNullableWithAggregatesFilter<"Character"> | string | null
    relationships?: JsonNullableWithAggregatesFilter<"Character">
    firstAppearance?: IntNullableWithAggregatesFilter<"Character"> | number | null
    sortOrder?: IntWithAggregatesFilter<"Character"> | number
    isConfirmed?: BoolWithAggregatesFilter<"Character"> | boolean
  }

  export type SettingTermWhereInput = {
    AND?: SettingTermWhereInput | SettingTermWhereInput[]
    OR?: SettingTermWhereInput[]
    NOT?: SettingTermWhereInput | SettingTermWhereInput[]
    id?: StringFilter<"SettingTerm"> | string
    bibleId?: StringFilter<"SettingTerm"> | string
    original?: StringFilter<"SettingTerm"> | string
    translated?: StringFilter<"SettingTerm"> | string
    category?: EnumTermCategoryFilter<"SettingTerm"> | $Enums.TermCategory
    note?: StringNullableFilter<"SettingTerm"> | string | null
    context?: StringNullableFilter<"SettingTerm"> | string | null
    firstAppearance?: IntNullableFilter<"SettingTerm"> | number | null
    frequency?: IntFilter<"SettingTerm"> | number
    isConfirmed?: BoolFilter<"SettingTerm"> | boolean
    bible?: XOR<SettingBibleRelationFilter, SettingBibleWhereInput>
  }

  export type SettingTermOrderByWithRelationInput = {
    id?: SortOrder
    bibleId?: SortOrder
    original?: SortOrder
    translated?: SortOrder
    category?: SortOrder
    note?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    firstAppearance?: SortOrderInput | SortOrder
    frequency?: SortOrder
    isConfirmed?: SortOrder
    bible?: SettingBibleOrderByWithRelationInput
  }

  export type SettingTermWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bibleId_original?: SettingTermBibleIdOriginalCompoundUniqueInput
    AND?: SettingTermWhereInput | SettingTermWhereInput[]
    OR?: SettingTermWhereInput[]
    NOT?: SettingTermWhereInput | SettingTermWhereInput[]
    bibleId?: StringFilter<"SettingTerm"> | string
    original?: StringFilter<"SettingTerm"> | string
    translated?: StringFilter<"SettingTerm"> | string
    category?: EnumTermCategoryFilter<"SettingTerm"> | $Enums.TermCategory
    note?: StringNullableFilter<"SettingTerm"> | string | null
    context?: StringNullableFilter<"SettingTerm"> | string | null
    firstAppearance?: IntNullableFilter<"SettingTerm"> | number | null
    frequency?: IntFilter<"SettingTerm"> | number
    isConfirmed?: BoolFilter<"SettingTerm"> | boolean
    bible?: XOR<SettingBibleRelationFilter, SettingBibleWhereInput>
  }, "id" | "bibleId_original">

  export type SettingTermOrderByWithAggregationInput = {
    id?: SortOrder
    bibleId?: SortOrder
    original?: SortOrder
    translated?: SortOrder
    category?: SortOrder
    note?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    firstAppearance?: SortOrderInput | SortOrder
    frequency?: SortOrder
    isConfirmed?: SortOrder
    _count?: SettingTermCountOrderByAggregateInput
    _avg?: SettingTermAvgOrderByAggregateInput
    _max?: SettingTermMaxOrderByAggregateInput
    _min?: SettingTermMinOrderByAggregateInput
    _sum?: SettingTermSumOrderByAggregateInput
  }

  export type SettingTermScalarWhereWithAggregatesInput = {
    AND?: SettingTermScalarWhereWithAggregatesInput | SettingTermScalarWhereWithAggregatesInput[]
    OR?: SettingTermScalarWhereWithAggregatesInput[]
    NOT?: SettingTermScalarWhereWithAggregatesInput | SettingTermScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SettingTerm"> | string
    bibleId?: StringWithAggregatesFilter<"SettingTerm"> | string
    original?: StringWithAggregatesFilter<"SettingTerm"> | string
    translated?: StringWithAggregatesFilter<"SettingTerm"> | string
    category?: EnumTermCategoryWithAggregatesFilter<"SettingTerm"> | $Enums.TermCategory
    note?: StringNullableWithAggregatesFilter<"SettingTerm"> | string | null
    context?: StringNullableWithAggregatesFilter<"SettingTerm"> | string | null
    firstAppearance?: IntNullableWithAggregatesFilter<"SettingTerm"> | number | null
    frequency?: IntWithAggregatesFilter<"SettingTerm"> | number
    isConfirmed?: BoolWithAggregatesFilter<"SettingTerm"> | boolean
  }

  export type TimelineEventWhereInput = {
    AND?: TimelineEventWhereInput | TimelineEventWhereInput[]
    OR?: TimelineEventWhereInput[]
    NOT?: TimelineEventWhereInput | TimelineEventWhereInput[]
    id?: StringFilter<"TimelineEvent"> | string
    bibleId?: StringFilter<"TimelineEvent"> | string
    title?: StringFilter<"TimelineEvent"> | string
    description?: StringFilter<"TimelineEvent"> | string
    chapterStart?: IntFilter<"TimelineEvent"> | number
    chapterEnd?: IntNullableFilter<"TimelineEvent"> | number | null
    eventType?: EnumEventTypeFilter<"TimelineEvent"> | $Enums.EventType
    importance?: IntFilter<"TimelineEvent"> | number
    isForeshadowing?: BoolFilter<"TimelineEvent"> | boolean
    foreshadowNote?: StringNullableFilter<"TimelineEvent"> | string | null
    involvedCharacterIds?: StringNullableListFilter<"TimelineEvent">
    bible?: XOR<SettingBibleRelationFilter, SettingBibleWhereInput>
  }

  export type TimelineEventOrderByWithRelationInput = {
    id?: SortOrder
    bibleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrderInput | SortOrder
    eventType?: SortOrder
    importance?: SortOrder
    isForeshadowing?: SortOrder
    foreshadowNote?: SortOrderInput | SortOrder
    involvedCharacterIds?: SortOrder
    bible?: SettingBibleOrderByWithRelationInput
  }

  export type TimelineEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bibleId_title_chapterStart?: TimelineEventBibleIdTitleChapterStartCompoundUniqueInput
    AND?: TimelineEventWhereInput | TimelineEventWhereInput[]
    OR?: TimelineEventWhereInput[]
    NOT?: TimelineEventWhereInput | TimelineEventWhereInput[]
    bibleId?: StringFilter<"TimelineEvent"> | string
    title?: StringFilter<"TimelineEvent"> | string
    description?: StringFilter<"TimelineEvent"> | string
    chapterStart?: IntFilter<"TimelineEvent"> | number
    chapterEnd?: IntNullableFilter<"TimelineEvent"> | number | null
    eventType?: EnumEventTypeFilter<"TimelineEvent"> | $Enums.EventType
    importance?: IntFilter<"TimelineEvent"> | number
    isForeshadowing?: BoolFilter<"TimelineEvent"> | boolean
    foreshadowNote?: StringNullableFilter<"TimelineEvent"> | string | null
    involvedCharacterIds?: StringNullableListFilter<"TimelineEvent">
    bible?: XOR<SettingBibleRelationFilter, SettingBibleWhereInput>
  }, "id" | "bibleId_title_chapterStart">

  export type TimelineEventOrderByWithAggregationInput = {
    id?: SortOrder
    bibleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrderInput | SortOrder
    eventType?: SortOrder
    importance?: SortOrder
    isForeshadowing?: SortOrder
    foreshadowNote?: SortOrderInput | SortOrder
    involvedCharacterIds?: SortOrder
    _count?: TimelineEventCountOrderByAggregateInput
    _avg?: TimelineEventAvgOrderByAggregateInput
    _max?: TimelineEventMaxOrderByAggregateInput
    _min?: TimelineEventMinOrderByAggregateInput
    _sum?: TimelineEventSumOrderByAggregateInput
  }

  export type TimelineEventScalarWhereWithAggregatesInput = {
    AND?: TimelineEventScalarWhereWithAggregatesInput | TimelineEventScalarWhereWithAggregatesInput[]
    OR?: TimelineEventScalarWhereWithAggregatesInput[]
    NOT?: TimelineEventScalarWhereWithAggregatesInput | TimelineEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimelineEvent"> | string
    bibleId?: StringWithAggregatesFilter<"TimelineEvent"> | string
    title?: StringWithAggregatesFilter<"TimelineEvent"> | string
    description?: StringWithAggregatesFilter<"TimelineEvent"> | string
    chapterStart?: IntWithAggregatesFilter<"TimelineEvent"> | number
    chapterEnd?: IntNullableWithAggregatesFilter<"TimelineEvent"> | number | null
    eventType?: EnumEventTypeWithAggregatesFilter<"TimelineEvent"> | $Enums.EventType
    importance?: IntWithAggregatesFilter<"TimelineEvent"> | number
    isForeshadowing?: BoolWithAggregatesFilter<"TimelineEvent"> | boolean
    foreshadowNote?: StringNullableWithAggregatesFilter<"TimelineEvent"> | string | null
    involvedCharacterIds?: StringNullableListFilter<"TimelineEvent">
  }

  export type BibleGenerationJobWhereInput = {
    AND?: BibleGenerationJobWhereInput | BibleGenerationJobWhereInput[]
    OR?: BibleGenerationJobWhereInput[]
    NOT?: BibleGenerationJobWhereInput | BibleGenerationJobWhereInput[]
    id?: StringFilter<"BibleGenerationJob"> | string
    workId?: StringFilter<"BibleGenerationJob"> | string
    userId?: StringFilter<"BibleGenerationJob"> | string
    status?: EnumBibleJobStatusFilter<"BibleGenerationJob"> | $Enums.BibleJobStatus
    batchPlan?: JsonFilter<"BibleGenerationJob">
    totalBatches?: IntFilter<"BibleGenerationJob"> | number
    currentBatchIndex?: IntFilter<"BibleGenerationJob"> | number
    analyzedChapters?: IntFilter<"BibleGenerationJob"> | number
    retryCount?: IntFilter<"BibleGenerationJob"> | number
    maxRetries?: IntFilter<"BibleGenerationJob"> | number
    errorMessage?: StringNullableFilter<"BibleGenerationJob"> | string | null
    lastError?: StringNullableFilter<"BibleGenerationJob"> | string | null
    createdAt?: DateTimeFilter<"BibleGenerationJob"> | Date | string
    updatedAt?: DateTimeFilter<"BibleGenerationJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"BibleGenerationJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"BibleGenerationJob"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"BibleGenerationJob"> | Date | string | null
    lockedBy?: StringNullableFilter<"BibleGenerationJob"> | string | null
    work?: XOR<WorkRelationFilter, WorkWhereInput>
  }

  export type BibleGenerationJobOrderByWithRelationInput = {
    id?: SortOrder
    workId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    batchPlan?: SortOrder
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    analyzedChapters?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    work?: WorkOrderByWithRelationInput
  }

  export type BibleGenerationJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BibleGenerationJobWhereInput | BibleGenerationJobWhereInput[]
    OR?: BibleGenerationJobWhereInput[]
    NOT?: BibleGenerationJobWhereInput | BibleGenerationJobWhereInput[]
    workId?: StringFilter<"BibleGenerationJob"> | string
    userId?: StringFilter<"BibleGenerationJob"> | string
    status?: EnumBibleJobStatusFilter<"BibleGenerationJob"> | $Enums.BibleJobStatus
    batchPlan?: JsonFilter<"BibleGenerationJob">
    totalBatches?: IntFilter<"BibleGenerationJob"> | number
    currentBatchIndex?: IntFilter<"BibleGenerationJob"> | number
    analyzedChapters?: IntFilter<"BibleGenerationJob"> | number
    retryCount?: IntFilter<"BibleGenerationJob"> | number
    maxRetries?: IntFilter<"BibleGenerationJob"> | number
    errorMessage?: StringNullableFilter<"BibleGenerationJob"> | string | null
    lastError?: StringNullableFilter<"BibleGenerationJob"> | string | null
    createdAt?: DateTimeFilter<"BibleGenerationJob"> | Date | string
    updatedAt?: DateTimeFilter<"BibleGenerationJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"BibleGenerationJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"BibleGenerationJob"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"BibleGenerationJob"> | Date | string | null
    lockedBy?: StringNullableFilter<"BibleGenerationJob"> | string | null
    work?: XOR<WorkRelationFilter, WorkWhereInput>
  }, "id">

  export type BibleGenerationJobOrderByWithAggregationInput = {
    id?: SortOrder
    workId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    batchPlan?: SortOrder
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    analyzedChapters?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    _count?: BibleGenerationJobCountOrderByAggregateInput
    _avg?: BibleGenerationJobAvgOrderByAggregateInput
    _max?: BibleGenerationJobMaxOrderByAggregateInput
    _min?: BibleGenerationJobMinOrderByAggregateInput
    _sum?: BibleGenerationJobSumOrderByAggregateInput
  }

  export type BibleGenerationJobScalarWhereWithAggregatesInput = {
    AND?: BibleGenerationJobScalarWhereWithAggregatesInput | BibleGenerationJobScalarWhereWithAggregatesInput[]
    OR?: BibleGenerationJobScalarWhereWithAggregatesInput[]
    NOT?: BibleGenerationJobScalarWhereWithAggregatesInput | BibleGenerationJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BibleGenerationJob"> | string
    workId?: StringWithAggregatesFilter<"BibleGenerationJob"> | string
    userId?: StringWithAggregatesFilter<"BibleGenerationJob"> | string
    status?: EnumBibleJobStatusWithAggregatesFilter<"BibleGenerationJob"> | $Enums.BibleJobStatus
    batchPlan?: JsonWithAggregatesFilter<"BibleGenerationJob">
    totalBatches?: IntWithAggregatesFilter<"BibleGenerationJob"> | number
    currentBatchIndex?: IntWithAggregatesFilter<"BibleGenerationJob"> | number
    analyzedChapters?: IntWithAggregatesFilter<"BibleGenerationJob"> | number
    retryCount?: IntWithAggregatesFilter<"BibleGenerationJob"> | number
    maxRetries?: IntWithAggregatesFilter<"BibleGenerationJob"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"BibleGenerationJob"> | string | null
    lastError?: StringNullableWithAggregatesFilter<"BibleGenerationJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BibleGenerationJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BibleGenerationJob"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"BibleGenerationJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"BibleGenerationJob"> | Date | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"BibleGenerationJob"> | Date | string | null
    lockedBy?: StringNullableWithAggregatesFilter<"BibleGenerationJob"> | string | null
  }

  export type ChapterCommentWhereInput = {
    AND?: ChapterCommentWhereInput | ChapterCommentWhereInput[]
    OR?: ChapterCommentWhereInput[]
    NOT?: ChapterCommentWhereInput | ChapterCommentWhereInput[]
    id?: StringFilter<"ChapterComment"> | string
    chapterId?: StringFilter<"ChapterComment"> | string
    authorId?: StringFilter<"ChapterComment"> | string
    parentId?: StringNullableFilter<"ChapterComment"> | string | null
    content?: StringFilter<"ChapterComment"> | string
    textRange?: JsonNullableFilter<"ChapterComment">
    quotedText?: StringNullableFilter<"ChapterComment"> | string | null
    isResolved?: BoolFilter<"ChapterComment"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ChapterComment"> | Date | string | null
    resolvedById?: StringNullableFilter<"ChapterComment"> | string | null
    createdAt?: DateTimeFilter<"ChapterComment"> | Date | string
    updatedAt?: DateTimeFilter<"ChapterComment"> | Date | string
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<ChapterCommentNullableRelationFilter, ChapterCommentWhereInput> | null
    replies?: ChapterCommentListRelationFilter
    resolvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ChapterCommentOrderByWithRelationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    content?: SortOrder
    textRange?: SortOrderInput | SortOrder
    quotedText?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    parent?: ChapterCommentOrderByWithRelationInput
    replies?: ChapterCommentOrderByRelationAggregateInput
    resolvedBy?: UserOrderByWithRelationInput
  }

  export type ChapterCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChapterCommentWhereInput | ChapterCommentWhereInput[]
    OR?: ChapterCommentWhereInput[]
    NOT?: ChapterCommentWhereInput | ChapterCommentWhereInput[]
    chapterId?: StringFilter<"ChapterComment"> | string
    authorId?: StringFilter<"ChapterComment"> | string
    parentId?: StringNullableFilter<"ChapterComment"> | string | null
    content?: StringFilter<"ChapterComment"> | string
    textRange?: JsonNullableFilter<"ChapterComment">
    quotedText?: StringNullableFilter<"ChapterComment"> | string | null
    isResolved?: BoolFilter<"ChapterComment"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ChapterComment"> | Date | string | null
    resolvedById?: StringNullableFilter<"ChapterComment"> | string | null
    createdAt?: DateTimeFilter<"ChapterComment"> | Date | string
    updatedAt?: DateTimeFilter<"ChapterComment"> | Date | string
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<ChapterCommentNullableRelationFilter, ChapterCommentWhereInput> | null
    replies?: ChapterCommentListRelationFilter
    resolvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ChapterCommentOrderByWithAggregationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    content?: SortOrder
    textRange?: SortOrderInput | SortOrder
    quotedText?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChapterCommentCountOrderByAggregateInput
    _max?: ChapterCommentMaxOrderByAggregateInput
    _min?: ChapterCommentMinOrderByAggregateInput
  }

  export type ChapterCommentScalarWhereWithAggregatesInput = {
    AND?: ChapterCommentScalarWhereWithAggregatesInput | ChapterCommentScalarWhereWithAggregatesInput[]
    OR?: ChapterCommentScalarWhereWithAggregatesInput[]
    NOT?: ChapterCommentScalarWhereWithAggregatesInput | ChapterCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChapterComment"> | string
    chapterId?: StringWithAggregatesFilter<"ChapterComment"> | string
    authorId?: StringWithAggregatesFilter<"ChapterComment"> | string
    parentId?: StringNullableWithAggregatesFilter<"ChapterComment"> | string | null
    content?: StringWithAggregatesFilter<"ChapterComment"> | string
    textRange?: JsonNullableWithAggregatesFilter<"ChapterComment">
    quotedText?: StringNullableWithAggregatesFilter<"ChapterComment"> | string | null
    isResolved?: BoolWithAggregatesFilter<"ChapterComment"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"ChapterComment"> | Date | string | null
    resolvedById?: StringNullableWithAggregatesFilter<"ChapterComment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChapterComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChapterComment"> | Date | string
  }

  export type ChapterSnapshotWhereInput = {
    AND?: ChapterSnapshotWhereInput | ChapterSnapshotWhereInput[]
    OR?: ChapterSnapshotWhereInput[]
    NOT?: ChapterSnapshotWhereInput | ChapterSnapshotWhereInput[]
    id?: StringFilter<"ChapterSnapshot"> | string
    chapterId?: StringFilter<"ChapterSnapshot"> | string
    authorId?: StringFilter<"ChapterSnapshot"> | string
    name?: StringNullableFilter<"ChapterSnapshot"> | string | null
    description?: StringNullableFilter<"ChapterSnapshot"> | string | null
    snapshotType?: EnumSnapshotTypeFilter<"ChapterSnapshot"> | $Enums.SnapshotType
    originalContent?: StringFilter<"ChapterSnapshot"> | string
    translatedContent?: StringNullableFilter<"ChapterSnapshot"> | string | null
    editedContent?: StringNullableFilter<"ChapterSnapshot"> | string | null
    status?: EnumChapterStatusFilter<"ChapterSnapshot"> | $Enums.ChapterStatus
    triggerEvent?: StringNullableFilter<"ChapterSnapshot"> | string | null
    createdAt?: DateTimeFilter<"ChapterSnapshot"> | Date | string
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChapterSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    snapshotType?: SortOrder
    originalContent?: SortOrder
    translatedContent?: SortOrderInput | SortOrder
    editedContent?: SortOrderInput | SortOrder
    status?: SortOrder
    triggerEvent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type ChapterSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChapterSnapshotWhereInput | ChapterSnapshotWhereInput[]
    OR?: ChapterSnapshotWhereInput[]
    NOT?: ChapterSnapshotWhereInput | ChapterSnapshotWhereInput[]
    chapterId?: StringFilter<"ChapterSnapshot"> | string
    authorId?: StringFilter<"ChapterSnapshot"> | string
    name?: StringNullableFilter<"ChapterSnapshot"> | string | null
    description?: StringNullableFilter<"ChapterSnapshot"> | string | null
    snapshotType?: EnumSnapshotTypeFilter<"ChapterSnapshot"> | $Enums.SnapshotType
    originalContent?: StringFilter<"ChapterSnapshot"> | string
    translatedContent?: StringNullableFilter<"ChapterSnapshot"> | string | null
    editedContent?: StringNullableFilter<"ChapterSnapshot"> | string | null
    status?: EnumChapterStatusFilter<"ChapterSnapshot"> | $Enums.ChapterStatus
    triggerEvent?: StringNullableFilter<"ChapterSnapshot"> | string | null
    createdAt?: DateTimeFilter<"ChapterSnapshot"> | Date | string
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChapterSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    snapshotType?: SortOrder
    originalContent?: SortOrder
    translatedContent?: SortOrderInput | SortOrder
    editedContent?: SortOrderInput | SortOrder
    status?: SortOrder
    triggerEvent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChapterSnapshotCountOrderByAggregateInput
    _max?: ChapterSnapshotMaxOrderByAggregateInput
    _min?: ChapterSnapshotMinOrderByAggregateInput
  }

  export type ChapterSnapshotScalarWhereWithAggregatesInput = {
    AND?: ChapterSnapshotScalarWhereWithAggregatesInput | ChapterSnapshotScalarWhereWithAggregatesInput[]
    OR?: ChapterSnapshotScalarWhereWithAggregatesInput[]
    NOT?: ChapterSnapshotScalarWhereWithAggregatesInput | ChapterSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChapterSnapshot"> | string
    chapterId?: StringWithAggregatesFilter<"ChapterSnapshot"> | string
    authorId?: StringWithAggregatesFilter<"ChapterSnapshot"> | string
    name?: StringNullableWithAggregatesFilter<"ChapterSnapshot"> | string | null
    description?: StringNullableWithAggregatesFilter<"ChapterSnapshot"> | string | null
    snapshotType?: EnumSnapshotTypeWithAggregatesFilter<"ChapterSnapshot"> | $Enums.SnapshotType
    originalContent?: StringWithAggregatesFilter<"ChapterSnapshot"> | string
    translatedContent?: StringNullableWithAggregatesFilter<"ChapterSnapshot"> | string | null
    editedContent?: StringNullableWithAggregatesFilter<"ChapterSnapshot"> | string | null
    status?: EnumChapterStatusWithAggregatesFilter<"ChapterSnapshot"> | $Enums.ChapterStatus
    triggerEvent?: StringNullableWithAggregatesFilter<"ChapterSnapshot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChapterSnapshot"> | Date | string
  }

  export type ChapterChangeWhereInput = {
    AND?: ChapterChangeWhereInput | ChapterChangeWhereInput[]
    OR?: ChapterChangeWhereInput[]
    NOT?: ChapterChangeWhereInput | ChapterChangeWhereInput[]
    id?: StringFilter<"ChapterChange"> | string
    chapterId?: StringFilter<"ChapterChange"> | string
    authorId?: StringFilter<"ChapterChange"> | string
    changeType?: EnumChangeTypeFilter<"ChapterChange"> | $Enums.ChangeType
    fromPos?: IntFilter<"ChapterChange"> | number
    toPos?: IntFilter<"ChapterChange"> | number
    oldText?: StringNullableFilter<"ChapterChange"> | string | null
    newText?: StringNullableFilter<"ChapterChange"> | string | null
    status?: EnumChangeStatusFilter<"ChapterChange"> | $Enums.ChangeStatus
    reviewedById?: StringNullableFilter<"ChapterChange"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ChapterChange"> | Date | string | null
    createdAt?: DateTimeFilter<"ChapterChange"> | Date | string
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    reviewedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ChapterChangeOrderByWithRelationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    changeType?: SortOrder
    fromPos?: SortOrder
    toPos?: SortOrder
    oldText?: SortOrderInput | SortOrder
    newText?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    reviewedBy?: UserOrderByWithRelationInput
  }

  export type ChapterChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChapterChangeWhereInput | ChapterChangeWhereInput[]
    OR?: ChapterChangeWhereInput[]
    NOT?: ChapterChangeWhereInput | ChapterChangeWhereInput[]
    chapterId?: StringFilter<"ChapterChange"> | string
    authorId?: StringFilter<"ChapterChange"> | string
    changeType?: EnumChangeTypeFilter<"ChapterChange"> | $Enums.ChangeType
    fromPos?: IntFilter<"ChapterChange"> | number
    toPos?: IntFilter<"ChapterChange"> | number
    oldText?: StringNullableFilter<"ChapterChange"> | string | null
    newText?: StringNullableFilter<"ChapterChange"> | string | null
    status?: EnumChangeStatusFilter<"ChapterChange"> | $Enums.ChangeStatus
    reviewedById?: StringNullableFilter<"ChapterChange"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ChapterChange"> | Date | string | null
    createdAt?: DateTimeFilter<"ChapterChange"> | Date | string
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    reviewedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ChapterChangeOrderByWithAggregationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    changeType?: SortOrder
    fromPos?: SortOrder
    toPos?: SortOrder
    oldText?: SortOrderInput | SortOrder
    newText?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChapterChangeCountOrderByAggregateInput
    _avg?: ChapterChangeAvgOrderByAggregateInput
    _max?: ChapterChangeMaxOrderByAggregateInput
    _min?: ChapterChangeMinOrderByAggregateInput
    _sum?: ChapterChangeSumOrderByAggregateInput
  }

  export type ChapterChangeScalarWhereWithAggregatesInput = {
    AND?: ChapterChangeScalarWhereWithAggregatesInput | ChapterChangeScalarWhereWithAggregatesInput[]
    OR?: ChapterChangeScalarWhereWithAggregatesInput[]
    NOT?: ChapterChangeScalarWhereWithAggregatesInput | ChapterChangeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChapterChange"> | string
    chapterId?: StringWithAggregatesFilter<"ChapterChange"> | string
    authorId?: StringWithAggregatesFilter<"ChapterChange"> | string
    changeType?: EnumChangeTypeWithAggregatesFilter<"ChapterChange"> | $Enums.ChangeType
    fromPos?: IntWithAggregatesFilter<"ChapterChange"> | number
    toPos?: IntWithAggregatesFilter<"ChapterChange"> | number
    oldText?: StringNullableWithAggregatesFilter<"ChapterChange"> | string | null
    newText?: StringNullableWithAggregatesFilter<"ChapterChange"> | string | null
    status?: EnumChangeStatusWithAggregatesFilter<"ChapterChange"> | $Enums.ChangeStatus
    reviewedById?: StringNullableWithAggregatesFilter<"ChapterChange"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ChapterChange"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChapterChange"> | Date | string
  }

  export type ChapterActivityWhereInput = {
    AND?: ChapterActivityWhereInput | ChapterActivityWhereInput[]
    OR?: ChapterActivityWhereInput[]
    NOT?: ChapterActivityWhereInput | ChapterActivityWhereInput[]
    id?: StringFilter<"ChapterActivity"> | string
    chapterId?: StringFilter<"ChapterActivity"> | string
    actorId?: StringFilter<"ChapterActivity"> | string
    activityType?: EnumActivityTypeFilter<"ChapterActivity"> | $Enums.ActivityType
    metadata?: JsonNullableFilter<"ChapterActivity">
    summary?: StringFilter<"ChapterActivity"> | string
    createdAt?: DateTimeFilter<"ChapterActivity"> | Date | string
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
    actor?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChapterActivityOrderByWithRelationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    actorId?: SortOrder
    activityType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
    actor?: UserOrderByWithRelationInput
  }

  export type ChapterActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChapterActivityWhereInput | ChapterActivityWhereInput[]
    OR?: ChapterActivityWhereInput[]
    NOT?: ChapterActivityWhereInput | ChapterActivityWhereInput[]
    chapterId?: StringFilter<"ChapterActivity"> | string
    actorId?: StringFilter<"ChapterActivity"> | string
    activityType?: EnumActivityTypeFilter<"ChapterActivity"> | $Enums.ActivityType
    metadata?: JsonNullableFilter<"ChapterActivity">
    summary?: StringFilter<"ChapterActivity"> | string
    createdAt?: DateTimeFilter<"ChapterActivity"> | Date | string
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
    actor?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChapterActivityOrderByWithAggregationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    actorId?: SortOrder
    activityType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    _count?: ChapterActivityCountOrderByAggregateInput
    _max?: ChapterActivityMaxOrderByAggregateInput
    _min?: ChapterActivityMinOrderByAggregateInput
  }

  export type ChapterActivityScalarWhereWithAggregatesInput = {
    AND?: ChapterActivityScalarWhereWithAggregatesInput | ChapterActivityScalarWhereWithAggregatesInput[]
    OR?: ChapterActivityScalarWhereWithAggregatesInput[]
    NOT?: ChapterActivityScalarWhereWithAggregatesInput | ChapterActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChapterActivity"> | string
    chapterId?: StringWithAggregatesFilter<"ChapterActivity"> | string
    actorId?: StringWithAggregatesFilter<"ChapterActivity"> | string
    activityType?: EnumActivityTypeWithAggregatesFilter<"ChapterActivity"> | $Enums.ActivityType
    metadata?: JsonNullableWithAggregatesFilter<"ChapterActivity">
    summary?: StringWithAggregatesFilter<"ChapterActivity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChapterActivity"> | Date | string
  }

  export type EditorProfileWhereInput = {
    AND?: EditorProfileWhereInput | EditorProfileWhereInput[]
    OR?: EditorProfileWhereInput[]
    NOT?: EditorProfileWhereInput | EditorProfileWhereInput[]
    id?: StringFilter<"EditorProfile"> | string
    userId?: StringFilter<"EditorProfile"> | string
    displayName?: StringNullableFilter<"EditorProfile"> | string | null
    bio?: StringNullableFilter<"EditorProfile"> | string | null
    portfolioUrl?: StringNullableFilter<"EditorProfile"> | string | null
    specialtyGenres?: StringNullableListFilter<"EditorProfile">
    languages?: StringNullableListFilter<"EditorProfile">
    availability?: EnumEditorAvailabilityFilter<"EditorProfile"> | $Enums.EditorAvailability
    maxConcurrent?: IntFilter<"EditorProfile"> | number
    completedProjects?: IntFilter<"EditorProfile"> | number
    averageRating?: FloatNullableFilter<"EditorProfile"> | number | null
    totalReviews?: IntFilter<"EditorProfile"> | number
    isVerified?: BoolFilter<"EditorProfile"> | boolean
    createdAt?: DateTimeFilter<"EditorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EditorProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    portfolioItems?: PortfolioItemListRelationFilter
    applications?: ProjectApplicationListRelationFilter
    reviews?: EditorReviewListRelationFilter
  }

  export type EditorProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    portfolioUrl?: SortOrderInput | SortOrder
    specialtyGenres?: SortOrder
    languages?: SortOrder
    availability?: SortOrder
    maxConcurrent?: SortOrder
    completedProjects?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    totalReviews?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    portfolioItems?: PortfolioItemOrderByRelationAggregateInput
    applications?: ProjectApplicationOrderByRelationAggregateInput
    reviews?: EditorReviewOrderByRelationAggregateInput
  }

  export type EditorProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: EditorProfileWhereInput | EditorProfileWhereInput[]
    OR?: EditorProfileWhereInput[]
    NOT?: EditorProfileWhereInput | EditorProfileWhereInput[]
    displayName?: StringNullableFilter<"EditorProfile"> | string | null
    bio?: StringNullableFilter<"EditorProfile"> | string | null
    portfolioUrl?: StringNullableFilter<"EditorProfile"> | string | null
    specialtyGenres?: StringNullableListFilter<"EditorProfile">
    languages?: StringNullableListFilter<"EditorProfile">
    availability?: EnumEditorAvailabilityFilter<"EditorProfile"> | $Enums.EditorAvailability
    maxConcurrent?: IntFilter<"EditorProfile"> | number
    completedProjects?: IntFilter<"EditorProfile"> | number
    averageRating?: FloatNullableFilter<"EditorProfile"> | number | null
    totalReviews?: IntFilter<"EditorProfile"> | number
    isVerified?: BoolFilter<"EditorProfile"> | boolean
    createdAt?: DateTimeFilter<"EditorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EditorProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    portfolioItems?: PortfolioItemListRelationFilter
    applications?: ProjectApplicationListRelationFilter
    reviews?: EditorReviewListRelationFilter
  }, "id" | "userId">

  export type EditorProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    portfolioUrl?: SortOrderInput | SortOrder
    specialtyGenres?: SortOrder
    languages?: SortOrder
    availability?: SortOrder
    maxConcurrent?: SortOrder
    completedProjects?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    totalReviews?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EditorProfileCountOrderByAggregateInput
    _avg?: EditorProfileAvgOrderByAggregateInput
    _max?: EditorProfileMaxOrderByAggregateInput
    _min?: EditorProfileMinOrderByAggregateInput
    _sum?: EditorProfileSumOrderByAggregateInput
  }

  export type EditorProfileScalarWhereWithAggregatesInput = {
    AND?: EditorProfileScalarWhereWithAggregatesInput | EditorProfileScalarWhereWithAggregatesInput[]
    OR?: EditorProfileScalarWhereWithAggregatesInput[]
    NOT?: EditorProfileScalarWhereWithAggregatesInput | EditorProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EditorProfile"> | string
    userId?: StringWithAggregatesFilter<"EditorProfile"> | string
    displayName?: StringNullableWithAggregatesFilter<"EditorProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"EditorProfile"> | string | null
    portfolioUrl?: StringNullableWithAggregatesFilter<"EditorProfile"> | string | null
    specialtyGenres?: StringNullableListFilter<"EditorProfile">
    languages?: StringNullableListFilter<"EditorProfile">
    availability?: EnumEditorAvailabilityWithAggregatesFilter<"EditorProfile"> | $Enums.EditorAvailability
    maxConcurrent?: IntWithAggregatesFilter<"EditorProfile"> | number
    completedProjects?: IntWithAggregatesFilter<"EditorProfile"> | number
    averageRating?: FloatNullableWithAggregatesFilter<"EditorProfile"> | number | null
    totalReviews?: IntWithAggregatesFilter<"EditorProfile"> | number
    isVerified?: BoolWithAggregatesFilter<"EditorProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EditorProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EditorProfile"> | Date | string
  }

  export type PortfolioItemWhereInput = {
    AND?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    OR?: PortfolioItemWhereInput[]
    NOT?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    id?: StringFilter<"PortfolioItem"> | string
    profileId?: StringFilter<"PortfolioItem"> | string
    title?: StringFilter<"PortfolioItem"> | string
    description?: StringNullableFilter<"PortfolioItem"> | string | null
    genre?: StringNullableFilter<"PortfolioItem"> | string | null
    sampleText?: StringNullableFilter<"PortfolioItem"> | string | null
    sortOrder?: IntFilter<"PortfolioItem"> | number
    createdAt?: DateTimeFilter<"PortfolioItem"> | Date | string
    profile?: XOR<EditorProfileRelationFilter, EditorProfileWhereInput>
  }

  export type PortfolioItemOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    genre?: SortOrderInput | SortOrder
    sampleText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    profile?: EditorProfileOrderByWithRelationInput
  }

  export type PortfolioItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    OR?: PortfolioItemWhereInput[]
    NOT?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    profileId?: StringFilter<"PortfolioItem"> | string
    title?: StringFilter<"PortfolioItem"> | string
    description?: StringNullableFilter<"PortfolioItem"> | string | null
    genre?: StringNullableFilter<"PortfolioItem"> | string | null
    sampleText?: StringNullableFilter<"PortfolioItem"> | string | null
    sortOrder?: IntFilter<"PortfolioItem"> | number
    createdAt?: DateTimeFilter<"PortfolioItem"> | Date | string
    profile?: XOR<EditorProfileRelationFilter, EditorProfileWhereInput>
  }, "id">

  export type PortfolioItemOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    genre?: SortOrderInput | SortOrder
    sampleText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: PortfolioItemCountOrderByAggregateInput
    _avg?: PortfolioItemAvgOrderByAggregateInput
    _max?: PortfolioItemMaxOrderByAggregateInput
    _min?: PortfolioItemMinOrderByAggregateInput
    _sum?: PortfolioItemSumOrderByAggregateInput
  }

  export type PortfolioItemScalarWhereWithAggregatesInput = {
    AND?: PortfolioItemScalarWhereWithAggregatesInput | PortfolioItemScalarWhereWithAggregatesInput[]
    OR?: PortfolioItemScalarWhereWithAggregatesInput[]
    NOT?: PortfolioItemScalarWhereWithAggregatesInput | PortfolioItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PortfolioItem"> | string
    profileId?: StringWithAggregatesFilter<"PortfolioItem"> | string
    title?: StringWithAggregatesFilter<"PortfolioItem"> | string
    description?: StringNullableWithAggregatesFilter<"PortfolioItem"> | string | null
    genre?: StringNullableWithAggregatesFilter<"PortfolioItem"> | string | null
    sampleText?: StringNullableWithAggregatesFilter<"PortfolioItem"> | string | null
    sortOrder?: IntWithAggregatesFilter<"PortfolioItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PortfolioItem"> | Date | string
  }

  export type ProjectListingWhereInput = {
    AND?: ProjectListingWhereInput | ProjectListingWhereInput[]
    OR?: ProjectListingWhereInput[]
    NOT?: ProjectListingWhereInput | ProjectListingWhereInput[]
    id?: StringFilter<"ProjectListing"> | string
    workId?: StringFilter<"ProjectListing"> | string
    authorId?: StringFilter<"ProjectListing"> | string
    title?: StringFilter<"ProjectListing"> | string
    description?: StringFilter<"ProjectListing"> | string
    requirements?: StringNullableFilter<"ProjectListing"> | string | null
    status?: EnumProjectListingStatusFilter<"ProjectListing"> | $Enums.ProjectListingStatus
    budgetMin?: IntNullableFilter<"ProjectListing"> | number | null
    budgetMax?: IntNullableFilter<"ProjectListing"> | number | null
    deadline?: DateTimeNullableFilter<"ProjectListing"> | Date | string | null
    chapterStart?: IntNullableFilter<"ProjectListing"> | number | null
    chapterEnd?: IntNullableFilter<"ProjectListing"> | number | null
    viewCount?: IntFilter<"ProjectListing"> | number
    applicationCount?: IntFilter<"ProjectListing"> | number
    publishedAt?: DateTimeNullableFilter<"ProjectListing"> | Date | string | null
    createdAt?: DateTimeFilter<"ProjectListing"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectListing"> | Date | string
    work?: XOR<WorkRelationFilter, WorkWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    applications?: ProjectApplicationListRelationFilter
    contract?: XOR<ProjectContractNullableRelationFilter, ProjectContractWhereInput> | null
  }

  export type ProjectListingOrderByWithRelationInput = {
    id?: SortOrder
    workId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrderInput | SortOrder
    status?: SortOrder
    budgetMin?: SortOrderInput | SortOrder
    budgetMax?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    chapterStart?: SortOrderInput | SortOrder
    chapterEnd?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    applicationCount?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    work?: WorkOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    applications?: ProjectApplicationOrderByRelationAggregateInput
    contract?: ProjectContractOrderByWithRelationInput
  }

  export type ProjectListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectListingWhereInput | ProjectListingWhereInput[]
    OR?: ProjectListingWhereInput[]
    NOT?: ProjectListingWhereInput | ProjectListingWhereInput[]
    workId?: StringFilter<"ProjectListing"> | string
    authorId?: StringFilter<"ProjectListing"> | string
    title?: StringFilter<"ProjectListing"> | string
    description?: StringFilter<"ProjectListing"> | string
    requirements?: StringNullableFilter<"ProjectListing"> | string | null
    status?: EnumProjectListingStatusFilter<"ProjectListing"> | $Enums.ProjectListingStatus
    budgetMin?: IntNullableFilter<"ProjectListing"> | number | null
    budgetMax?: IntNullableFilter<"ProjectListing"> | number | null
    deadline?: DateTimeNullableFilter<"ProjectListing"> | Date | string | null
    chapterStart?: IntNullableFilter<"ProjectListing"> | number | null
    chapterEnd?: IntNullableFilter<"ProjectListing"> | number | null
    viewCount?: IntFilter<"ProjectListing"> | number
    applicationCount?: IntFilter<"ProjectListing"> | number
    publishedAt?: DateTimeNullableFilter<"ProjectListing"> | Date | string | null
    createdAt?: DateTimeFilter<"ProjectListing"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectListing"> | Date | string
    work?: XOR<WorkRelationFilter, WorkWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    applications?: ProjectApplicationListRelationFilter
    contract?: XOR<ProjectContractNullableRelationFilter, ProjectContractWhereInput> | null
  }, "id">

  export type ProjectListingOrderByWithAggregationInput = {
    id?: SortOrder
    workId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrderInput | SortOrder
    status?: SortOrder
    budgetMin?: SortOrderInput | SortOrder
    budgetMax?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    chapterStart?: SortOrderInput | SortOrder
    chapterEnd?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    applicationCount?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectListingCountOrderByAggregateInput
    _avg?: ProjectListingAvgOrderByAggregateInput
    _max?: ProjectListingMaxOrderByAggregateInput
    _min?: ProjectListingMinOrderByAggregateInput
    _sum?: ProjectListingSumOrderByAggregateInput
  }

  export type ProjectListingScalarWhereWithAggregatesInput = {
    AND?: ProjectListingScalarWhereWithAggregatesInput | ProjectListingScalarWhereWithAggregatesInput[]
    OR?: ProjectListingScalarWhereWithAggregatesInput[]
    NOT?: ProjectListingScalarWhereWithAggregatesInput | ProjectListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectListing"> | string
    workId?: StringWithAggregatesFilter<"ProjectListing"> | string
    authorId?: StringWithAggregatesFilter<"ProjectListing"> | string
    title?: StringWithAggregatesFilter<"ProjectListing"> | string
    description?: StringWithAggregatesFilter<"ProjectListing"> | string
    requirements?: StringNullableWithAggregatesFilter<"ProjectListing"> | string | null
    status?: EnumProjectListingStatusWithAggregatesFilter<"ProjectListing"> | $Enums.ProjectListingStatus
    budgetMin?: IntNullableWithAggregatesFilter<"ProjectListing"> | number | null
    budgetMax?: IntNullableWithAggregatesFilter<"ProjectListing"> | number | null
    deadline?: DateTimeNullableWithAggregatesFilter<"ProjectListing"> | Date | string | null
    chapterStart?: IntNullableWithAggregatesFilter<"ProjectListing"> | number | null
    chapterEnd?: IntNullableWithAggregatesFilter<"ProjectListing"> | number | null
    viewCount?: IntWithAggregatesFilter<"ProjectListing"> | number
    applicationCount?: IntWithAggregatesFilter<"ProjectListing"> | number
    publishedAt?: DateTimeNullableWithAggregatesFilter<"ProjectListing"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectListing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectListing"> | Date | string
  }

  export type ProjectApplicationWhereInput = {
    AND?: ProjectApplicationWhereInput | ProjectApplicationWhereInput[]
    OR?: ProjectApplicationWhereInput[]
    NOT?: ProjectApplicationWhereInput | ProjectApplicationWhereInput[]
    id?: StringFilter<"ProjectApplication"> | string
    listingId?: StringFilter<"ProjectApplication"> | string
    editorProfileId?: StringFilter<"ProjectApplication"> | string
    proposalMessage?: StringFilter<"ProjectApplication"> | string
    priceQuote?: IntNullableFilter<"ProjectApplication"> | number | null
    estimatedDays?: IntNullableFilter<"ProjectApplication"> | number | null
    status?: EnumApplicationStatusFilter<"ProjectApplication"> | $Enums.ApplicationStatus
    authorNote?: StringNullableFilter<"ProjectApplication"> | string | null
    submittedAt?: DateTimeFilter<"ProjectApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"ProjectApplication"> | Date | string | null
    listing?: XOR<ProjectListingRelationFilter, ProjectListingWhereInput>
    editorProfile?: XOR<EditorProfileRelationFilter, EditorProfileWhereInput>
  }

  export type ProjectApplicationOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    editorProfileId?: SortOrder
    proposalMessage?: SortOrder
    priceQuote?: SortOrderInput | SortOrder
    estimatedDays?: SortOrderInput | SortOrder
    status?: SortOrder
    authorNote?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    listing?: ProjectListingOrderByWithRelationInput
    editorProfile?: EditorProfileOrderByWithRelationInput
  }

  export type ProjectApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    listingId_editorProfileId?: ProjectApplicationListingIdEditorProfileIdCompoundUniqueInput
    AND?: ProjectApplicationWhereInput | ProjectApplicationWhereInput[]
    OR?: ProjectApplicationWhereInput[]
    NOT?: ProjectApplicationWhereInput | ProjectApplicationWhereInput[]
    listingId?: StringFilter<"ProjectApplication"> | string
    editorProfileId?: StringFilter<"ProjectApplication"> | string
    proposalMessage?: StringFilter<"ProjectApplication"> | string
    priceQuote?: IntNullableFilter<"ProjectApplication"> | number | null
    estimatedDays?: IntNullableFilter<"ProjectApplication"> | number | null
    status?: EnumApplicationStatusFilter<"ProjectApplication"> | $Enums.ApplicationStatus
    authorNote?: StringNullableFilter<"ProjectApplication"> | string | null
    submittedAt?: DateTimeFilter<"ProjectApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"ProjectApplication"> | Date | string | null
    listing?: XOR<ProjectListingRelationFilter, ProjectListingWhereInput>
    editorProfile?: XOR<EditorProfileRelationFilter, EditorProfileWhereInput>
  }, "id" | "listingId_editorProfileId">

  export type ProjectApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    editorProfileId?: SortOrder
    proposalMessage?: SortOrder
    priceQuote?: SortOrderInput | SortOrder
    estimatedDays?: SortOrderInput | SortOrder
    status?: SortOrder
    authorNote?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    _count?: ProjectApplicationCountOrderByAggregateInput
    _avg?: ProjectApplicationAvgOrderByAggregateInput
    _max?: ProjectApplicationMaxOrderByAggregateInput
    _min?: ProjectApplicationMinOrderByAggregateInput
    _sum?: ProjectApplicationSumOrderByAggregateInput
  }

  export type ProjectApplicationScalarWhereWithAggregatesInput = {
    AND?: ProjectApplicationScalarWhereWithAggregatesInput | ProjectApplicationScalarWhereWithAggregatesInput[]
    OR?: ProjectApplicationScalarWhereWithAggregatesInput[]
    NOT?: ProjectApplicationScalarWhereWithAggregatesInput | ProjectApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectApplication"> | string
    listingId?: StringWithAggregatesFilter<"ProjectApplication"> | string
    editorProfileId?: StringWithAggregatesFilter<"ProjectApplication"> | string
    proposalMessage?: StringWithAggregatesFilter<"ProjectApplication"> | string
    priceQuote?: IntNullableWithAggregatesFilter<"ProjectApplication"> | number | null
    estimatedDays?: IntNullableWithAggregatesFilter<"ProjectApplication"> | number | null
    status?: EnumApplicationStatusWithAggregatesFilter<"ProjectApplication"> | $Enums.ApplicationStatus
    authorNote?: StringNullableWithAggregatesFilter<"ProjectApplication"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"ProjectApplication"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ProjectApplication"> | Date | string | null
  }

  export type ProjectContractWhereInput = {
    AND?: ProjectContractWhereInput | ProjectContractWhereInput[]
    OR?: ProjectContractWhereInput[]
    NOT?: ProjectContractWhereInput | ProjectContractWhereInput[]
    id?: StringFilter<"ProjectContract"> | string
    listingId?: StringFilter<"ProjectContract"> | string
    workId?: StringFilter<"ProjectContract"> | string
    authorId?: StringFilter<"ProjectContract"> | string
    editorId?: StringFilter<"ProjectContract"> | string
    totalAmount?: IntNullableFilter<"ProjectContract"> | number | null
    startDate?: DateTimeFilter<"ProjectContract"> | Date | string
    expectedEndDate?: DateTimeNullableFilter<"ProjectContract"> | Date | string | null
    chapterStart?: IntFilter<"ProjectContract"> | number
    chapterEnd?: IntNullableFilter<"ProjectContract"> | number | null
    isActive?: BoolFilter<"ProjectContract"> | boolean
    createdAt?: DateTimeFilter<"ProjectContract"> | Date | string
    listing?: XOR<ProjectListingRelationFilter, ProjectListingWhereInput>
    work?: XOR<WorkRelationFilter, WorkWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    editor?: XOR<UserRelationFilter, UserWhereInput>
    revisionRequests?: ChapterRevisionRequestListRelationFilter
  }

  export type ProjectContractOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    workId?: SortOrder
    authorId?: SortOrder
    editorId?: SortOrder
    totalAmount?: SortOrderInput | SortOrder
    startDate?: SortOrder
    expectedEndDate?: SortOrderInput | SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    listing?: ProjectListingOrderByWithRelationInput
    work?: WorkOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    editor?: UserOrderByWithRelationInput
    revisionRequests?: ChapterRevisionRequestOrderByRelationAggregateInput
  }

  export type ProjectContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    listingId?: string
    AND?: ProjectContractWhereInput | ProjectContractWhereInput[]
    OR?: ProjectContractWhereInput[]
    NOT?: ProjectContractWhereInput | ProjectContractWhereInput[]
    workId?: StringFilter<"ProjectContract"> | string
    authorId?: StringFilter<"ProjectContract"> | string
    editorId?: StringFilter<"ProjectContract"> | string
    totalAmount?: IntNullableFilter<"ProjectContract"> | number | null
    startDate?: DateTimeFilter<"ProjectContract"> | Date | string
    expectedEndDate?: DateTimeNullableFilter<"ProjectContract"> | Date | string | null
    chapterStart?: IntFilter<"ProjectContract"> | number
    chapterEnd?: IntNullableFilter<"ProjectContract"> | number | null
    isActive?: BoolFilter<"ProjectContract"> | boolean
    createdAt?: DateTimeFilter<"ProjectContract"> | Date | string
    listing?: XOR<ProjectListingRelationFilter, ProjectListingWhereInput>
    work?: XOR<WorkRelationFilter, WorkWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    editor?: XOR<UserRelationFilter, UserWhereInput>
    revisionRequests?: ChapterRevisionRequestListRelationFilter
  }, "id" | "listingId">

  export type ProjectContractOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    workId?: SortOrder
    authorId?: SortOrder
    editorId?: SortOrder
    totalAmount?: SortOrderInput | SortOrder
    startDate?: SortOrder
    expectedEndDate?: SortOrderInput | SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectContractCountOrderByAggregateInput
    _avg?: ProjectContractAvgOrderByAggregateInput
    _max?: ProjectContractMaxOrderByAggregateInput
    _min?: ProjectContractMinOrderByAggregateInput
    _sum?: ProjectContractSumOrderByAggregateInput
  }

  export type ProjectContractScalarWhereWithAggregatesInput = {
    AND?: ProjectContractScalarWhereWithAggregatesInput | ProjectContractScalarWhereWithAggregatesInput[]
    OR?: ProjectContractScalarWhereWithAggregatesInput[]
    NOT?: ProjectContractScalarWhereWithAggregatesInput | ProjectContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectContract"> | string
    listingId?: StringWithAggregatesFilter<"ProjectContract"> | string
    workId?: StringWithAggregatesFilter<"ProjectContract"> | string
    authorId?: StringWithAggregatesFilter<"ProjectContract"> | string
    editorId?: StringWithAggregatesFilter<"ProjectContract"> | string
    totalAmount?: IntNullableWithAggregatesFilter<"ProjectContract"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"ProjectContract"> | Date | string
    expectedEndDate?: DateTimeNullableWithAggregatesFilter<"ProjectContract"> | Date | string | null
    chapterStart?: IntWithAggregatesFilter<"ProjectContract"> | number
    chapterEnd?: IntNullableWithAggregatesFilter<"ProjectContract"> | number | null
    isActive?: BoolWithAggregatesFilter<"ProjectContract"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProjectContract"> | Date | string
  }

  export type ChapterRevisionRequestWhereInput = {
    AND?: ChapterRevisionRequestWhereInput | ChapterRevisionRequestWhereInput[]
    OR?: ChapterRevisionRequestWhereInput[]
    NOT?: ChapterRevisionRequestWhereInput | ChapterRevisionRequestWhereInput[]
    id?: StringFilter<"ChapterRevisionRequest"> | string
    contractId?: StringFilter<"ChapterRevisionRequest"> | string
    chapterId?: StringFilter<"ChapterRevisionRequest"> | string
    requestedById?: StringFilter<"ChapterRevisionRequest"> | string
    reason?: StringFilter<"ChapterRevisionRequest"> | string
    specificFeedback?: StringNullableFilter<"ChapterRevisionRequest"> | string | null
    status?: EnumRevisionRequestStatusFilter<"ChapterRevisionRequest"> | $Enums.RevisionRequestStatus
    response?: StringNullableFilter<"ChapterRevisionRequest"> | string | null
    requestedAt?: DateTimeFilter<"ChapterRevisionRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"ChapterRevisionRequest"> | Date | string | null
    revisionCount?: IntFilter<"ChapterRevisionRequest"> | number
    contract?: XOR<ProjectContractRelationFilter, ProjectContractWhereInput>
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
    requestedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChapterRevisionRequestOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    chapterId?: SortOrder
    requestedById?: SortOrder
    reason?: SortOrder
    specificFeedback?: SortOrderInput | SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    revisionCount?: SortOrder
    contract?: ProjectContractOrderByWithRelationInput
    chapter?: ChapterOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
  }

  export type ChapterRevisionRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChapterRevisionRequestWhereInput | ChapterRevisionRequestWhereInput[]
    OR?: ChapterRevisionRequestWhereInput[]
    NOT?: ChapterRevisionRequestWhereInput | ChapterRevisionRequestWhereInput[]
    contractId?: StringFilter<"ChapterRevisionRequest"> | string
    chapterId?: StringFilter<"ChapterRevisionRequest"> | string
    requestedById?: StringFilter<"ChapterRevisionRequest"> | string
    reason?: StringFilter<"ChapterRevisionRequest"> | string
    specificFeedback?: StringNullableFilter<"ChapterRevisionRequest"> | string | null
    status?: EnumRevisionRequestStatusFilter<"ChapterRevisionRequest"> | $Enums.RevisionRequestStatus
    response?: StringNullableFilter<"ChapterRevisionRequest"> | string | null
    requestedAt?: DateTimeFilter<"ChapterRevisionRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"ChapterRevisionRequest"> | Date | string | null
    revisionCount?: IntFilter<"ChapterRevisionRequest"> | number
    contract?: XOR<ProjectContractRelationFilter, ProjectContractWhereInput>
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
    requestedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChapterRevisionRequestOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    chapterId?: SortOrder
    requestedById?: SortOrder
    reason?: SortOrder
    specificFeedback?: SortOrderInput | SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    revisionCount?: SortOrder
    _count?: ChapterRevisionRequestCountOrderByAggregateInput
    _avg?: ChapterRevisionRequestAvgOrderByAggregateInput
    _max?: ChapterRevisionRequestMaxOrderByAggregateInput
    _min?: ChapterRevisionRequestMinOrderByAggregateInput
    _sum?: ChapterRevisionRequestSumOrderByAggregateInput
  }

  export type ChapterRevisionRequestScalarWhereWithAggregatesInput = {
    AND?: ChapterRevisionRequestScalarWhereWithAggregatesInput | ChapterRevisionRequestScalarWhereWithAggregatesInput[]
    OR?: ChapterRevisionRequestScalarWhereWithAggregatesInput[]
    NOT?: ChapterRevisionRequestScalarWhereWithAggregatesInput | ChapterRevisionRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChapterRevisionRequest"> | string
    contractId?: StringWithAggregatesFilter<"ChapterRevisionRequest"> | string
    chapterId?: StringWithAggregatesFilter<"ChapterRevisionRequest"> | string
    requestedById?: StringWithAggregatesFilter<"ChapterRevisionRequest"> | string
    reason?: StringWithAggregatesFilter<"ChapterRevisionRequest"> | string
    specificFeedback?: StringNullableWithAggregatesFilter<"ChapterRevisionRequest"> | string | null
    status?: EnumRevisionRequestStatusWithAggregatesFilter<"ChapterRevisionRequest"> | $Enums.RevisionRequestStatus
    response?: StringNullableWithAggregatesFilter<"ChapterRevisionRequest"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"ChapterRevisionRequest"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ChapterRevisionRequest"> | Date | string | null
    revisionCount?: IntWithAggregatesFilter<"ChapterRevisionRequest"> | number
  }

  export type EditorReviewWhereInput = {
    AND?: EditorReviewWhereInput | EditorReviewWhereInput[]
    OR?: EditorReviewWhereInput[]
    NOT?: EditorReviewWhereInput | EditorReviewWhereInput[]
    id?: StringFilter<"EditorReview"> | string
    editorProfileId?: StringFilter<"EditorReview"> | string
    authorId?: StringFilter<"EditorReview"> | string
    workId?: StringFilter<"EditorReview"> | string
    overallRating?: IntFilter<"EditorReview"> | number
    qualityRating?: IntNullableFilter<"EditorReview"> | number | null
    speedRating?: IntNullableFilter<"EditorReview"> | number | null
    communicationRating?: IntNullableFilter<"EditorReview"> | number | null
    content?: StringNullableFilter<"EditorReview"> | string | null
    isPublic?: BoolFilter<"EditorReview"> | boolean
    createdAt?: DateTimeFilter<"EditorReview"> | Date | string
    editorProfile?: XOR<EditorProfileRelationFilter, EditorProfileWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    work?: XOR<WorkRelationFilter, WorkWhereInput>
  }

  export type EditorReviewOrderByWithRelationInput = {
    id?: SortOrder
    editorProfileId?: SortOrder
    authorId?: SortOrder
    workId?: SortOrder
    overallRating?: SortOrder
    qualityRating?: SortOrderInput | SortOrder
    speedRating?: SortOrderInput | SortOrder
    communicationRating?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    editorProfile?: EditorProfileOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    work?: WorkOrderByWithRelationInput
  }

  export type EditorReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    editorProfileId_authorId_workId?: EditorReviewEditorProfileIdAuthorIdWorkIdCompoundUniqueInput
    AND?: EditorReviewWhereInput | EditorReviewWhereInput[]
    OR?: EditorReviewWhereInput[]
    NOT?: EditorReviewWhereInput | EditorReviewWhereInput[]
    editorProfileId?: StringFilter<"EditorReview"> | string
    authorId?: StringFilter<"EditorReview"> | string
    workId?: StringFilter<"EditorReview"> | string
    overallRating?: IntFilter<"EditorReview"> | number
    qualityRating?: IntNullableFilter<"EditorReview"> | number | null
    speedRating?: IntNullableFilter<"EditorReview"> | number | null
    communicationRating?: IntNullableFilter<"EditorReview"> | number | null
    content?: StringNullableFilter<"EditorReview"> | string | null
    isPublic?: BoolFilter<"EditorReview"> | boolean
    createdAt?: DateTimeFilter<"EditorReview"> | Date | string
    editorProfile?: XOR<EditorProfileRelationFilter, EditorProfileWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    work?: XOR<WorkRelationFilter, WorkWhereInput>
  }, "id" | "editorProfileId_authorId_workId">

  export type EditorReviewOrderByWithAggregationInput = {
    id?: SortOrder
    editorProfileId?: SortOrder
    authorId?: SortOrder
    workId?: SortOrder
    overallRating?: SortOrder
    qualityRating?: SortOrderInput | SortOrder
    speedRating?: SortOrderInput | SortOrder
    communicationRating?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    _count?: EditorReviewCountOrderByAggregateInput
    _avg?: EditorReviewAvgOrderByAggregateInput
    _max?: EditorReviewMaxOrderByAggregateInput
    _min?: EditorReviewMinOrderByAggregateInput
    _sum?: EditorReviewSumOrderByAggregateInput
  }

  export type EditorReviewScalarWhereWithAggregatesInput = {
    AND?: EditorReviewScalarWhereWithAggregatesInput | EditorReviewScalarWhereWithAggregatesInput[]
    OR?: EditorReviewScalarWhereWithAggregatesInput[]
    NOT?: EditorReviewScalarWhereWithAggregatesInput | EditorReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EditorReview"> | string
    editorProfileId?: StringWithAggregatesFilter<"EditorReview"> | string
    authorId?: StringWithAggregatesFilter<"EditorReview"> | string
    workId?: StringWithAggregatesFilter<"EditorReview"> | string
    overallRating?: IntWithAggregatesFilter<"EditorReview"> | number
    qualityRating?: IntNullableWithAggregatesFilter<"EditorReview"> | number | null
    speedRating?: IntNullableWithAggregatesFilter<"EditorReview"> | number | null
    communicationRating?: IntNullableWithAggregatesFilter<"EditorReview"> | number | null
    content?: StringNullableWithAggregatesFilter<"EditorReview"> | string | null
    isPublic?: BoolWithAggregatesFilter<"EditorReview"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EditorReview"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkCreateInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWorksInput
    editor?: UserCreateNestedOneWithoutEditingWorksInput
    chapters?: ChapterCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemCreateNestedManyWithoutWorkInput
    creators?: CreatorCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobCreateNestedManyWithoutWorkInput
    listings?: ProjectListingCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemUncheckedCreateNestedManyWithoutWorkInput
    creators?: CreatorUncheckedCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleUncheckedCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput
    listings?: ProjectListingUncheckedCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractUncheckedCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWorksNestedInput
    editor?: UserUpdateOneWithoutEditingWorksNestedInput
    chapters?: ChapterUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUpdateManyWithoutWorkNestedInput
    creators?: CreatorUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput
    creators?: CreatorUncheckedUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUncheckedUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUncheckedUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUncheckedUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type WorkCreateManyInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorCreateInput = {
    id?: string
    name: string
    role: string
    work: WorkCreateNestedOneWithoutCreatorsInput
  }

  export type CreatorUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    workId: string
  }

  export type CreatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    work?: WorkUpdateOneRequiredWithoutCreatorsNestedInput
  }

  export type CreatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
  }

  export type CreatorCreateManyInput = {
    id?: string
    name: string
    role: string
    workId: string
  }

  export type CreatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type CreatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
  }

  export type ChapterCreateInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastEditedBy?: UserCreateNestedOneWithoutLastEditedChaptersInput
    work: WorkCreateNestedOneWithoutChaptersInput
    comments?: ChapterCommentCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: string | null
    lastEditedAt?: Date | string | null
    workId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditedBy?: UserUpdateOneWithoutLastEditedChaptersNestedInput
    work?: WorkUpdateOneRequiredWithoutChaptersNestedInput
    comments?: ChapterCommentUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ChapterCommentUncheckedUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterCreateManyInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: string | null
    lastEditedAt?: Date | string | null
    workId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlossaryItemCreateInput = {
    id?: string
    original: string
    translated: string
    category?: string | null
    note?: string | null
    work: WorkCreateNestedOneWithoutGlossaryInput
  }

  export type GlossaryItemUncheckedCreateInput = {
    id?: string
    original: string
    translated: string
    category?: string | null
    note?: string | null
    workId: string
  }

  export type GlossaryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    work?: WorkUpdateOneRequiredWithoutGlossaryNestedInput
  }

  export type GlossaryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: StringFieldUpdateOperationsInput | string
  }

  export type GlossaryItemCreateManyInput = {
    id?: string
    original: string
    translated: string
    category?: string | null
    note?: string | null
    workId: string
  }

  export type GlossaryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GlossaryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: StringFieldUpdateOperationsInput | string
  }

  export type TranslationLogCreateInput = {
    id?: string
    level?: $Enums.LogLevel
    category?: $Enums.LogCategory
    jobId?: string | null
    workId?: string | null
    chapterId?: string | null
    chapterNum?: number | null
    chunkIndex?: number | null
    userId?: string | null
    userEmail?: string | null
    message: string
    errorCode?: string | null
    errorStack?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    durationMs?: number | null
    retryCount?: number | null
    clientIp?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type TranslationLogUncheckedCreateInput = {
    id?: string
    level?: $Enums.LogLevel
    category?: $Enums.LogCategory
    jobId?: string | null
    workId?: string | null
    chapterId?: string | null
    chapterNum?: number | null
    chunkIndex?: number | null
    userId?: string | null
    userEmail?: string | null
    message: string
    errorCode?: string | null
    errorStack?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    durationMs?: number | null
    retryCount?: number | null
    clientIp?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type TranslationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterNum?: NullableIntFieldUpdateOperationsInput | number | null
    chunkIndex?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterNum?: NullableIntFieldUpdateOperationsInput | number | null
    chunkIndex?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationLogCreateManyInput = {
    id?: string
    level?: $Enums.LogLevel
    category?: $Enums.LogCategory
    jobId?: string | null
    workId?: string | null
    chapterId?: string | null
    chapterNum?: number | null
    chunkIndex?: number | null
    userId?: string | null
    userEmail?: string | null
    message: string
    errorCode?: string | null
    errorStack?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    durationMs?: number | null
    retryCount?: number | null
    clientIp?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type TranslationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterNum?: NullableIntFieldUpdateOperationsInput | number | null
    chunkIndex?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterNum?: NullableIntFieldUpdateOperationsInput | number | null
    chunkIndex?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiveTranslationJobCreateInput = {
    id?: string
    jobId: string
    workId: string
    workTitle: string
    userId: string
    userEmail?: string | null
    status?: string
    isPauseRequested?: boolean
    batchPlan?: NullableJsonNullValueInput | InputJsonValue
    totalBatches?: number
    currentBatchIndex?: number
    retryCount?: number
    maxRetries?: number
    lastError?: string | null
    totalChapters: number
    completedChapters?: number
    failedChapters?: number
    currentChapterNum?: number | null
    currentChunkIndex?: number | null
    totalChunks?: number | null
    chaptersProgress?: NullableJsonNullValueInput | InputJsonValue
    failedChapterNums?: ActiveTranslationJobCreatefailedChapterNumsInput | number[]
    autoRetryCount?: number
    maxAutoRetries?: number
    errorMessage?: string | null
    lockedAt?: Date | string | null
    lockedBy?: string | null
    startedAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ActiveTranslationJobUncheckedCreateInput = {
    id?: string
    jobId: string
    workId: string
    workTitle: string
    userId: string
    userEmail?: string | null
    status?: string
    isPauseRequested?: boolean
    batchPlan?: NullableJsonNullValueInput | InputJsonValue
    totalBatches?: number
    currentBatchIndex?: number
    retryCount?: number
    maxRetries?: number
    lastError?: string | null
    totalChapters: number
    completedChapters?: number
    failedChapters?: number
    currentChapterNum?: number | null
    currentChunkIndex?: number | null
    totalChunks?: number | null
    chaptersProgress?: NullableJsonNullValueInput | InputJsonValue
    failedChapterNums?: ActiveTranslationJobCreatefailedChapterNumsInput | number[]
    autoRetryCount?: number
    maxAutoRetries?: number
    errorMessage?: string | null
    lockedAt?: Date | string | null
    lockedBy?: string | null
    startedAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ActiveTranslationJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    workTitle?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPauseRequested?: BoolFieldUpdateOperationsInput | boolean
    batchPlan?: NullableJsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    completedChapters?: IntFieldUpdateOperationsInput | number
    failedChapters?: IntFieldUpdateOperationsInput | number
    currentChapterNum?: NullableIntFieldUpdateOperationsInput | number | null
    currentChunkIndex?: NullableIntFieldUpdateOperationsInput | number | null
    totalChunks?: NullableIntFieldUpdateOperationsInput | number | null
    chaptersProgress?: NullableJsonNullValueInput | InputJsonValue
    failedChapterNums?: ActiveTranslationJobUpdatefailedChapterNumsInput | number[]
    autoRetryCount?: IntFieldUpdateOperationsInput | number
    maxAutoRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActiveTranslationJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    workTitle?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPauseRequested?: BoolFieldUpdateOperationsInput | boolean
    batchPlan?: NullableJsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    completedChapters?: IntFieldUpdateOperationsInput | number
    failedChapters?: IntFieldUpdateOperationsInput | number
    currentChapterNum?: NullableIntFieldUpdateOperationsInput | number | null
    currentChunkIndex?: NullableIntFieldUpdateOperationsInput | number | null
    totalChunks?: NullableIntFieldUpdateOperationsInput | number | null
    chaptersProgress?: NullableJsonNullValueInput | InputJsonValue
    failedChapterNums?: ActiveTranslationJobUpdatefailedChapterNumsInput | number[]
    autoRetryCount?: IntFieldUpdateOperationsInput | number
    maxAutoRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActiveTranslationJobCreateManyInput = {
    id?: string
    jobId: string
    workId: string
    workTitle: string
    userId: string
    userEmail?: string | null
    status?: string
    isPauseRequested?: boolean
    batchPlan?: NullableJsonNullValueInput | InputJsonValue
    totalBatches?: number
    currentBatchIndex?: number
    retryCount?: number
    maxRetries?: number
    lastError?: string | null
    totalChapters: number
    completedChapters?: number
    failedChapters?: number
    currentChapterNum?: number | null
    currentChunkIndex?: number | null
    totalChunks?: number | null
    chaptersProgress?: NullableJsonNullValueInput | InputJsonValue
    failedChapterNums?: ActiveTranslationJobCreatefailedChapterNumsInput | number[]
    autoRetryCount?: number
    maxAutoRetries?: number
    errorMessage?: string | null
    lockedAt?: Date | string | null
    lockedBy?: string | null
    startedAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ActiveTranslationJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    workTitle?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPauseRequested?: BoolFieldUpdateOperationsInput | boolean
    batchPlan?: NullableJsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    completedChapters?: IntFieldUpdateOperationsInput | number
    failedChapters?: IntFieldUpdateOperationsInput | number
    currentChapterNum?: NullableIntFieldUpdateOperationsInput | number | null
    currentChunkIndex?: NullableIntFieldUpdateOperationsInput | number | null
    totalChunks?: NullableIntFieldUpdateOperationsInput | number | null
    chaptersProgress?: NullableJsonNullValueInput | InputJsonValue
    failedChapterNums?: ActiveTranslationJobUpdatefailedChapterNumsInput | number[]
    autoRetryCount?: IntFieldUpdateOperationsInput | number
    maxAutoRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActiveTranslationJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    workTitle?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPauseRequested?: BoolFieldUpdateOperationsInput | boolean
    batchPlan?: NullableJsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    completedChapters?: IntFieldUpdateOperationsInput | number
    failedChapters?: IntFieldUpdateOperationsInput | number
    currentChapterNum?: NullableIntFieldUpdateOperationsInput | number | null
    currentChunkIndex?: NullableIntFieldUpdateOperationsInput | number | null
    totalChunks?: NullableIntFieldUpdateOperationsInput | number | null
    chaptersProgress?: NullableJsonNullValueInput | InputJsonValue
    failedChapterNums?: ActiveTranslationJobUpdatefailedChapterNumsInput | number[]
    autoRetryCount?: IntFieldUpdateOperationsInput | number
    maxAutoRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TranslationJobHistoryCreateInput = {
    id?: string
    jobId: string
    workId: string
    workTitle: string
    userId: string
    userEmail?: string | null
    status: string
    totalChapters: number
    completedChapters: number
    failedChapters: number
    errorMessage?: string | null
    failedChapterNums?: TranslationJobHistoryCreatefailedChapterNumsInput | number[]
    startedAt: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    createdAt?: Date | string
  }

  export type TranslationJobHistoryUncheckedCreateInput = {
    id?: string
    jobId: string
    workId: string
    workTitle: string
    userId: string
    userEmail?: string | null
    status: string
    totalChapters: number
    completedChapters: number
    failedChapters: number
    errorMessage?: string | null
    failedChapterNums?: TranslationJobHistoryCreatefailedChapterNumsInput | number[]
    startedAt: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    createdAt?: Date | string
  }

  export type TranslationJobHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    workTitle?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalChapters?: IntFieldUpdateOperationsInput | number
    completedChapters?: IntFieldUpdateOperationsInput | number
    failedChapters?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    failedChapterNums?: TranslationJobHistoryUpdatefailedChapterNumsInput | number[]
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationJobHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    workTitle?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalChapters?: IntFieldUpdateOperationsInput | number
    completedChapters?: IntFieldUpdateOperationsInput | number
    failedChapters?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    failedChapterNums?: TranslationJobHistoryUpdatefailedChapterNumsInput | number[]
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationJobHistoryCreateManyInput = {
    id?: string
    jobId: string
    workId: string
    workTitle: string
    userId: string
    userEmail?: string | null
    status: string
    totalChapters: number
    completedChapters: number
    failedChapters: number
    errorMessage?: string | null
    failedChapterNums?: TranslationJobHistoryCreatefailedChapterNumsInput | number[]
    startedAt: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    createdAt?: Date | string
  }

  export type TranslationJobHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    workTitle?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalChapters?: IntFieldUpdateOperationsInput | number
    completedChapters?: IntFieldUpdateOperationsInput | number
    failedChapters?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    failedChapterNums?: TranslationJobHistoryUpdatefailedChapterNumsInput | number[]
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationJobHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    workTitle?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalChapters?: IntFieldUpdateOperationsInput | number
    completedChapters?: IntFieldUpdateOperationsInput | number
    failedChapters?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    failedChapterNums?: TranslationJobHistoryUpdatefailedChapterNumsInput | number[]
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingBibleCreateInput = {
    id?: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    work: WorkCreateNestedOneWithoutSettingBibleInput
    characters?: CharacterCreateNestedManyWithoutBibleInput
    terms?: SettingTermCreateNestedManyWithoutBibleInput
    events?: TimelineEventCreateNestedManyWithoutBibleInput
  }

  export type SettingBibleUncheckedCreateInput = {
    id?: string
    workId: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutBibleInput
    terms?: SettingTermUncheckedCreateNestedManyWithoutBibleInput
    events?: TimelineEventUncheckedCreateNestedManyWithoutBibleInput
  }

  export type SettingBibleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    work?: WorkUpdateOneRequiredWithoutSettingBibleNestedInput
    characters?: CharacterUpdateManyWithoutBibleNestedInput
    terms?: SettingTermUpdateManyWithoutBibleNestedInput
    events?: TimelineEventUpdateManyWithoutBibleNestedInput
  }

  export type SettingBibleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutBibleNestedInput
    terms?: SettingTermUncheckedUpdateManyWithoutBibleNestedInput
    events?: TimelineEventUncheckedUpdateManyWithoutBibleNestedInput
  }

  export type SettingBibleCreateManyInput = {
    id?: string
    workId: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingBibleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingBibleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterCreateInput = {
    id?: string
    nameOriginal: string
    nameKorean: string
    nameHanja?: string | null
    titles?: CharacterCreatetitlesInput | string[]
    aliases?: CharacterCreatealiasesInput | string[]
    personality?: string | null
    speechStyle?: string | null
    role?: $Enums.CharacterRole
    description?: string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: number | null
    sortOrder?: number
    isConfirmed?: boolean
    bible: SettingBibleCreateNestedOneWithoutCharactersInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: string
    bibleId: string
    nameOriginal: string
    nameKorean: string
    nameHanja?: string | null
    titles?: CharacterCreatetitlesInput | string[]
    aliases?: CharacterCreatealiasesInput | string[]
    personality?: string | null
    speechStyle?: string | null
    role?: $Enums.CharacterRole
    description?: string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: number | null
    sortOrder?: number
    isConfirmed?: boolean
  }

  export type CharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameOriginal?: StringFieldUpdateOperationsInput | string
    nameKorean?: StringFieldUpdateOperationsInput | string
    nameHanja?: NullableStringFieldUpdateOperationsInput | string | null
    titles?: CharacterUpdatetitlesInput | string[]
    aliases?: CharacterUpdatealiasesInput | string[]
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    speechStyle?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumCharacterRoleFieldUpdateOperationsInput | $Enums.CharacterRole
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    bible?: SettingBibleUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bibleId?: StringFieldUpdateOperationsInput | string
    nameOriginal?: StringFieldUpdateOperationsInput | string
    nameKorean?: StringFieldUpdateOperationsInput | string
    nameHanja?: NullableStringFieldUpdateOperationsInput | string | null
    titles?: CharacterUpdatetitlesInput | string[]
    aliases?: CharacterUpdatealiasesInput | string[]
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    speechStyle?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumCharacterRoleFieldUpdateOperationsInput | $Enums.CharacterRole
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CharacterCreateManyInput = {
    id?: string
    bibleId: string
    nameOriginal: string
    nameKorean: string
    nameHanja?: string | null
    titles?: CharacterCreatetitlesInput | string[]
    aliases?: CharacterCreatealiasesInput | string[]
    personality?: string | null
    speechStyle?: string | null
    role?: $Enums.CharacterRole
    description?: string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: number | null
    sortOrder?: number
    isConfirmed?: boolean
  }

  export type CharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameOriginal?: StringFieldUpdateOperationsInput | string
    nameKorean?: StringFieldUpdateOperationsInput | string
    nameHanja?: NullableStringFieldUpdateOperationsInput | string | null
    titles?: CharacterUpdatetitlesInput | string[]
    aliases?: CharacterUpdatealiasesInput | string[]
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    speechStyle?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumCharacterRoleFieldUpdateOperationsInput | $Enums.CharacterRole
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bibleId?: StringFieldUpdateOperationsInput | string
    nameOriginal?: StringFieldUpdateOperationsInput | string
    nameKorean?: StringFieldUpdateOperationsInput | string
    nameHanja?: NullableStringFieldUpdateOperationsInput | string | null
    titles?: CharacterUpdatetitlesInput | string[]
    aliases?: CharacterUpdatealiasesInput | string[]
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    speechStyle?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumCharacterRoleFieldUpdateOperationsInput | $Enums.CharacterRole
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingTermCreateInput = {
    id?: string
    original: string
    translated: string
    category: $Enums.TermCategory
    note?: string | null
    context?: string | null
    firstAppearance?: number | null
    frequency?: number
    isConfirmed?: boolean
    bible: SettingBibleCreateNestedOneWithoutTermsInput
  }

  export type SettingTermUncheckedCreateInput = {
    id?: string
    bibleId: string
    original: string
    translated: string
    category: $Enums.TermCategory
    note?: string | null
    context?: string | null
    firstAppearance?: number | null
    frequency?: number
    isConfirmed?: boolean
  }

  export type SettingTermUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: EnumTermCategoryFieldUpdateOperationsInput | $Enums.TermCategory
    note?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    bible?: SettingBibleUpdateOneRequiredWithoutTermsNestedInput
  }

  export type SettingTermUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bibleId?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: EnumTermCategoryFieldUpdateOperationsInput | $Enums.TermCategory
    note?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingTermCreateManyInput = {
    id?: string
    bibleId: string
    original: string
    translated: string
    category: $Enums.TermCategory
    note?: string | null
    context?: string | null
    firstAppearance?: number | null
    frequency?: number
    isConfirmed?: boolean
  }

  export type SettingTermUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: EnumTermCategoryFieldUpdateOperationsInput | $Enums.TermCategory
    note?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingTermUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bibleId?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: EnumTermCategoryFieldUpdateOperationsInput | $Enums.TermCategory
    note?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TimelineEventCreateInput = {
    id?: string
    title: string
    description: string
    chapterStart: number
    chapterEnd?: number | null
    eventType?: $Enums.EventType
    importance?: number
    isForeshadowing?: boolean
    foreshadowNote?: string | null
    involvedCharacterIds?: TimelineEventCreateinvolvedCharacterIdsInput | string[]
    bible: SettingBibleCreateNestedOneWithoutEventsInput
  }

  export type TimelineEventUncheckedCreateInput = {
    id?: string
    bibleId: string
    title: string
    description: string
    chapterStart: number
    chapterEnd?: number | null
    eventType?: $Enums.EventType
    importance?: number
    isForeshadowing?: boolean
    foreshadowNote?: string | null
    involvedCharacterIds?: TimelineEventCreateinvolvedCharacterIdsInput | string[]
  }

  export type TimelineEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    importance?: IntFieldUpdateOperationsInput | number
    isForeshadowing?: BoolFieldUpdateOperationsInput | boolean
    foreshadowNote?: NullableStringFieldUpdateOperationsInput | string | null
    involvedCharacterIds?: TimelineEventUpdateinvolvedCharacterIdsInput | string[]
    bible?: SettingBibleUpdateOneRequiredWithoutEventsNestedInput
  }

  export type TimelineEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bibleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    importance?: IntFieldUpdateOperationsInput | number
    isForeshadowing?: BoolFieldUpdateOperationsInput | boolean
    foreshadowNote?: NullableStringFieldUpdateOperationsInput | string | null
    involvedCharacterIds?: TimelineEventUpdateinvolvedCharacterIdsInput | string[]
  }

  export type TimelineEventCreateManyInput = {
    id?: string
    bibleId: string
    title: string
    description: string
    chapterStart: number
    chapterEnd?: number | null
    eventType?: $Enums.EventType
    importance?: number
    isForeshadowing?: boolean
    foreshadowNote?: string | null
    involvedCharacterIds?: TimelineEventCreateinvolvedCharacterIdsInput | string[]
  }

  export type TimelineEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    importance?: IntFieldUpdateOperationsInput | number
    isForeshadowing?: BoolFieldUpdateOperationsInput | boolean
    foreshadowNote?: NullableStringFieldUpdateOperationsInput | string | null
    involvedCharacterIds?: TimelineEventUpdateinvolvedCharacterIdsInput | string[]
  }

  export type TimelineEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bibleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    importance?: IntFieldUpdateOperationsInput | number
    isForeshadowing?: BoolFieldUpdateOperationsInput | boolean
    foreshadowNote?: NullableStringFieldUpdateOperationsInput | string | null
    involvedCharacterIds?: TimelineEventUpdateinvolvedCharacterIdsInput | string[]
  }

  export type BibleGenerationJobCreateInput = {
    id?: string
    userId: string
    status?: $Enums.BibleJobStatus
    batchPlan: JsonNullValueInput | InputJsonValue
    totalBatches: number
    currentBatchIndex?: number
    analyzedChapters?: number
    retryCount?: number
    maxRetries?: number
    errorMessage?: string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lockedAt?: Date | string | null
    lockedBy?: string | null
    work: WorkCreateNestedOneWithoutBibleJobsInput
  }

  export type BibleGenerationJobUncheckedCreateInput = {
    id?: string
    workId: string
    userId: string
    status?: $Enums.BibleJobStatus
    batchPlan: JsonNullValueInput | InputJsonValue
    totalBatches: number
    currentBatchIndex?: number
    analyzedChapters?: number
    retryCount?: number
    maxRetries?: number
    errorMessage?: string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lockedAt?: Date | string | null
    lockedBy?: string | null
  }

  export type BibleGenerationJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleJobStatusFieldUpdateOperationsInput | $Enums.BibleJobStatus
    batchPlan?: JsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    work?: WorkUpdateOneRequiredWithoutBibleJobsNestedInput
  }

  export type BibleGenerationJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleJobStatusFieldUpdateOperationsInput | $Enums.BibleJobStatus
    batchPlan?: JsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BibleGenerationJobCreateManyInput = {
    id?: string
    workId: string
    userId: string
    status?: $Enums.BibleJobStatus
    batchPlan: JsonNullValueInput | InputJsonValue
    totalBatches: number
    currentBatchIndex?: number
    analyzedChapters?: number
    retryCount?: number
    maxRetries?: number
    errorMessage?: string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lockedAt?: Date | string | null
    lockedBy?: string | null
  }

  export type BibleGenerationJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleJobStatusFieldUpdateOperationsInput | $Enums.BibleJobStatus
    batchPlan?: JsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BibleGenerationJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleJobStatusFieldUpdateOperationsInput | $Enums.BibleJobStatus
    batchPlan?: JsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChapterCommentCreateInput = {
    id?: string
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    parent?: ChapterCommentCreateNestedOneWithoutRepliesInput
    replies?: ChapterCommentCreateNestedManyWithoutParentInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
  }

  export type ChapterCommentUncheckedCreateInput = {
    id?: string
    chapterId: string
    authorId: string
    parentId?: string | null
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ChapterCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ChapterCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: ChapterCommentUpdateOneWithoutRepliesNestedInput
    replies?: ChapterCommentUpdateManyWithoutParentNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
  }

  export type ChapterCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ChapterCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ChapterCommentCreateManyInput = {
    id?: string
    chapterId: string
    authorId: string
    parentId?: string | null
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterSnapshotCreateInput = {
    id?: string
    name?: string | null
    description?: string | null
    snapshotType?: $Enums.SnapshotType
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status: $Enums.ChapterStatus
    triggerEvent?: string | null
    createdAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutSnapshotsInput
    author: UserCreateNestedOneWithoutSnapshotsInput
  }

  export type ChapterSnapshotUncheckedCreateInput = {
    id?: string
    chapterId: string
    authorId: string
    name?: string | null
    description?: string | null
    snapshotType?: $Enums.SnapshotType
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status: $Enums.ChapterStatus
    triggerEvent?: string | null
    createdAt?: Date | string
  }

  export type ChapterSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    triggerEvent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutSnapshotsNestedInput
    author?: UserUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type ChapterSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    triggerEvent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterSnapshotCreateManyInput = {
    id?: string
    chapterId: string
    authorId: string
    name?: string | null
    description?: string | null
    snapshotType?: $Enums.SnapshotType
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status: $Enums.ChapterStatus
    triggerEvent?: string | null
    createdAt?: Date | string
  }

  export type ChapterSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    triggerEvent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    triggerEvent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChangeCreateInput = {
    id?: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutChangesInput
    author: UserCreateNestedOneWithoutChangesInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedChangesInput
  }

  export type ChapterChangeUncheckedCreateInput = {
    id?: string
    chapterId: string
    authorId: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChapterChangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutChangesNestedInput
    author?: UserUpdateOneRequiredWithoutChangesNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedChangesNestedInput
  }

  export type ChapterChangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChangeCreateManyInput = {
    id?: string
    chapterId: string
    authorId: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChapterChangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterActivityCreateInput = {
    id?: string
    activityType: $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary: string
    createdAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutActivitiesInput
    actor: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ChapterActivityUncheckedCreateInput = {
    id?: string
    chapterId: string
    actorId: string
    activityType: $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary: string
    createdAt?: Date | string
  }

  export type ChapterActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutActivitiesNestedInput
    actor?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ChapterActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterActivityCreateManyInput = {
    id?: string
    chapterId: string
    actorId: string
    activityType: $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary: string
    createdAt?: Date | string
  }

  export type ChapterActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditorProfileCreateInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEditorProfileInput
    portfolioItems?: PortfolioItemCreateNestedManyWithoutProfileInput
    applications?: ProjectApplicationCreateNestedManyWithoutEditorProfileInput
    reviews?: EditorReviewCreateNestedManyWithoutEditorProfileInput
  }

  export type EditorProfileUncheckedCreateInput = {
    id?: string
    userId: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioItems?: PortfolioItemUncheckedCreateNestedManyWithoutProfileInput
    applications?: ProjectApplicationUncheckedCreateNestedManyWithoutEditorProfileInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutEditorProfileInput
  }

  export type EditorProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEditorProfileNestedInput
    portfolioItems?: PortfolioItemUpdateManyWithoutProfileNestedInput
    applications?: ProjectApplicationUpdateManyWithoutEditorProfileNestedInput
    reviews?: EditorReviewUpdateManyWithoutEditorProfileNestedInput
  }

  export type EditorProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioItems?: PortfolioItemUncheckedUpdateManyWithoutProfileNestedInput
    applications?: ProjectApplicationUncheckedUpdateManyWithoutEditorProfileNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutEditorProfileNestedInput
  }

  export type EditorProfileCreateManyInput = {
    id?: string
    userId: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditorProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditorProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    genre?: string | null
    sampleText?: string | null
    sortOrder?: number
    createdAt?: Date | string
    profile: EditorProfileCreateNestedOneWithoutPortfolioItemsInput
  }

  export type PortfolioItemUncheckedCreateInput = {
    id?: string
    profileId: string
    title: string
    description?: string | null
    genre?: string | null
    sampleText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type PortfolioItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    sampleText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: EditorProfileUpdateOneRequiredWithoutPortfolioItemsNestedInput
  }

  export type PortfolioItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    sampleText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemCreateManyInput = {
    id?: string
    profileId: string
    title: string
    description?: string | null
    genre?: string | null
    sampleText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type PortfolioItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    sampleText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    sampleText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectListingCreateInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    work: WorkCreateNestedOneWithoutListingsInput
    author: UserCreateNestedOneWithoutAuthorListingsInput
    applications?: ProjectApplicationCreateNestedManyWithoutListingInput
    contract?: ProjectContractCreateNestedOneWithoutListingInput
  }

  export type ProjectListingUncheckedCreateInput = {
    id?: string
    workId: string
    authorId: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ProjectApplicationUncheckedCreateNestedManyWithoutListingInput
    contract?: ProjectContractUncheckedCreateNestedOneWithoutListingInput
  }

  export type ProjectListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    work?: WorkUpdateOneRequiredWithoutListingsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthorListingsNestedInput
    applications?: ProjectApplicationUpdateManyWithoutListingNestedInput
    contract?: ProjectContractUpdateOneWithoutListingNestedInput
  }

  export type ProjectListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ProjectApplicationUncheckedUpdateManyWithoutListingNestedInput
    contract?: ProjectContractUncheckedUpdateOneWithoutListingNestedInput
  }

  export type ProjectListingCreateManyInput = {
    id?: string
    workId: string
    authorId: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectApplicationCreateInput = {
    id?: string
    proposalMessage: string
    priceQuote?: number | null
    estimatedDays?: number | null
    status?: $Enums.ApplicationStatus
    authorNote?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    listing: ProjectListingCreateNestedOneWithoutApplicationsInput
    editorProfile: EditorProfileCreateNestedOneWithoutApplicationsInput
  }

  export type ProjectApplicationUncheckedCreateInput = {
    id?: string
    listingId: string
    editorProfileId: string
    proposalMessage: string
    priceQuote?: number | null
    estimatedDays?: number | null
    status?: $Enums.ApplicationStatus
    authorNote?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type ProjectApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalMessage?: StringFieldUpdateOperationsInput | string
    priceQuote?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    authorNote?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ProjectListingUpdateOneRequiredWithoutApplicationsNestedInput
    editorProfile?: EditorProfileUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type ProjectApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    editorProfileId?: StringFieldUpdateOperationsInput | string
    proposalMessage?: StringFieldUpdateOperationsInput | string
    priceQuote?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    authorNote?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectApplicationCreateManyInput = {
    id?: string
    listingId: string
    editorProfileId: string
    proposalMessage: string
    priceQuote?: number | null
    estimatedDays?: number | null
    status?: $Enums.ApplicationStatus
    authorNote?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type ProjectApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalMessage?: StringFieldUpdateOperationsInput | string
    priceQuote?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    authorNote?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    editorProfileId?: StringFieldUpdateOperationsInput | string
    proposalMessage?: StringFieldUpdateOperationsInput | string
    priceQuote?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    authorNote?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectContractCreateInput = {
    id?: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    listing: ProjectListingCreateNestedOneWithoutContractInput
    work: WorkCreateNestedOneWithoutContractsInput
    author: UserCreateNestedOneWithoutAuthorContractsInput
    editor: UserCreateNestedOneWithoutEditorContractsInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutContractInput
  }

  export type ProjectContractUncheckedCreateInput = {
    id?: string
    listingId: string
    workId: string
    authorId: string
    editorId: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutContractInput
  }

  export type ProjectContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ProjectListingUpdateOneRequiredWithoutContractNestedInput
    work?: WorkUpdateOneRequiredWithoutContractsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthorContractsNestedInput
    editor?: UserUpdateOneRequiredWithoutEditorContractsNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutContractNestedInput
  }

  export type ProjectContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ProjectContractCreateManyInput = {
    id?: string
    listingId: string
    workId: string
    authorId: string
    editorId: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ProjectContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterRevisionRequestCreateInput = {
    id?: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
    contract: ProjectContractCreateNestedOneWithoutRevisionRequestsInput
    chapter: ChapterCreateNestedOneWithoutRevisionRequestsInput
    requestedBy: UserCreateNestedOneWithoutRevisionRequestsInput
  }

  export type ChapterRevisionRequestUncheckedCreateInput = {
    id?: string
    contractId: string
    chapterId: string
    requestedById: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
  }

  export type ChapterRevisionRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
    contract?: ProjectContractUpdateOneRequiredWithoutRevisionRequestsNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutRevisionRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRevisionRequestsNestedInput
  }

  export type ChapterRevisionRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
  }

  export type ChapterRevisionRequestCreateManyInput = {
    id?: string
    contractId: string
    chapterId: string
    requestedById: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
  }

  export type ChapterRevisionRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
  }

  export type ChapterRevisionRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
  }

  export type EditorReviewCreateInput = {
    id?: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    editorProfile: EditorProfileCreateNestedOneWithoutReviewsInput
    author: UserCreateNestedOneWithoutAuthorReviewsInput
    work: WorkCreateNestedOneWithoutReviewsInput
  }

  export type EditorReviewUncheckedCreateInput = {
    id?: string
    editorProfileId: string
    authorId: string
    workId: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type EditorReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editorProfile?: EditorProfileUpdateOneRequiredWithoutReviewsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthorReviewsNestedInput
    work?: WorkUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type EditorReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    editorProfileId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditorReviewCreateManyInput = {
    id?: string
    editorProfileId: string
    authorId: string
    workId: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type EditorReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditorReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    editorProfileId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type WorkListRelationFilter = {
    every?: WorkWhereInput
    some?: WorkWhereInput
    none?: WorkWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ChapterListRelationFilter = {
    every?: ChapterWhereInput
    some?: ChapterWhereInput
    none?: ChapterWhereInput
  }

  export type ChapterCommentListRelationFilter = {
    every?: ChapterCommentWhereInput
    some?: ChapterCommentWhereInput
    none?: ChapterCommentWhereInput
  }

  export type ChapterSnapshotListRelationFilter = {
    every?: ChapterSnapshotWhereInput
    some?: ChapterSnapshotWhereInput
    none?: ChapterSnapshotWhereInput
  }

  export type ChapterChangeListRelationFilter = {
    every?: ChapterChangeWhereInput
    some?: ChapterChangeWhereInput
    none?: ChapterChangeWhereInput
  }

  export type ChapterActivityListRelationFilter = {
    every?: ChapterActivityWhereInput
    some?: ChapterActivityWhereInput
    none?: ChapterActivityWhereInput
  }

  export type EditorProfileNullableRelationFilter = {
    is?: EditorProfileWhereInput | null
    isNot?: EditorProfileWhereInput | null
  }

  export type ProjectListingListRelationFilter = {
    every?: ProjectListingWhereInput
    some?: ProjectListingWhereInput
    none?: ProjectListingWhereInput
  }

  export type ProjectContractListRelationFilter = {
    every?: ProjectContractWhereInput
    some?: ProjectContractWhereInput
    none?: ProjectContractWhereInput
  }

  export type ChapterRevisionRequestListRelationFilter = {
    every?: ChapterRevisionRequestWhereInput
    some?: ChapterRevisionRequestWhereInput
    none?: ChapterRevisionRequestWhereInput
  }

  export type EditorReviewListRelationFilter = {
    every?: EditorReviewWhereInput
    some?: EditorReviewWhereInput
    none?: EditorReviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WorkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterRevisionRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EditorReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAgeRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingFilter<$PrismaModel> | $Enums.AgeRating
  }

  export type EnumWorkStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkStatus | EnumWorkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkStatus[] | ListEnumWorkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkStatus[] | ListEnumWorkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkStatusFilter<$PrismaModel> | $Enums.WorkStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumOriginalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OriginalStatus | EnumOriginalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OriginalStatus[] | ListEnumOriginalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OriginalStatus[] | ListEnumOriginalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOriginalStatusFilter<$PrismaModel> | $Enums.OriginalStatus
  }

  export type EnumSourceLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceLanguage | EnumSourceLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.SourceLanguage[] | ListEnumSourceLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceLanguage[] | ListEnumSourceLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceLanguageFilter<$PrismaModel> | $Enums.SourceLanguage
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type GlossaryItemListRelationFilter = {
    every?: GlossaryItemWhereInput
    some?: GlossaryItemWhereInput
    none?: GlossaryItemWhereInput
  }

  export type CreatorListRelationFilter = {
    every?: CreatorWhereInput
    some?: CreatorWhereInput
    none?: CreatorWhereInput
  }

  export type SettingBibleNullableRelationFilter = {
    is?: SettingBibleWhereInput | null
    isNot?: SettingBibleWhereInput | null
  }

  export type BibleGenerationJobListRelationFilter = {
    every?: BibleGenerationJobWhereInput
    some?: BibleGenerationJobWhereInput
    none?: BibleGenerationJobWhereInput
  }

  export type GlossaryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BibleGenerationJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkCountOrderByAggregateInput = {
    id?: SortOrder
    titleKo?: SortOrder
    titleOriginal?: SortOrder
    publisher?: SortOrder
    ageRating?: SortOrder
    status?: SortOrder
    coverImage?: SortOrder
    synopsis?: SortOrder
    genres?: SortOrder
    originalStatus?: SortOrder
    sourceLanguage?: SortOrder
    expectedChapters?: SortOrder
    platformName?: SortOrder
    platformUrl?: SortOrder
    publishedAt?: SortOrder
    totalChapters?: SortOrder
    authorId?: SortOrder
    editorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkAvgOrderByAggregateInput = {
    expectedChapters?: SortOrder
    totalChapters?: SortOrder
  }

  export type WorkMaxOrderByAggregateInput = {
    id?: SortOrder
    titleKo?: SortOrder
    titleOriginal?: SortOrder
    publisher?: SortOrder
    ageRating?: SortOrder
    status?: SortOrder
    coverImage?: SortOrder
    synopsis?: SortOrder
    originalStatus?: SortOrder
    sourceLanguage?: SortOrder
    expectedChapters?: SortOrder
    platformName?: SortOrder
    platformUrl?: SortOrder
    publishedAt?: SortOrder
    totalChapters?: SortOrder
    authorId?: SortOrder
    editorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkMinOrderByAggregateInput = {
    id?: SortOrder
    titleKo?: SortOrder
    titleOriginal?: SortOrder
    publisher?: SortOrder
    ageRating?: SortOrder
    status?: SortOrder
    coverImage?: SortOrder
    synopsis?: SortOrder
    originalStatus?: SortOrder
    sourceLanguage?: SortOrder
    expectedChapters?: SortOrder
    platformName?: SortOrder
    platformUrl?: SortOrder
    publishedAt?: SortOrder
    totalChapters?: SortOrder
    authorId?: SortOrder
    editorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkSumOrderByAggregateInput = {
    expectedChapters?: SortOrder
    totalChapters?: SortOrder
  }

  export type EnumAgeRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingWithAggregatesFilter<$PrismaModel> | $Enums.AgeRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgeRatingFilter<$PrismaModel>
    _max?: NestedEnumAgeRatingFilter<$PrismaModel>
  }

  export type EnumWorkStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkStatus | EnumWorkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkStatus[] | ListEnumWorkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkStatus[] | ListEnumWorkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkStatusFilter<$PrismaModel>
  }

  export type EnumOriginalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OriginalStatus | EnumOriginalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OriginalStatus[] | ListEnumOriginalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OriginalStatus[] | ListEnumOriginalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOriginalStatusWithAggregatesFilter<$PrismaModel> | $Enums.OriginalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOriginalStatusFilter<$PrismaModel>
    _max?: NestedEnumOriginalStatusFilter<$PrismaModel>
  }

  export type EnumSourceLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceLanguage | EnumSourceLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.SourceLanguage[] | ListEnumSourceLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceLanguage[] | ListEnumSourceLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceLanguageWithAggregatesFilter<$PrismaModel> | $Enums.SourceLanguage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceLanguageFilter<$PrismaModel>
    _max?: NestedEnumSourceLanguageFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type WorkRelationFilter = {
    is?: WorkWhereInput
    isNot?: WorkWhereInput
  }

  export type CreatorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    workId?: SortOrder
  }

  export type CreatorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    workId?: SortOrder
  }

  export type CreatorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    workId?: SortOrder
  }

  export type EnumChapterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusFilter<$PrismaModel> | $Enums.ChapterStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ChapterWorkIdNumberCompoundUniqueInput = {
    workId: string
    number: number
  }

  export type ChapterCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    originalContent?: SortOrder
    translatedContent?: SortOrder
    editedContent?: SortOrder
    status?: SortOrder
    wordCount?: SortOrder
    translationMeta?: SortOrder
    trackChangesState?: SortOrder
    lastEditedById?: SortOrder
    lastEditedAt?: SortOrder
    workId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterAvgOrderByAggregateInput = {
    number?: SortOrder
    wordCount?: SortOrder
  }

  export type ChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    originalContent?: SortOrder
    translatedContent?: SortOrder
    editedContent?: SortOrder
    status?: SortOrder
    wordCount?: SortOrder
    lastEditedById?: SortOrder
    lastEditedAt?: SortOrder
    workId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    originalContent?: SortOrder
    translatedContent?: SortOrder
    editedContent?: SortOrder
    status?: SortOrder
    wordCount?: SortOrder
    lastEditedById?: SortOrder
    lastEditedAt?: SortOrder
    workId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterSumOrderByAggregateInput = {
    number?: SortOrder
    wordCount?: SortOrder
  }

  export type EnumChapterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChapterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChapterStatusFilter<$PrismaModel>
    _max?: NestedEnumChapterStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type GlossaryItemWorkIdOriginalCompoundUniqueInput = {
    workId: string
    original: string
  }

  export type GlossaryItemCountOrderByAggregateInput = {
    id?: SortOrder
    original?: SortOrder
    translated?: SortOrder
    category?: SortOrder
    note?: SortOrder
    workId?: SortOrder
  }

  export type GlossaryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    original?: SortOrder
    translated?: SortOrder
    category?: SortOrder
    note?: SortOrder
    workId?: SortOrder
  }

  export type GlossaryItemMinOrderByAggregateInput = {
    id?: SortOrder
    original?: SortOrder
    translated?: SortOrder
    category?: SortOrder
    note?: SortOrder
    workId?: SortOrder
  }

  export type EnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type EnumLogCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryFilter<$PrismaModel> | $Enums.LogCategory
  }

  export type TranslationLogCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    chapterId?: SortOrder
    chapterNum?: SortOrder
    chunkIndex?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    message?: SortOrder
    errorCode?: SortOrder
    errorStack?: SortOrder
    metadata?: SortOrder
    durationMs?: SortOrder
    retryCount?: SortOrder
    clientIp?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type TranslationLogAvgOrderByAggregateInput = {
    chapterNum?: SortOrder
    chunkIndex?: SortOrder
    durationMs?: SortOrder
    retryCount?: SortOrder
  }

  export type TranslationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    chapterId?: SortOrder
    chapterNum?: SortOrder
    chunkIndex?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    message?: SortOrder
    errorCode?: SortOrder
    errorStack?: SortOrder
    durationMs?: SortOrder
    retryCount?: SortOrder
    clientIp?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type TranslationLogMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    chapterId?: SortOrder
    chapterNum?: SortOrder
    chunkIndex?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    message?: SortOrder
    errorCode?: SortOrder
    errorStack?: SortOrder
    durationMs?: SortOrder
    retryCount?: SortOrder
    clientIp?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type TranslationLogSumOrderByAggregateInput = {
    chapterNum?: SortOrder
    chunkIndex?: SortOrder
    durationMs?: SortOrder
    retryCount?: SortOrder
  }

  export type EnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type EnumLogCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryWithAggregatesFilter<$PrismaModel> | $Enums.LogCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogCategoryFilter<$PrismaModel>
    _max?: NestedEnumLogCategoryFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ActiveTranslationJobCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    workTitle?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    isPauseRequested?: SortOrder
    batchPlan?: SortOrder
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lastError?: SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    currentChapterNum?: SortOrder
    currentChunkIndex?: SortOrder
    totalChunks?: SortOrder
    chaptersProgress?: SortOrder
    failedChapterNums?: SortOrder
    autoRetryCount?: SortOrder
    maxAutoRetries?: SortOrder
    errorMessage?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ActiveTranslationJobAvgOrderByAggregateInput = {
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    currentChapterNum?: SortOrder
    currentChunkIndex?: SortOrder
    totalChunks?: SortOrder
    failedChapterNums?: SortOrder
    autoRetryCount?: SortOrder
    maxAutoRetries?: SortOrder
  }

  export type ActiveTranslationJobMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    workTitle?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    isPauseRequested?: SortOrder
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lastError?: SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    currentChapterNum?: SortOrder
    currentChunkIndex?: SortOrder
    totalChunks?: SortOrder
    autoRetryCount?: SortOrder
    maxAutoRetries?: SortOrder
    errorMessage?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ActiveTranslationJobMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    workTitle?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    isPauseRequested?: SortOrder
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lastError?: SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    currentChapterNum?: SortOrder
    currentChunkIndex?: SortOrder
    totalChunks?: SortOrder
    autoRetryCount?: SortOrder
    maxAutoRetries?: SortOrder
    errorMessage?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ActiveTranslationJobSumOrderByAggregateInput = {
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    currentChapterNum?: SortOrder
    currentChunkIndex?: SortOrder
    totalChunks?: SortOrder
    failedChapterNums?: SortOrder
    autoRetryCount?: SortOrder
    maxAutoRetries?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TranslationJobHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    workTitle?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    errorMessage?: SortOrder
    failedChapterNums?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type TranslationJobHistoryAvgOrderByAggregateInput = {
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    failedChapterNums?: SortOrder
    durationMs?: SortOrder
  }

  export type TranslationJobHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    workTitle?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    errorMessage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type TranslationJobHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    workId?: SortOrder
    workTitle?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    errorMessage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type TranslationJobHistorySumOrderByAggregateInput = {
    totalChapters?: SortOrder
    completedChapters?: SortOrder
    failedChapters?: SortOrder
    failedChapterNums?: SortOrder
    durationMs?: SortOrder
  }

  export type EnumBibleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BibleStatus | EnumBibleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BibleStatus[] | ListEnumBibleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BibleStatus[] | ListEnumBibleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBibleStatusFilter<$PrismaModel> | $Enums.BibleStatus
  }

  export type CharacterListRelationFilter = {
    every?: CharacterWhereInput
    some?: CharacterWhereInput
    none?: CharacterWhereInput
  }

  export type SettingTermListRelationFilter = {
    every?: SettingTermWhereInput
    some?: SettingTermWhereInput
    none?: SettingTermWhereInput
  }

  export type TimelineEventListRelationFilter = {
    every?: TimelineEventWhereInput
    some?: TimelineEventWhereInput
    none?: TimelineEventWhereInput
  }

  export type CharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettingTermOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimelineEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettingBibleCountOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    status?: SortOrder
    version?: SortOrder
    translationGuide?: SortOrder
    analyzedChapters?: SortOrder
    generatedAt?: SortOrder
    confirmedAt?: SortOrder
    confirmedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingBibleAvgOrderByAggregateInput = {
    version?: SortOrder
    analyzedChapters?: SortOrder
  }

  export type SettingBibleMaxOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    status?: SortOrder
    version?: SortOrder
    translationGuide?: SortOrder
    analyzedChapters?: SortOrder
    generatedAt?: SortOrder
    confirmedAt?: SortOrder
    confirmedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingBibleMinOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    status?: SortOrder
    version?: SortOrder
    translationGuide?: SortOrder
    analyzedChapters?: SortOrder
    generatedAt?: SortOrder
    confirmedAt?: SortOrder
    confirmedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingBibleSumOrderByAggregateInput = {
    version?: SortOrder
    analyzedChapters?: SortOrder
  }

  export type EnumBibleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BibleStatus | EnumBibleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BibleStatus[] | ListEnumBibleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BibleStatus[] | ListEnumBibleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBibleStatusWithAggregatesFilter<$PrismaModel> | $Enums.BibleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBibleStatusFilter<$PrismaModel>
    _max?: NestedEnumBibleStatusFilter<$PrismaModel>
  }

  export type EnumCharacterRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterRole | EnumCharacterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CharacterRole[] | ListEnumCharacterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CharacterRole[] | ListEnumCharacterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCharacterRoleFilter<$PrismaModel> | $Enums.CharacterRole
  }

  export type SettingBibleRelationFilter = {
    is?: SettingBibleWhereInput
    isNot?: SettingBibleWhereInput
  }

  export type CharacterBibleIdNameOriginalCompoundUniqueInput = {
    bibleId: string
    nameOriginal: string
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    bibleId?: SortOrder
    nameOriginal?: SortOrder
    nameKorean?: SortOrder
    nameHanja?: SortOrder
    titles?: SortOrder
    aliases?: SortOrder
    personality?: SortOrder
    speechStyle?: SortOrder
    role?: SortOrder
    description?: SortOrder
    relationships?: SortOrder
    firstAppearance?: SortOrder
    sortOrder?: SortOrder
    isConfirmed?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    firstAppearance?: SortOrder
    sortOrder?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    bibleId?: SortOrder
    nameOriginal?: SortOrder
    nameKorean?: SortOrder
    nameHanja?: SortOrder
    personality?: SortOrder
    speechStyle?: SortOrder
    role?: SortOrder
    description?: SortOrder
    firstAppearance?: SortOrder
    sortOrder?: SortOrder
    isConfirmed?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    bibleId?: SortOrder
    nameOriginal?: SortOrder
    nameKorean?: SortOrder
    nameHanja?: SortOrder
    personality?: SortOrder
    speechStyle?: SortOrder
    role?: SortOrder
    description?: SortOrder
    firstAppearance?: SortOrder
    sortOrder?: SortOrder
    isConfirmed?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    firstAppearance?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumCharacterRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterRole | EnumCharacterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CharacterRole[] | ListEnumCharacterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CharacterRole[] | ListEnumCharacterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCharacterRoleWithAggregatesFilter<$PrismaModel> | $Enums.CharacterRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCharacterRoleFilter<$PrismaModel>
    _max?: NestedEnumCharacterRoleFilter<$PrismaModel>
  }

  export type EnumTermCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TermCategory | EnumTermCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TermCategory[] | ListEnumTermCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TermCategory[] | ListEnumTermCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTermCategoryFilter<$PrismaModel> | $Enums.TermCategory
  }

  export type SettingTermBibleIdOriginalCompoundUniqueInput = {
    bibleId: string
    original: string
  }

  export type SettingTermCountOrderByAggregateInput = {
    id?: SortOrder
    bibleId?: SortOrder
    original?: SortOrder
    translated?: SortOrder
    category?: SortOrder
    note?: SortOrder
    context?: SortOrder
    firstAppearance?: SortOrder
    frequency?: SortOrder
    isConfirmed?: SortOrder
  }

  export type SettingTermAvgOrderByAggregateInput = {
    firstAppearance?: SortOrder
    frequency?: SortOrder
  }

  export type SettingTermMaxOrderByAggregateInput = {
    id?: SortOrder
    bibleId?: SortOrder
    original?: SortOrder
    translated?: SortOrder
    category?: SortOrder
    note?: SortOrder
    context?: SortOrder
    firstAppearance?: SortOrder
    frequency?: SortOrder
    isConfirmed?: SortOrder
  }

  export type SettingTermMinOrderByAggregateInput = {
    id?: SortOrder
    bibleId?: SortOrder
    original?: SortOrder
    translated?: SortOrder
    category?: SortOrder
    note?: SortOrder
    context?: SortOrder
    firstAppearance?: SortOrder
    frequency?: SortOrder
    isConfirmed?: SortOrder
  }

  export type SettingTermSumOrderByAggregateInput = {
    firstAppearance?: SortOrder
    frequency?: SortOrder
  }

  export type EnumTermCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TermCategory | EnumTermCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TermCategory[] | ListEnumTermCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TermCategory[] | ListEnumTermCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTermCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TermCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTermCategoryFilter<$PrismaModel>
    _max?: NestedEnumTermCategoryFilter<$PrismaModel>
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type TimelineEventBibleIdTitleChapterStartCompoundUniqueInput = {
    bibleId: string
    title: string
    chapterStart: number
  }

  export type TimelineEventCountOrderByAggregateInput = {
    id?: SortOrder
    bibleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    eventType?: SortOrder
    importance?: SortOrder
    isForeshadowing?: SortOrder
    foreshadowNote?: SortOrder
    involvedCharacterIds?: SortOrder
  }

  export type TimelineEventAvgOrderByAggregateInput = {
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    importance?: SortOrder
  }

  export type TimelineEventMaxOrderByAggregateInput = {
    id?: SortOrder
    bibleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    eventType?: SortOrder
    importance?: SortOrder
    isForeshadowing?: SortOrder
    foreshadowNote?: SortOrder
  }

  export type TimelineEventMinOrderByAggregateInput = {
    id?: SortOrder
    bibleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    eventType?: SortOrder
    importance?: SortOrder
    isForeshadowing?: SortOrder
    foreshadowNote?: SortOrder
  }

  export type TimelineEventSumOrderByAggregateInput = {
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    importance?: SortOrder
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type EnumBibleJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BibleJobStatus | EnumBibleJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BibleJobStatus[] | ListEnumBibleJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BibleJobStatus[] | ListEnumBibleJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBibleJobStatusFilter<$PrismaModel> | $Enums.BibleJobStatus
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BibleGenerationJobCountOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    batchPlan?: SortOrder
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    analyzedChapters?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    errorMessage?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
  }

  export type BibleGenerationJobAvgOrderByAggregateInput = {
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    analyzedChapters?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type BibleGenerationJobMaxOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    analyzedChapters?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    errorMessage?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
  }

  export type BibleGenerationJobMinOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    analyzedChapters?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    errorMessage?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
  }

  export type BibleGenerationJobSumOrderByAggregateInput = {
    totalBatches?: SortOrder
    currentBatchIndex?: SortOrder
    analyzedChapters?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type EnumBibleJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BibleJobStatus | EnumBibleJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BibleJobStatus[] | ListEnumBibleJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BibleJobStatus[] | ListEnumBibleJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBibleJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.BibleJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBibleJobStatusFilter<$PrismaModel>
    _max?: NestedEnumBibleJobStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ChapterRelationFilter = {
    is?: ChapterWhereInput
    isNot?: ChapterWhereInput
  }

  export type ChapterCommentNullableRelationFilter = {
    is?: ChapterCommentWhereInput | null
    isNot?: ChapterCommentWhereInput | null
  }

  export type ChapterCommentCountOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    content?: SortOrder
    textRange?: SortOrder
    quotedText?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    content?: SortOrder
    quotedText?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterCommentMinOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    content?: SortOrder
    quotedText?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSnapshotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotType | EnumSnapshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotTypeFilter<$PrismaModel> | $Enums.SnapshotType
  }

  export type ChapterSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    snapshotType?: SortOrder
    originalContent?: SortOrder
    translatedContent?: SortOrder
    editedContent?: SortOrder
    status?: SortOrder
    triggerEvent?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    snapshotType?: SortOrder
    originalContent?: SortOrder
    translatedContent?: SortOrder
    editedContent?: SortOrder
    status?: SortOrder
    triggerEvent?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    snapshotType?: SortOrder
    originalContent?: SortOrder
    translatedContent?: SortOrder
    editedContent?: SortOrder
    status?: SortOrder
    triggerEvent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSnapshotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotType | EnumSnapshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SnapshotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnapshotTypeFilter<$PrismaModel>
    _max?: NestedEnumSnapshotTypeFilter<$PrismaModel>
  }

  export type EnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type EnumChangeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeStatus | EnumChangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeStatusFilter<$PrismaModel> | $Enums.ChangeStatus
  }

  export type ChapterChangeCountOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    changeType?: SortOrder
    fromPos?: SortOrder
    toPos?: SortOrder
    oldText?: SortOrder
    newText?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterChangeAvgOrderByAggregateInput = {
    fromPos?: SortOrder
    toPos?: SortOrder
  }

  export type ChapterChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    changeType?: SortOrder
    fromPos?: SortOrder
    toPos?: SortOrder
    oldText?: SortOrder
    newText?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterChangeMinOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    authorId?: SortOrder
    changeType?: SortOrder
    fromPos?: SortOrder
    toPos?: SortOrder
    oldText?: SortOrder
    newText?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterChangeSumOrderByAggregateInput = {
    fromPos?: SortOrder
    toPos?: SortOrder
  }

  export type EnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type EnumChangeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeStatus | EnumChangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChangeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeStatusFilter<$PrismaModel>
    _max?: NestedEnumChangeStatusFilter<$PrismaModel>
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type ChapterActivityCountOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    actorId?: SortOrder
    activityType?: SortOrder
    metadata?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    actorId?: SortOrder
    activityType?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterActivityMinOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    actorId?: SortOrder
    activityType?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type EnumEditorAvailabilityFilter<$PrismaModel = never> = {
    equals?: $Enums.EditorAvailability | EnumEditorAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.EditorAvailability[] | ListEnumEditorAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.EditorAvailability[] | ListEnumEditorAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumEditorAvailabilityFilter<$PrismaModel> | $Enums.EditorAvailability
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PortfolioItemListRelationFilter = {
    every?: PortfolioItemWhereInput
    some?: PortfolioItemWhereInput
    none?: PortfolioItemWhereInput
  }

  export type ProjectApplicationListRelationFilter = {
    every?: ProjectApplicationWhereInput
    some?: ProjectApplicationWhereInput
    none?: ProjectApplicationWhereInput
  }

  export type PortfolioItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EditorProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    portfolioUrl?: SortOrder
    specialtyGenres?: SortOrder
    languages?: SortOrder
    availability?: SortOrder
    maxConcurrent?: SortOrder
    completedProjects?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditorProfileAvgOrderByAggregateInput = {
    maxConcurrent?: SortOrder
    completedProjects?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
  }

  export type EditorProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    portfolioUrl?: SortOrder
    availability?: SortOrder
    maxConcurrent?: SortOrder
    completedProjects?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditorProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    portfolioUrl?: SortOrder
    availability?: SortOrder
    maxConcurrent?: SortOrder
    completedProjects?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditorProfileSumOrderByAggregateInput = {
    maxConcurrent?: SortOrder
    completedProjects?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
  }

  export type EnumEditorAvailabilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EditorAvailability | EnumEditorAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.EditorAvailability[] | ListEnumEditorAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.EditorAvailability[] | ListEnumEditorAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumEditorAvailabilityWithAggregatesFilter<$PrismaModel> | $Enums.EditorAvailability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEditorAvailabilityFilter<$PrismaModel>
    _max?: NestedEnumEditorAvailabilityFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EditorProfileRelationFilter = {
    is?: EditorProfileWhereInput
    isNot?: EditorProfileWhereInput
  }

  export type PortfolioItemCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    genre?: SortOrder
    sampleText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type PortfolioItemAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type PortfolioItemMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    genre?: SortOrder
    sampleText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type PortfolioItemMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    genre?: SortOrder
    sampleText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type PortfolioItemSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumProjectListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectListingStatus | EnumProjectListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectListingStatus[] | ListEnumProjectListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectListingStatus[] | ListEnumProjectListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectListingStatusFilter<$PrismaModel> | $Enums.ProjectListingStatus
  }

  export type ProjectContractNullableRelationFilter = {
    is?: ProjectContractWhereInput | null
    isNot?: ProjectContractWhereInput | null
  }

  export type ProjectListingCountOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    status?: SortOrder
    budgetMin?: SortOrder
    budgetMax?: SortOrder
    deadline?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    viewCount?: SortOrder
    applicationCount?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectListingAvgOrderByAggregateInput = {
    budgetMin?: SortOrder
    budgetMax?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    viewCount?: SortOrder
    applicationCount?: SortOrder
  }

  export type ProjectListingMaxOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    status?: SortOrder
    budgetMin?: SortOrder
    budgetMax?: SortOrder
    deadline?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    viewCount?: SortOrder
    applicationCount?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectListingMinOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    status?: SortOrder
    budgetMin?: SortOrder
    budgetMax?: SortOrder
    deadline?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    viewCount?: SortOrder
    applicationCount?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectListingSumOrderByAggregateInput = {
    budgetMin?: SortOrder
    budgetMax?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    viewCount?: SortOrder
    applicationCount?: SortOrder
  }

  export type EnumProjectListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectListingStatus | EnumProjectListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectListingStatus[] | ListEnumProjectListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectListingStatus[] | ListEnumProjectListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectListingStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectListingStatusFilter<$PrismaModel>
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type ProjectListingRelationFilter = {
    is?: ProjectListingWhereInput
    isNot?: ProjectListingWhereInput
  }

  export type ProjectApplicationListingIdEditorProfileIdCompoundUniqueInput = {
    listingId: string
    editorProfileId: string
  }

  export type ProjectApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    editorProfileId?: SortOrder
    proposalMessage?: SortOrder
    priceQuote?: SortOrder
    estimatedDays?: SortOrder
    status?: SortOrder
    authorNote?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type ProjectApplicationAvgOrderByAggregateInput = {
    priceQuote?: SortOrder
    estimatedDays?: SortOrder
  }

  export type ProjectApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    editorProfileId?: SortOrder
    proposalMessage?: SortOrder
    priceQuote?: SortOrder
    estimatedDays?: SortOrder
    status?: SortOrder
    authorNote?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type ProjectApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    editorProfileId?: SortOrder
    proposalMessage?: SortOrder
    priceQuote?: SortOrder
    estimatedDays?: SortOrder
    status?: SortOrder
    authorNote?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type ProjectApplicationSumOrderByAggregateInput = {
    priceQuote?: SortOrder
    estimatedDays?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type ProjectContractCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    workId?: SortOrder
    authorId?: SortOrder
    editorId?: SortOrder
    totalAmount?: SortOrder
    startDate?: SortOrder
    expectedEndDate?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectContractAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
  }

  export type ProjectContractMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    workId?: SortOrder
    authorId?: SortOrder
    editorId?: SortOrder
    totalAmount?: SortOrder
    startDate?: SortOrder
    expectedEndDate?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectContractMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    workId?: SortOrder
    authorId?: SortOrder
    editorId?: SortOrder
    totalAmount?: SortOrder
    startDate?: SortOrder
    expectedEndDate?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectContractSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    chapterStart?: SortOrder
    chapterEnd?: SortOrder
  }

  export type EnumRevisionRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionRequestStatus | EnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionRequestStatus[] | ListEnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionRequestStatus[] | ListEnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionRequestStatusFilter<$PrismaModel> | $Enums.RevisionRequestStatus
  }

  export type ProjectContractRelationFilter = {
    is?: ProjectContractWhereInput
    isNot?: ProjectContractWhereInput
  }

  export type ChapterRevisionRequestCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    chapterId?: SortOrder
    requestedById?: SortOrder
    reason?: SortOrder
    specificFeedback?: SortOrder
    status?: SortOrder
    response?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    revisionCount?: SortOrder
  }

  export type ChapterRevisionRequestAvgOrderByAggregateInput = {
    revisionCount?: SortOrder
  }

  export type ChapterRevisionRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    chapterId?: SortOrder
    requestedById?: SortOrder
    reason?: SortOrder
    specificFeedback?: SortOrder
    status?: SortOrder
    response?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    revisionCount?: SortOrder
  }

  export type ChapterRevisionRequestMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    chapterId?: SortOrder
    requestedById?: SortOrder
    reason?: SortOrder
    specificFeedback?: SortOrder
    status?: SortOrder
    response?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    revisionCount?: SortOrder
  }

  export type ChapterRevisionRequestSumOrderByAggregateInput = {
    revisionCount?: SortOrder
  }

  export type EnumRevisionRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionRequestStatus | EnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionRequestStatus[] | ListEnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionRequestStatus[] | ListEnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RevisionRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRevisionRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRevisionRequestStatusFilter<$PrismaModel>
  }

  export type EditorReviewEditorProfileIdAuthorIdWorkIdCompoundUniqueInput = {
    editorProfileId: string
    authorId: string
    workId: string
  }

  export type EditorReviewCountOrderByAggregateInput = {
    id?: SortOrder
    editorProfileId?: SortOrder
    authorId?: SortOrder
    workId?: SortOrder
    overallRating?: SortOrder
    qualityRating?: SortOrder
    speedRating?: SortOrder
    communicationRating?: SortOrder
    content?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
  }

  export type EditorReviewAvgOrderByAggregateInput = {
    overallRating?: SortOrder
    qualityRating?: SortOrder
    speedRating?: SortOrder
    communicationRating?: SortOrder
  }

  export type EditorReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    editorProfileId?: SortOrder
    authorId?: SortOrder
    workId?: SortOrder
    overallRating?: SortOrder
    qualityRating?: SortOrder
    speedRating?: SortOrder
    communicationRating?: SortOrder
    content?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
  }

  export type EditorReviewMinOrderByAggregateInput = {
    id?: SortOrder
    editorProfileId?: SortOrder
    authorId?: SortOrder
    workId?: SortOrder
    overallRating?: SortOrder
    qualityRating?: SortOrder
    speedRating?: SortOrder
    communicationRating?: SortOrder
    content?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
  }

  export type EditorReviewSumOrderByAggregateInput = {
    overallRating?: SortOrder
    qualityRating?: SortOrder
    speedRating?: SortOrder
    communicationRating?: SortOrder
  }

  export type WorkCreateNestedManyWithoutAuthorInput = {
    create?: XOR<WorkCreateWithoutAuthorInput, WorkUncheckedCreateWithoutAuthorInput> | WorkCreateWithoutAuthorInput[] | WorkUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: WorkCreateOrConnectWithoutAuthorInput | WorkCreateOrConnectWithoutAuthorInput[]
    createMany?: WorkCreateManyAuthorInputEnvelope
    connect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
  }

  export type WorkCreateNestedManyWithoutEditorInput = {
    create?: XOR<WorkCreateWithoutEditorInput, WorkUncheckedCreateWithoutEditorInput> | WorkCreateWithoutEditorInput[] | WorkUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: WorkCreateOrConnectWithoutEditorInput | WorkCreateOrConnectWithoutEditorInput[]
    createMany?: WorkCreateManyEditorInputEnvelope
    connect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ChapterCreateNestedManyWithoutLastEditedByInput = {
    create?: XOR<ChapterCreateWithoutLastEditedByInput, ChapterUncheckedCreateWithoutLastEditedByInput> | ChapterCreateWithoutLastEditedByInput[] | ChapterUncheckedCreateWithoutLastEditedByInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutLastEditedByInput | ChapterCreateOrConnectWithoutLastEditedByInput[]
    createMany?: ChapterCreateManyLastEditedByInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type ChapterCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ChapterCommentCreateWithoutAuthorInput, ChapterCommentUncheckedCreateWithoutAuthorInput> | ChapterCommentCreateWithoutAuthorInput[] | ChapterCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutAuthorInput | ChapterCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: ChapterCommentCreateManyAuthorInputEnvelope
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
  }

  export type ChapterCommentCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<ChapterCommentCreateWithoutResolvedByInput, ChapterCommentUncheckedCreateWithoutResolvedByInput> | ChapterCommentCreateWithoutResolvedByInput[] | ChapterCommentUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutResolvedByInput | ChapterCommentCreateOrConnectWithoutResolvedByInput[]
    createMany?: ChapterCommentCreateManyResolvedByInputEnvelope
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
  }

  export type ChapterSnapshotCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ChapterSnapshotCreateWithoutAuthorInput, ChapterSnapshotUncheckedCreateWithoutAuthorInput> | ChapterSnapshotCreateWithoutAuthorInput[] | ChapterSnapshotUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterSnapshotCreateOrConnectWithoutAuthorInput | ChapterSnapshotCreateOrConnectWithoutAuthorInput[]
    createMany?: ChapterSnapshotCreateManyAuthorInputEnvelope
    connect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
  }

  export type ChapterChangeCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ChapterChangeCreateWithoutAuthorInput, ChapterChangeUncheckedCreateWithoutAuthorInput> | ChapterChangeCreateWithoutAuthorInput[] | ChapterChangeUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutAuthorInput | ChapterChangeCreateOrConnectWithoutAuthorInput[]
    createMany?: ChapterChangeCreateManyAuthorInputEnvelope
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
  }

  export type ChapterChangeCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<ChapterChangeCreateWithoutReviewedByInput, ChapterChangeUncheckedCreateWithoutReviewedByInput> | ChapterChangeCreateWithoutReviewedByInput[] | ChapterChangeUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutReviewedByInput | ChapterChangeCreateOrConnectWithoutReviewedByInput[]
    createMany?: ChapterChangeCreateManyReviewedByInputEnvelope
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
  }

  export type ChapterActivityCreateNestedManyWithoutActorInput = {
    create?: XOR<ChapterActivityCreateWithoutActorInput, ChapterActivityUncheckedCreateWithoutActorInput> | ChapterActivityCreateWithoutActorInput[] | ChapterActivityUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ChapterActivityCreateOrConnectWithoutActorInput | ChapterActivityCreateOrConnectWithoutActorInput[]
    createMany?: ChapterActivityCreateManyActorInputEnvelope
    connect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
  }

  export type EditorProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<EditorProfileCreateWithoutUserInput, EditorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EditorProfileCreateOrConnectWithoutUserInput
    connect?: EditorProfileWhereUniqueInput
  }

  export type ProjectListingCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ProjectListingCreateWithoutAuthorInput, ProjectListingUncheckedCreateWithoutAuthorInput> | ProjectListingCreateWithoutAuthorInput[] | ProjectListingUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectListingCreateOrConnectWithoutAuthorInput | ProjectListingCreateOrConnectWithoutAuthorInput[]
    createMany?: ProjectListingCreateManyAuthorInputEnvelope
    connect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
  }

  export type ProjectContractCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ProjectContractCreateWithoutAuthorInput, ProjectContractUncheckedCreateWithoutAuthorInput> | ProjectContractCreateWithoutAuthorInput[] | ProjectContractUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutAuthorInput | ProjectContractCreateOrConnectWithoutAuthorInput[]
    createMany?: ProjectContractCreateManyAuthorInputEnvelope
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
  }

  export type ProjectContractCreateNestedManyWithoutEditorInput = {
    create?: XOR<ProjectContractCreateWithoutEditorInput, ProjectContractUncheckedCreateWithoutEditorInput> | ProjectContractCreateWithoutEditorInput[] | ProjectContractUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutEditorInput | ProjectContractCreateOrConnectWithoutEditorInput[]
    createMany?: ProjectContractCreateManyEditorInputEnvelope
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
  }

  export type ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutRequestedByInput, ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput> | ChapterRevisionRequestCreateWithoutRequestedByInput[] | ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutRequestedByInput | ChapterRevisionRequestCreateOrConnectWithoutRequestedByInput[]
    createMany?: ChapterRevisionRequestCreateManyRequestedByInputEnvelope
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
  }

  export type EditorReviewCreateNestedManyWithoutAuthorInput = {
    create?: XOR<EditorReviewCreateWithoutAuthorInput, EditorReviewUncheckedCreateWithoutAuthorInput> | EditorReviewCreateWithoutAuthorInput[] | EditorReviewUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutAuthorInput | EditorReviewCreateOrConnectWithoutAuthorInput[]
    createMany?: EditorReviewCreateManyAuthorInputEnvelope
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
  }

  export type WorkUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<WorkCreateWithoutAuthorInput, WorkUncheckedCreateWithoutAuthorInput> | WorkCreateWithoutAuthorInput[] | WorkUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: WorkCreateOrConnectWithoutAuthorInput | WorkCreateOrConnectWithoutAuthorInput[]
    createMany?: WorkCreateManyAuthorInputEnvelope
    connect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
  }

  export type WorkUncheckedCreateNestedManyWithoutEditorInput = {
    create?: XOR<WorkCreateWithoutEditorInput, WorkUncheckedCreateWithoutEditorInput> | WorkCreateWithoutEditorInput[] | WorkUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: WorkCreateOrConnectWithoutEditorInput | WorkCreateOrConnectWithoutEditorInput[]
    createMany?: WorkCreateManyEditorInputEnvelope
    connect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutLastEditedByInput = {
    create?: XOR<ChapterCreateWithoutLastEditedByInput, ChapterUncheckedCreateWithoutLastEditedByInput> | ChapterCreateWithoutLastEditedByInput[] | ChapterUncheckedCreateWithoutLastEditedByInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutLastEditedByInput | ChapterCreateOrConnectWithoutLastEditedByInput[]
    createMany?: ChapterCreateManyLastEditedByInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ChapterCommentCreateWithoutAuthorInput, ChapterCommentUncheckedCreateWithoutAuthorInput> | ChapterCommentCreateWithoutAuthorInput[] | ChapterCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutAuthorInput | ChapterCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: ChapterCommentCreateManyAuthorInputEnvelope
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
  }

  export type ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<ChapterCommentCreateWithoutResolvedByInput, ChapterCommentUncheckedCreateWithoutResolvedByInput> | ChapterCommentCreateWithoutResolvedByInput[] | ChapterCommentUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutResolvedByInput | ChapterCommentCreateOrConnectWithoutResolvedByInput[]
    createMany?: ChapterCommentCreateManyResolvedByInputEnvelope
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
  }

  export type ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ChapterSnapshotCreateWithoutAuthorInput, ChapterSnapshotUncheckedCreateWithoutAuthorInput> | ChapterSnapshotCreateWithoutAuthorInput[] | ChapterSnapshotUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterSnapshotCreateOrConnectWithoutAuthorInput | ChapterSnapshotCreateOrConnectWithoutAuthorInput[]
    createMany?: ChapterSnapshotCreateManyAuthorInputEnvelope
    connect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
  }

  export type ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ChapterChangeCreateWithoutAuthorInput, ChapterChangeUncheckedCreateWithoutAuthorInput> | ChapterChangeCreateWithoutAuthorInput[] | ChapterChangeUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutAuthorInput | ChapterChangeCreateOrConnectWithoutAuthorInput[]
    createMany?: ChapterChangeCreateManyAuthorInputEnvelope
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
  }

  export type ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<ChapterChangeCreateWithoutReviewedByInput, ChapterChangeUncheckedCreateWithoutReviewedByInput> | ChapterChangeCreateWithoutReviewedByInput[] | ChapterChangeUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutReviewedByInput | ChapterChangeCreateOrConnectWithoutReviewedByInput[]
    createMany?: ChapterChangeCreateManyReviewedByInputEnvelope
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
  }

  export type ChapterActivityUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<ChapterActivityCreateWithoutActorInput, ChapterActivityUncheckedCreateWithoutActorInput> | ChapterActivityCreateWithoutActorInput[] | ChapterActivityUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ChapterActivityCreateOrConnectWithoutActorInput | ChapterActivityCreateOrConnectWithoutActorInput[]
    createMany?: ChapterActivityCreateManyActorInputEnvelope
    connect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
  }

  export type EditorProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EditorProfileCreateWithoutUserInput, EditorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EditorProfileCreateOrConnectWithoutUserInput
    connect?: EditorProfileWhereUniqueInput
  }

  export type ProjectListingUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ProjectListingCreateWithoutAuthorInput, ProjectListingUncheckedCreateWithoutAuthorInput> | ProjectListingCreateWithoutAuthorInput[] | ProjectListingUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectListingCreateOrConnectWithoutAuthorInput | ProjectListingCreateOrConnectWithoutAuthorInput[]
    createMany?: ProjectListingCreateManyAuthorInputEnvelope
    connect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
  }

  export type ProjectContractUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ProjectContractCreateWithoutAuthorInput, ProjectContractUncheckedCreateWithoutAuthorInput> | ProjectContractCreateWithoutAuthorInput[] | ProjectContractUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutAuthorInput | ProjectContractCreateOrConnectWithoutAuthorInput[]
    createMany?: ProjectContractCreateManyAuthorInputEnvelope
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
  }

  export type ProjectContractUncheckedCreateNestedManyWithoutEditorInput = {
    create?: XOR<ProjectContractCreateWithoutEditorInput, ProjectContractUncheckedCreateWithoutEditorInput> | ProjectContractCreateWithoutEditorInput[] | ProjectContractUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutEditorInput | ProjectContractCreateOrConnectWithoutEditorInput[]
    createMany?: ProjectContractCreateManyEditorInputEnvelope
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
  }

  export type ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutRequestedByInput, ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput> | ChapterRevisionRequestCreateWithoutRequestedByInput[] | ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutRequestedByInput | ChapterRevisionRequestCreateOrConnectWithoutRequestedByInput[]
    createMany?: ChapterRevisionRequestCreateManyRequestedByInputEnvelope
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
  }

  export type EditorReviewUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<EditorReviewCreateWithoutAuthorInput, EditorReviewUncheckedCreateWithoutAuthorInput> | EditorReviewCreateWithoutAuthorInput[] | EditorReviewUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutAuthorInput | EditorReviewCreateOrConnectWithoutAuthorInput[]
    createMany?: EditorReviewCreateManyAuthorInputEnvelope
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type WorkUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<WorkCreateWithoutAuthorInput, WorkUncheckedCreateWithoutAuthorInput> | WorkCreateWithoutAuthorInput[] | WorkUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: WorkCreateOrConnectWithoutAuthorInput | WorkCreateOrConnectWithoutAuthorInput[]
    upsert?: WorkUpsertWithWhereUniqueWithoutAuthorInput | WorkUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: WorkCreateManyAuthorInputEnvelope
    set?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    disconnect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    delete?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    connect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    update?: WorkUpdateWithWhereUniqueWithoutAuthorInput | WorkUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: WorkUpdateManyWithWhereWithoutAuthorInput | WorkUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: WorkScalarWhereInput | WorkScalarWhereInput[]
  }

  export type WorkUpdateManyWithoutEditorNestedInput = {
    create?: XOR<WorkCreateWithoutEditorInput, WorkUncheckedCreateWithoutEditorInput> | WorkCreateWithoutEditorInput[] | WorkUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: WorkCreateOrConnectWithoutEditorInput | WorkCreateOrConnectWithoutEditorInput[]
    upsert?: WorkUpsertWithWhereUniqueWithoutEditorInput | WorkUpsertWithWhereUniqueWithoutEditorInput[]
    createMany?: WorkCreateManyEditorInputEnvelope
    set?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    disconnect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    delete?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    connect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    update?: WorkUpdateWithWhereUniqueWithoutEditorInput | WorkUpdateWithWhereUniqueWithoutEditorInput[]
    updateMany?: WorkUpdateManyWithWhereWithoutEditorInput | WorkUpdateManyWithWhereWithoutEditorInput[]
    deleteMany?: WorkScalarWhereInput | WorkScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ChapterUpdateManyWithoutLastEditedByNestedInput = {
    create?: XOR<ChapterCreateWithoutLastEditedByInput, ChapterUncheckedCreateWithoutLastEditedByInput> | ChapterCreateWithoutLastEditedByInput[] | ChapterUncheckedCreateWithoutLastEditedByInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutLastEditedByInput | ChapterCreateOrConnectWithoutLastEditedByInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutLastEditedByInput | ChapterUpsertWithWhereUniqueWithoutLastEditedByInput[]
    createMany?: ChapterCreateManyLastEditedByInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutLastEditedByInput | ChapterUpdateWithWhereUniqueWithoutLastEditedByInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutLastEditedByInput | ChapterUpdateManyWithWhereWithoutLastEditedByInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type ChapterCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ChapterCommentCreateWithoutAuthorInput, ChapterCommentUncheckedCreateWithoutAuthorInput> | ChapterCommentCreateWithoutAuthorInput[] | ChapterCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutAuthorInput | ChapterCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: ChapterCommentUpsertWithWhereUniqueWithoutAuthorInput | ChapterCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ChapterCommentCreateManyAuthorInputEnvelope
    set?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    disconnect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    delete?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    update?: ChapterCommentUpdateWithWhereUniqueWithoutAuthorInput | ChapterCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ChapterCommentUpdateManyWithWhereWithoutAuthorInput | ChapterCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ChapterCommentScalarWhereInput | ChapterCommentScalarWhereInput[]
  }

  export type ChapterCommentUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<ChapterCommentCreateWithoutResolvedByInput, ChapterCommentUncheckedCreateWithoutResolvedByInput> | ChapterCommentCreateWithoutResolvedByInput[] | ChapterCommentUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutResolvedByInput | ChapterCommentCreateOrConnectWithoutResolvedByInput[]
    upsert?: ChapterCommentUpsertWithWhereUniqueWithoutResolvedByInput | ChapterCommentUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: ChapterCommentCreateManyResolvedByInputEnvelope
    set?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    disconnect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    delete?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    update?: ChapterCommentUpdateWithWhereUniqueWithoutResolvedByInput | ChapterCommentUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: ChapterCommentUpdateManyWithWhereWithoutResolvedByInput | ChapterCommentUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: ChapterCommentScalarWhereInput | ChapterCommentScalarWhereInput[]
  }

  export type ChapterSnapshotUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ChapterSnapshotCreateWithoutAuthorInput, ChapterSnapshotUncheckedCreateWithoutAuthorInput> | ChapterSnapshotCreateWithoutAuthorInput[] | ChapterSnapshotUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterSnapshotCreateOrConnectWithoutAuthorInput | ChapterSnapshotCreateOrConnectWithoutAuthorInput[]
    upsert?: ChapterSnapshotUpsertWithWhereUniqueWithoutAuthorInput | ChapterSnapshotUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ChapterSnapshotCreateManyAuthorInputEnvelope
    set?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    disconnect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    delete?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    connect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    update?: ChapterSnapshotUpdateWithWhereUniqueWithoutAuthorInput | ChapterSnapshotUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ChapterSnapshotUpdateManyWithWhereWithoutAuthorInput | ChapterSnapshotUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ChapterSnapshotScalarWhereInput | ChapterSnapshotScalarWhereInput[]
  }

  export type ChapterChangeUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ChapterChangeCreateWithoutAuthorInput, ChapterChangeUncheckedCreateWithoutAuthorInput> | ChapterChangeCreateWithoutAuthorInput[] | ChapterChangeUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutAuthorInput | ChapterChangeCreateOrConnectWithoutAuthorInput[]
    upsert?: ChapterChangeUpsertWithWhereUniqueWithoutAuthorInput | ChapterChangeUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ChapterChangeCreateManyAuthorInputEnvelope
    set?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    disconnect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    delete?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    update?: ChapterChangeUpdateWithWhereUniqueWithoutAuthorInput | ChapterChangeUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ChapterChangeUpdateManyWithWhereWithoutAuthorInput | ChapterChangeUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ChapterChangeScalarWhereInput | ChapterChangeScalarWhereInput[]
  }

  export type ChapterChangeUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<ChapterChangeCreateWithoutReviewedByInput, ChapterChangeUncheckedCreateWithoutReviewedByInput> | ChapterChangeCreateWithoutReviewedByInput[] | ChapterChangeUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutReviewedByInput | ChapterChangeCreateOrConnectWithoutReviewedByInput[]
    upsert?: ChapterChangeUpsertWithWhereUniqueWithoutReviewedByInput | ChapterChangeUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: ChapterChangeCreateManyReviewedByInputEnvelope
    set?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    disconnect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    delete?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    update?: ChapterChangeUpdateWithWhereUniqueWithoutReviewedByInput | ChapterChangeUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: ChapterChangeUpdateManyWithWhereWithoutReviewedByInput | ChapterChangeUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: ChapterChangeScalarWhereInput | ChapterChangeScalarWhereInput[]
  }

  export type ChapterActivityUpdateManyWithoutActorNestedInput = {
    create?: XOR<ChapterActivityCreateWithoutActorInput, ChapterActivityUncheckedCreateWithoutActorInput> | ChapterActivityCreateWithoutActorInput[] | ChapterActivityUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ChapterActivityCreateOrConnectWithoutActorInput | ChapterActivityCreateOrConnectWithoutActorInput[]
    upsert?: ChapterActivityUpsertWithWhereUniqueWithoutActorInput | ChapterActivityUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: ChapterActivityCreateManyActorInputEnvelope
    set?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    disconnect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    delete?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    connect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    update?: ChapterActivityUpdateWithWhereUniqueWithoutActorInput | ChapterActivityUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: ChapterActivityUpdateManyWithWhereWithoutActorInput | ChapterActivityUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: ChapterActivityScalarWhereInput | ChapterActivityScalarWhereInput[]
  }

  export type EditorProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<EditorProfileCreateWithoutUserInput, EditorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EditorProfileCreateOrConnectWithoutUserInput
    upsert?: EditorProfileUpsertWithoutUserInput
    disconnect?: EditorProfileWhereInput | boolean
    delete?: EditorProfileWhereInput | boolean
    connect?: EditorProfileWhereUniqueInput
    update?: XOR<XOR<EditorProfileUpdateToOneWithWhereWithoutUserInput, EditorProfileUpdateWithoutUserInput>, EditorProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProjectListingUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ProjectListingCreateWithoutAuthorInput, ProjectListingUncheckedCreateWithoutAuthorInput> | ProjectListingCreateWithoutAuthorInput[] | ProjectListingUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectListingCreateOrConnectWithoutAuthorInput | ProjectListingCreateOrConnectWithoutAuthorInput[]
    upsert?: ProjectListingUpsertWithWhereUniqueWithoutAuthorInput | ProjectListingUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ProjectListingCreateManyAuthorInputEnvelope
    set?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    disconnect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    delete?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    connect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    update?: ProjectListingUpdateWithWhereUniqueWithoutAuthorInput | ProjectListingUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ProjectListingUpdateManyWithWhereWithoutAuthorInput | ProjectListingUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ProjectListingScalarWhereInput | ProjectListingScalarWhereInput[]
  }

  export type ProjectContractUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ProjectContractCreateWithoutAuthorInput, ProjectContractUncheckedCreateWithoutAuthorInput> | ProjectContractCreateWithoutAuthorInput[] | ProjectContractUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutAuthorInput | ProjectContractCreateOrConnectWithoutAuthorInput[]
    upsert?: ProjectContractUpsertWithWhereUniqueWithoutAuthorInput | ProjectContractUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ProjectContractCreateManyAuthorInputEnvelope
    set?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    disconnect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    delete?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    update?: ProjectContractUpdateWithWhereUniqueWithoutAuthorInput | ProjectContractUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ProjectContractUpdateManyWithWhereWithoutAuthorInput | ProjectContractUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ProjectContractScalarWhereInput | ProjectContractScalarWhereInput[]
  }

  export type ProjectContractUpdateManyWithoutEditorNestedInput = {
    create?: XOR<ProjectContractCreateWithoutEditorInput, ProjectContractUncheckedCreateWithoutEditorInput> | ProjectContractCreateWithoutEditorInput[] | ProjectContractUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutEditorInput | ProjectContractCreateOrConnectWithoutEditorInput[]
    upsert?: ProjectContractUpsertWithWhereUniqueWithoutEditorInput | ProjectContractUpsertWithWhereUniqueWithoutEditorInput[]
    createMany?: ProjectContractCreateManyEditorInputEnvelope
    set?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    disconnect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    delete?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    update?: ProjectContractUpdateWithWhereUniqueWithoutEditorInput | ProjectContractUpdateWithWhereUniqueWithoutEditorInput[]
    updateMany?: ProjectContractUpdateManyWithWhereWithoutEditorInput | ProjectContractUpdateManyWithWhereWithoutEditorInput[]
    deleteMany?: ProjectContractScalarWhereInput | ProjectContractScalarWhereInput[]
  }

  export type ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutRequestedByInput, ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput> | ChapterRevisionRequestCreateWithoutRequestedByInput[] | ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutRequestedByInput | ChapterRevisionRequestCreateOrConnectWithoutRequestedByInput[]
    upsert?: ChapterRevisionRequestUpsertWithWhereUniqueWithoutRequestedByInput | ChapterRevisionRequestUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: ChapterRevisionRequestCreateManyRequestedByInputEnvelope
    set?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    disconnect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    delete?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    update?: ChapterRevisionRequestUpdateWithWhereUniqueWithoutRequestedByInput | ChapterRevisionRequestUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: ChapterRevisionRequestUpdateManyWithWhereWithoutRequestedByInput | ChapterRevisionRequestUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: ChapterRevisionRequestScalarWhereInput | ChapterRevisionRequestScalarWhereInput[]
  }

  export type EditorReviewUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<EditorReviewCreateWithoutAuthorInput, EditorReviewUncheckedCreateWithoutAuthorInput> | EditorReviewCreateWithoutAuthorInput[] | EditorReviewUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutAuthorInput | EditorReviewCreateOrConnectWithoutAuthorInput[]
    upsert?: EditorReviewUpsertWithWhereUniqueWithoutAuthorInput | EditorReviewUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: EditorReviewCreateManyAuthorInputEnvelope
    set?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    disconnect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    delete?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    update?: EditorReviewUpdateWithWhereUniqueWithoutAuthorInput | EditorReviewUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: EditorReviewUpdateManyWithWhereWithoutAuthorInput | EditorReviewUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: EditorReviewScalarWhereInput | EditorReviewScalarWhereInput[]
  }

  export type WorkUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<WorkCreateWithoutAuthorInput, WorkUncheckedCreateWithoutAuthorInput> | WorkCreateWithoutAuthorInput[] | WorkUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: WorkCreateOrConnectWithoutAuthorInput | WorkCreateOrConnectWithoutAuthorInput[]
    upsert?: WorkUpsertWithWhereUniqueWithoutAuthorInput | WorkUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: WorkCreateManyAuthorInputEnvelope
    set?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    disconnect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    delete?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    connect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    update?: WorkUpdateWithWhereUniqueWithoutAuthorInput | WorkUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: WorkUpdateManyWithWhereWithoutAuthorInput | WorkUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: WorkScalarWhereInput | WorkScalarWhereInput[]
  }

  export type WorkUncheckedUpdateManyWithoutEditorNestedInput = {
    create?: XOR<WorkCreateWithoutEditorInput, WorkUncheckedCreateWithoutEditorInput> | WorkCreateWithoutEditorInput[] | WorkUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: WorkCreateOrConnectWithoutEditorInput | WorkCreateOrConnectWithoutEditorInput[]
    upsert?: WorkUpsertWithWhereUniqueWithoutEditorInput | WorkUpsertWithWhereUniqueWithoutEditorInput[]
    createMany?: WorkCreateManyEditorInputEnvelope
    set?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    disconnect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    delete?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    connect?: WorkWhereUniqueInput | WorkWhereUniqueInput[]
    update?: WorkUpdateWithWhereUniqueWithoutEditorInput | WorkUpdateWithWhereUniqueWithoutEditorInput[]
    updateMany?: WorkUpdateManyWithWhereWithoutEditorInput | WorkUpdateManyWithWhereWithoutEditorInput[]
    deleteMany?: WorkScalarWhereInput | WorkScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput = {
    create?: XOR<ChapterCreateWithoutLastEditedByInput, ChapterUncheckedCreateWithoutLastEditedByInput> | ChapterCreateWithoutLastEditedByInput[] | ChapterUncheckedCreateWithoutLastEditedByInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutLastEditedByInput | ChapterCreateOrConnectWithoutLastEditedByInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutLastEditedByInput | ChapterUpsertWithWhereUniqueWithoutLastEditedByInput[]
    createMany?: ChapterCreateManyLastEditedByInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutLastEditedByInput | ChapterUpdateWithWhereUniqueWithoutLastEditedByInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutLastEditedByInput | ChapterUpdateManyWithWhereWithoutLastEditedByInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ChapterCommentCreateWithoutAuthorInput, ChapterCommentUncheckedCreateWithoutAuthorInput> | ChapterCommentCreateWithoutAuthorInput[] | ChapterCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutAuthorInput | ChapterCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: ChapterCommentUpsertWithWhereUniqueWithoutAuthorInput | ChapterCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ChapterCommentCreateManyAuthorInputEnvelope
    set?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    disconnect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    delete?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    update?: ChapterCommentUpdateWithWhereUniqueWithoutAuthorInput | ChapterCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ChapterCommentUpdateManyWithWhereWithoutAuthorInput | ChapterCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ChapterCommentScalarWhereInput | ChapterCommentScalarWhereInput[]
  }

  export type ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<ChapterCommentCreateWithoutResolvedByInput, ChapterCommentUncheckedCreateWithoutResolvedByInput> | ChapterCommentCreateWithoutResolvedByInput[] | ChapterCommentUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutResolvedByInput | ChapterCommentCreateOrConnectWithoutResolvedByInput[]
    upsert?: ChapterCommentUpsertWithWhereUniqueWithoutResolvedByInput | ChapterCommentUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: ChapterCommentCreateManyResolvedByInputEnvelope
    set?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    disconnect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    delete?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    update?: ChapterCommentUpdateWithWhereUniqueWithoutResolvedByInput | ChapterCommentUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: ChapterCommentUpdateManyWithWhereWithoutResolvedByInput | ChapterCommentUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: ChapterCommentScalarWhereInput | ChapterCommentScalarWhereInput[]
  }

  export type ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ChapterSnapshotCreateWithoutAuthorInput, ChapterSnapshotUncheckedCreateWithoutAuthorInput> | ChapterSnapshotCreateWithoutAuthorInput[] | ChapterSnapshotUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterSnapshotCreateOrConnectWithoutAuthorInput | ChapterSnapshotCreateOrConnectWithoutAuthorInput[]
    upsert?: ChapterSnapshotUpsertWithWhereUniqueWithoutAuthorInput | ChapterSnapshotUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ChapterSnapshotCreateManyAuthorInputEnvelope
    set?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    disconnect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    delete?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    connect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    update?: ChapterSnapshotUpdateWithWhereUniqueWithoutAuthorInput | ChapterSnapshotUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ChapterSnapshotUpdateManyWithWhereWithoutAuthorInput | ChapterSnapshotUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ChapterSnapshotScalarWhereInput | ChapterSnapshotScalarWhereInput[]
  }

  export type ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ChapterChangeCreateWithoutAuthorInput, ChapterChangeUncheckedCreateWithoutAuthorInput> | ChapterChangeCreateWithoutAuthorInput[] | ChapterChangeUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutAuthorInput | ChapterChangeCreateOrConnectWithoutAuthorInput[]
    upsert?: ChapterChangeUpsertWithWhereUniqueWithoutAuthorInput | ChapterChangeUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ChapterChangeCreateManyAuthorInputEnvelope
    set?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    disconnect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    delete?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    update?: ChapterChangeUpdateWithWhereUniqueWithoutAuthorInput | ChapterChangeUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ChapterChangeUpdateManyWithWhereWithoutAuthorInput | ChapterChangeUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ChapterChangeScalarWhereInput | ChapterChangeScalarWhereInput[]
  }

  export type ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<ChapterChangeCreateWithoutReviewedByInput, ChapterChangeUncheckedCreateWithoutReviewedByInput> | ChapterChangeCreateWithoutReviewedByInput[] | ChapterChangeUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutReviewedByInput | ChapterChangeCreateOrConnectWithoutReviewedByInput[]
    upsert?: ChapterChangeUpsertWithWhereUniqueWithoutReviewedByInput | ChapterChangeUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: ChapterChangeCreateManyReviewedByInputEnvelope
    set?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    disconnect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    delete?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    update?: ChapterChangeUpdateWithWhereUniqueWithoutReviewedByInput | ChapterChangeUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: ChapterChangeUpdateManyWithWhereWithoutReviewedByInput | ChapterChangeUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: ChapterChangeScalarWhereInput | ChapterChangeScalarWhereInput[]
  }

  export type ChapterActivityUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<ChapterActivityCreateWithoutActorInput, ChapterActivityUncheckedCreateWithoutActorInput> | ChapterActivityCreateWithoutActorInput[] | ChapterActivityUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ChapterActivityCreateOrConnectWithoutActorInput | ChapterActivityCreateOrConnectWithoutActorInput[]
    upsert?: ChapterActivityUpsertWithWhereUniqueWithoutActorInput | ChapterActivityUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: ChapterActivityCreateManyActorInputEnvelope
    set?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    disconnect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    delete?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    connect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    update?: ChapterActivityUpdateWithWhereUniqueWithoutActorInput | ChapterActivityUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: ChapterActivityUpdateManyWithWhereWithoutActorInput | ChapterActivityUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: ChapterActivityScalarWhereInput | ChapterActivityScalarWhereInput[]
  }

  export type EditorProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EditorProfileCreateWithoutUserInput, EditorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EditorProfileCreateOrConnectWithoutUserInput
    upsert?: EditorProfileUpsertWithoutUserInput
    disconnect?: EditorProfileWhereInput | boolean
    delete?: EditorProfileWhereInput | boolean
    connect?: EditorProfileWhereUniqueInput
    update?: XOR<XOR<EditorProfileUpdateToOneWithWhereWithoutUserInput, EditorProfileUpdateWithoutUserInput>, EditorProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ProjectListingCreateWithoutAuthorInput, ProjectListingUncheckedCreateWithoutAuthorInput> | ProjectListingCreateWithoutAuthorInput[] | ProjectListingUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectListingCreateOrConnectWithoutAuthorInput | ProjectListingCreateOrConnectWithoutAuthorInput[]
    upsert?: ProjectListingUpsertWithWhereUniqueWithoutAuthorInput | ProjectListingUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ProjectListingCreateManyAuthorInputEnvelope
    set?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    disconnect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    delete?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    connect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    update?: ProjectListingUpdateWithWhereUniqueWithoutAuthorInput | ProjectListingUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ProjectListingUpdateManyWithWhereWithoutAuthorInput | ProjectListingUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ProjectListingScalarWhereInput | ProjectListingScalarWhereInput[]
  }

  export type ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ProjectContractCreateWithoutAuthorInput, ProjectContractUncheckedCreateWithoutAuthorInput> | ProjectContractCreateWithoutAuthorInput[] | ProjectContractUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutAuthorInput | ProjectContractCreateOrConnectWithoutAuthorInput[]
    upsert?: ProjectContractUpsertWithWhereUniqueWithoutAuthorInput | ProjectContractUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ProjectContractCreateManyAuthorInputEnvelope
    set?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    disconnect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    delete?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    update?: ProjectContractUpdateWithWhereUniqueWithoutAuthorInput | ProjectContractUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ProjectContractUpdateManyWithWhereWithoutAuthorInput | ProjectContractUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ProjectContractScalarWhereInput | ProjectContractScalarWhereInput[]
  }

  export type ProjectContractUncheckedUpdateManyWithoutEditorNestedInput = {
    create?: XOR<ProjectContractCreateWithoutEditorInput, ProjectContractUncheckedCreateWithoutEditorInput> | ProjectContractCreateWithoutEditorInput[] | ProjectContractUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutEditorInput | ProjectContractCreateOrConnectWithoutEditorInput[]
    upsert?: ProjectContractUpsertWithWhereUniqueWithoutEditorInput | ProjectContractUpsertWithWhereUniqueWithoutEditorInput[]
    createMany?: ProjectContractCreateManyEditorInputEnvelope
    set?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    disconnect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    delete?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    update?: ProjectContractUpdateWithWhereUniqueWithoutEditorInput | ProjectContractUpdateWithWhereUniqueWithoutEditorInput[]
    updateMany?: ProjectContractUpdateManyWithWhereWithoutEditorInput | ProjectContractUpdateManyWithWhereWithoutEditorInput[]
    deleteMany?: ProjectContractScalarWhereInput | ProjectContractScalarWhereInput[]
  }

  export type ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutRequestedByInput, ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput> | ChapterRevisionRequestCreateWithoutRequestedByInput[] | ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutRequestedByInput | ChapterRevisionRequestCreateOrConnectWithoutRequestedByInput[]
    upsert?: ChapterRevisionRequestUpsertWithWhereUniqueWithoutRequestedByInput | ChapterRevisionRequestUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: ChapterRevisionRequestCreateManyRequestedByInputEnvelope
    set?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    disconnect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    delete?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    update?: ChapterRevisionRequestUpdateWithWhereUniqueWithoutRequestedByInput | ChapterRevisionRequestUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: ChapterRevisionRequestUpdateManyWithWhereWithoutRequestedByInput | ChapterRevisionRequestUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: ChapterRevisionRequestScalarWhereInput | ChapterRevisionRequestScalarWhereInput[]
  }

  export type EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<EditorReviewCreateWithoutAuthorInput, EditorReviewUncheckedCreateWithoutAuthorInput> | EditorReviewCreateWithoutAuthorInput[] | EditorReviewUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutAuthorInput | EditorReviewCreateOrConnectWithoutAuthorInput[]
    upsert?: EditorReviewUpsertWithWhereUniqueWithoutAuthorInput | EditorReviewUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: EditorReviewCreateManyAuthorInputEnvelope
    set?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    disconnect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    delete?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    update?: EditorReviewUpdateWithWhereUniqueWithoutAuthorInput | EditorReviewUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: EditorReviewUpdateManyWithWhereWithoutAuthorInput | EditorReviewUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: EditorReviewScalarWhereInput | EditorReviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type WorkCreategenresInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutWorksInput = {
    create?: XOR<UserCreateWithoutWorksInput, UserUncheckedCreateWithoutWorksInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorksInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEditingWorksInput = {
    create?: XOR<UserCreateWithoutEditingWorksInput, UserUncheckedCreateWithoutEditingWorksInput>
    connectOrCreate?: UserCreateOrConnectWithoutEditingWorksInput
    connect?: UserWhereUniqueInput
  }

  export type ChapterCreateNestedManyWithoutWorkInput = {
    create?: XOR<ChapterCreateWithoutWorkInput, ChapterUncheckedCreateWithoutWorkInput> | ChapterCreateWithoutWorkInput[] | ChapterUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutWorkInput | ChapterCreateOrConnectWithoutWorkInput[]
    createMany?: ChapterCreateManyWorkInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type GlossaryItemCreateNestedManyWithoutWorkInput = {
    create?: XOR<GlossaryItemCreateWithoutWorkInput, GlossaryItemUncheckedCreateWithoutWorkInput> | GlossaryItemCreateWithoutWorkInput[] | GlossaryItemUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: GlossaryItemCreateOrConnectWithoutWorkInput | GlossaryItemCreateOrConnectWithoutWorkInput[]
    createMany?: GlossaryItemCreateManyWorkInputEnvelope
    connect?: GlossaryItemWhereUniqueInput | GlossaryItemWhereUniqueInput[]
  }

  export type CreatorCreateNestedManyWithoutWorkInput = {
    create?: XOR<CreatorCreateWithoutWorkInput, CreatorUncheckedCreateWithoutWorkInput> | CreatorCreateWithoutWorkInput[] | CreatorUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: CreatorCreateOrConnectWithoutWorkInput | CreatorCreateOrConnectWithoutWorkInput[]
    createMany?: CreatorCreateManyWorkInputEnvelope
    connect?: CreatorWhereUniqueInput | CreatorWhereUniqueInput[]
  }

  export type SettingBibleCreateNestedOneWithoutWorkInput = {
    create?: XOR<SettingBibleCreateWithoutWorkInput, SettingBibleUncheckedCreateWithoutWorkInput>
    connectOrCreate?: SettingBibleCreateOrConnectWithoutWorkInput
    connect?: SettingBibleWhereUniqueInput
  }

  export type BibleGenerationJobCreateNestedManyWithoutWorkInput = {
    create?: XOR<BibleGenerationJobCreateWithoutWorkInput, BibleGenerationJobUncheckedCreateWithoutWorkInput> | BibleGenerationJobCreateWithoutWorkInput[] | BibleGenerationJobUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: BibleGenerationJobCreateOrConnectWithoutWorkInput | BibleGenerationJobCreateOrConnectWithoutWorkInput[]
    createMany?: BibleGenerationJobCreateManyWorkInputEnvelope
    connect?: BibleGenerationJobWhereUniqueInput | BibleGenerationJobWhereUniqueInput[]
  }

  export type ProjectListingCreateNestedManyWithoutWorkInput = {
    create?: XOR<ProjectListingCreateWithoutWorkInput, ProjectListingUncheckedCreateWithoutWorkInput> | ProjectListingCreateWithoutWorkInput[] | ProjectListingUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ProjectListingCreateOrConnectWithoutWorkInput | ProjectListingCreateOrConnectWithoutWorkInput[]
    createMany?: ProjectListingCreateManyWorkInputEnvelope
    connect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
  }

  export type ProjectContractCreateNestedManyWithoutWorkInput = {
    create?: XOR<ProjectContractCreateWithoutWorkInput, ProjectContractUncheckedCreateWithoutWorkInput> | ProjectContractCreateWithoutWorkInput[] | ProjectContractUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutWorkInput | ProjectContractCreateOrConnectWithoutWorkInput[]
    createMany?: ProjectContractCreateManyWorkInputEnvelope
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
  }

  export type EditorReviewCreateNestedManyWithoutWorkInput = {
    create?: XOR<EditorReviewCreateWithoutWorkInput, EditorReviewUncheckedCreateWithoutWorkInput> | EditorReviewCreateWithoutWorkInput[] | EditorReviewUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutWorkInput | EditorReviewCreateOrConnectWithoutWorkInput[]
    createMany?: EditorReviewCreateManyWorkInputEnvelope
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<ChapterCreateWithoutWorkInput, ChapterUncheckedCreateWithoutWorkInput> | ChapterCreateWithoutWorkInput[] | ChapterUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutWorkInput | ChapterCreateOrConnectWithoutWorkInput[]
    createMany?: ChapterCreateManyWorkInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type GlossaryItemUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<GlossaryItemCreateWithoutWorkInput, GlossaryItemUncheckedCreateWithoutWorkInput> | GlossaryItemCreateWithoutWorkInput[] | GlossaryItemUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: GlossaryItemCreateOrConnectWithoutWorkInput | GlossaryItemCreateOrConnectWithoutWorkInput[]
    createMany?: GlossaryItemCreateManyWorkInputEnvelope
    connect?: GlossaryItemWhereUniqueInput | GlossaryItemWhereUniqueInput[]
  }

  export type CreatorUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<CreatorCreateWithoutWorkInput, CreatorUncheckedCreateWithoutWorkInput> | CreatorCreateWithoutWorkInput[] | CreatorUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: CreatorCreateOrConnectWithoutWorkInput | CreatorCreateOrConnectWithoutWorkInput[]
    createMany?: CreatorCreateManyWorkInputEnvelope
    connect?: CreatorWhereUniqueInput | CreatorWhereUniqueInput[]
  }

  export type SettingBibleUncheckedCreateNestedOneWithoutWorkInput = {
    create?: XOR<SettingBibleCreateWithoutWorkInput, SettingBibleUncheckedCreateWithoutWorkInput>
    connectOrCreate?: SettingBibleCreateOrConnectWithoutWorkInput
    connect?: SettingBibleWhereUniqueInput
  }

  export type BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<BibleGenerationJobCreateWithoutWorkInput, BibleGenerationJobUncheckedCreateWithoutWorkInput> | BibleGenerationJobCreateWithoutWorkInput[] | BibleGenerationJobUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: BibleGenerationJobCreateOrConnectWithoutWorkInput | BibleGenerationJobCreateOrConnectWithoutWorkInput[]
    createMany?: BibleGenerationJobCreateManyWorkInputEnvelope
    connect?: BibleGenerationJobWhereUniqueInput | BibleGenerationJobWhereUniqueInput[]
  }

  export type ProjectListingUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<ProjectListingCreateWithoutWorkInput, ProjectListingUncheckedCreateWithoutWorkInput> | ProjectListingCreateWithoutWorkInput[] | ProjectListingUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ProjectListingCreateOrConnectWithoutWorkInput | ProjectListingCreateOrConnectWithoutWorkInput[]
    createMany?: ProjectListingCreateManyWorkInputEnvelope
    connect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
  }

  export type ProjectContractUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<ProjectContractCreateWithoutWorkInput, ProjectContractUncheckedCreateWithoutWorkInput> | ProjectContractCreateWithoutWorkInput[] | ProjectContractUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutWorkInput | ProjectContractCreateOrConnectWithoutWorkInput[]
    createMany?: ProjectContractCreateManyWorkInputEnvelope
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
  }

  export type EditorReviewUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<EditorReviewCreateWithoutWorkInput, EditorReviewUncheckedCreateWithoutWorkInput> | EditorReviewCreateWithoutWorkInput[] | EditorReviewUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutWorkInput | EditorReviewCreateOrConnectWithoutWorkInput[]
    createMany?: EditorReviewCreateManyWorkInputEnvelope
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
  }

  export type EnumAgeRatingFieldUpdateOperationsInput = {
    set?: $Enums.AgeRating
  }

  export type EnumWorkStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkStatus
  }

  export type WorkUpdategenresInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumOriginalStatusFieldUpdateOperationsInput = {
    set?: $Enums.OriginalStatus
  }

  export type EnumSourceLanguageFieldUpdateOperationsInput = {
    set?: $Enums.SourceLanguage
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutWorksNestedInput = {
    create?: XOR<UserCreateWithoutWorksInput, UserUncheckedCreateWithoutWorksInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorksInput
    upsert?: UserUpsertWithoutWorksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorksInput, UserUpdateWithoutWorksInput>, UserUncheckedUpdateWithoutWorksInput>
  }

  export type UserUpdateOneWithoutEditingWorksNestedInput = {
    create?: XOR<UserCreateWithoutEditingWorksInput, UserUncheckedCreateWithoutEditingWorksInput>
    connectOrCreate?: UserCreateOrConnectWithoutEditingWorksInput
    upsert?: UserUpsertWithoutEditingWorksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEditingWorksInput, UserUpdateWithoutEditingWorksInput>, UserUncheckedUpdateWithoutEditingWorksInput>
  }

  export type ChapterUpdateManyWithoutWorkNestedInput = {
    create?: XOR<ChapterCreateWithoutWorkInput, ChapterUncheckedCreateWithoutWorkInput> | ChapterCreateWithoutWorkInput[] | ChapterUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutWorkInput | ChapterCreateOrConnectWithoutWorkInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutWorkInput | ChapterUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: ChapterCreateManyWorkInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutWorkInput | ChapterUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutWorkInput | ChapterUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type GlossaryItemUpdateManyWithoutWorkNestedInput = {
    create?: XOR<GlossaryItemCreateWithoutWorkInput, GlossaryItemUncheckedCreateWithoutWorkInput> | GlossaryItemCreateWithoutWorkInput[] | GlossaryItemUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: GlossaryItemCreateOrConnectWithoutWorkInput | GlossaryItemCreateOrConnectWithoutWorkInput[]
    upsert?: GlossaryItemUpsertWithWhereUniqueWithoutWorkInput | GlossaryItemUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: GlossaryItemCreateManyWorkInputEnvelope
    set?: GlossaryItemWhereUniqueInput | GlossaryItemWhereUniqueInput[]
    disconnect?: GlossaryItemWhereUniqueInput | GlossaryItemWhereUniqueInput[]
    delete?: GlossaryItemWhereUniqueInput | GlossaryItemWhereUniqueInput[]
    connect?: GlossaryItemWhereUniqueInput | GlossaryItemWhereUniqueInput[]
    update?: GlossaryItemUpdateWithWhereUniqueWithoutWorkInput | GlossaryItemUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: GlossaryItemUpdateManyWithWhereWithoutWorkInput | GlossaryItemUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: GlossaryItemScalarWhereInput | GlossaryItemScalarWhereInput[]
  }

  export type CreatorUpdateManyWithoutWorkNestedInput = {
    create?: XOR<CreatorCreateWithoutWorkInput, CreatorUncheckedCreateWithoutWorkInput> | CreatorCreateWithoutWorkInput[] | CreatorUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: CreatorCreateOrConnectWithoutWorkInput | CreatorCreateOrConnectWithoutWorkInput[]
    upsert?: CreatorUpsertWithWhereUniqueWithoutWorkInput | CreatorUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: CreatorCreateManyWorkInputEnvelope
    set?: CreatorWhereUniqueInput | CreatorWhereUniqueInput[]
    disconnect?: CreatorWhereUniqueInput | CreatorWhereUniqueInput[]
    delete?: CreatorWhereUniqueInput | CreatorWhereUniqueInput[]
    connect?: CreatorWhereUniqueInput | CreatorWhereUniqueInput[]
    update?: CreatorUpdateWithWhereUniqueWithoutWorkInput | CreatorUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: CreatorUpdateManyWithWhereWithoutWorkInput | CreatorUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: CreatorScalarWhereInput | CreatorScalarWhereInput[]
  }

  export type SettingBibleUpdateOneWithoutWorkNestedInput = {
    create?: XOR<SettingBibleCreateWithoutWorkInput, SettingBibleUncheckedCreateWithoutWorkInput>
    connectOrCreate?: SettingBibleCreateOrConnectWithoutWorkInput
    upsert?: SettingBibleUpsertWithoutWorkInput
    disconnect?: SettingBibleWhereInput | boolean
    delete?: SettingBibleWhereInput | boolean
    connect?: SettingBibleWhereUniqueInput
    update?: XOR<XOR<SettingBibleUpdateToOneWithWhereWithoutWorkInput, SettingBibleUpdateWithoutWorkInput>, SettingBibleUncheckedUpdateWithoutWorkInput>
  }

  export type BibleGenerationJobUpdateManyWithoutWorkNestedInput = {
    create?: XOR<BibleGenerationJobCreateWithoutWorkInput, BibleGenerationJobUncheckedCreateWithoutWorkInput> | BibleGenerationJobCreateWithoutWorkInput[] | BibleGenerationJobUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: BibleGenerationJobCreateOrConnectWithoutWorkInput | BibleGenerationJobCreateOrConnectWithoutWorkInput[]
    upsert?: BibleGenerationJobUpsertWithWhereUniqueWithoutWorkInput | BibleGenerationJobUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: BibleGenerationJobCreateManyWorkInputEnvelope
    set?: BibleGenerationJobWhereUniqueInput | BibleGenerationJobWhereUniqueInput[]
    disconnect?: BibleGenerationJobWhereUniqueInput | BibleGenerationJobWhereUniqueInput[]
    delete?: BibleGenerationJobWhereUniqueInput | BibleGenerationJobWhereUniqueInput[]
    connect?: BibleGenerationJobWhereUniqueInput | BibleGenerationJobWhereUniqueInput[]
    update?: BibleGenerationJobUpdateWithWhereUniqueWithoutWorkInput | BibleGenerationJobUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: BibleGenerationJobUpdateManyWithWhereWithoutWorkInput | BibleGenerationJobUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: BibleGenerationJobScalarWhereInput | BibleGenerationJobScalarWhereInput[]
  }

  export type ProjectListingUpdateManyWithoutWorkNestedInput = {
    create?: XOR<ProjectListingCreateWithoutWorkInput, ProjectListingUncheckedCreateWithoutWorkInput> | ProjectListingCreateWithoutWorkInput[] | ProjectListingUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ProjectListingCreateOrConnectWithoutWorkInput | ProjectListingCreateOrConnectWithoutWorkInput[]
    upsert?: ProjectListingUpsertWithWhereUniqueWithoutWorkInput | ProjectListingUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: ProjectListingCreateManyWorkInputEnvelope
    set?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    disconnect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    delete?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    connect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    update?: ProjectListingUpdateWithWhereUniqueWithoutWorkInput | ProjectListingUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: ProjectListingUpdateManyWithWhereWithoutWorkInput | ProjectListingUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: ProjectListingScalarWhereInput | ProjectListingScalarWhereInput[]
  }

  export type ProjectContractUpdateManyWithoutWorkNestedInput = {
    create?: XOR<ProjectContractCreateWithoutWorkInput, ProjectContractUncheckedCreateWithoutWorkInput> | ProjectContractCreateWithoutWorkInput[] | ProjectContractUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutWorkInput | ProjectContractCreateOrConnectWithoutWorkInput[]
    upsert?: ProjectContractUpsertWithWhereUniqueWithoutWorkInput | ProjectContractUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: ProjectContractCreateManyWorkInputEnvelope
    set?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    disconnect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    delete?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    update?: ProjectContractUpdateWithWhereUniqueWithoutWorkInput | ProjectContractUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: ProjectContractUpdateManyWithWhereWithoutWorkInput | ProjectContractUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: ProjectContractScalarWhereInput | ProjectContractScalarWhereInput[]
  }

  export type EditorReviewUpdateManyWithoutWorkNestedInput = {
    create?: XOR<EditorReviewCreateWithoutWorkInput, EditorReviewUncheckedCreateWithoutWorkInput> | EditorReviewCreateWithoutWorkInput[] | EditorReviewUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutWorkInput | EditorReviewCreateOrConnectWithoutWorkInput[]
    upsert?: EditorReviewUpsertWithWhereUniqueWithoutWorkInput | EditorReviewUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: EditorReviewCreateManyWorkInputEnvelope
    set?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    disconnect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    delete?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    update?: EditorReviewUpdateWithWhereUniqueWithoutWorkInput | EditorReviewUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: EditorReviewUpdateManyWithWhereWithoutWorkInput | EditorReviewUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: EditorReviewScalarWhereInput | EditorReviewScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<ChapterCreateWithoutWorkInput, ChapterUncheckedCreateWithoutWorkInput> | ChapterCreateWithoutWorkInput[] | ChapterUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutWorkInput | ChapterCreateOrConnectWithoutWorkInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutWorkInput | ChapterUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: ChapterCreateManyWorkInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutWorkInput | ChapterUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutWorkInput | ChapterUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<GlossaryItemCreateWithoutWorkInput, GlossaryItemUncheckedCreateWithoutWorkInput> | GlossaryItemCreateWithoutWorkInput[] | GlossaryItemUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: GlossaryItemCreateOrConnectWithoutWorkInput | GlossaryItemCreateOrConnectWithoutWorkInput[]
    upsert?: GlossaryItemUpsertWithWhereUniqueWithoutWorkInput | GlossaryItemUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: GlossaryItemCreateManyWorkInputEnvelope
    set?: GlossaryItemWhereUniqueInput | GlossaryItemWhereUniqueInput[]
    disconnect?: GlossaryItemWhereUniqueInput | GlossaryItemWhereUniqueInput[]
    delete?: GlossaryItemWhereUniqueInput | GlossaryItemWhereUniqueInput[]
    connect?: GlossaryItemWhereUniqueInput | GlossaryItemWhereUniqueInput[]
    update?: GlossaryItemUpdateWithWhereUniqueWithoutWorkInput | GlossaryItemUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: GlossaryItemUpdateManyWithWhereWithoutWorkInput | GlossaryItemUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: GlossaryItemScalarWhereInput | GlossaryItemScalarWhereInput[]
  }

  export type CreatorUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<CreatorCreateWithoutWorkInput, CreatorUncheckedCreateWithoutWorkInput> | CreatorCreateWithoutWorkInput[] | CreatorUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: CreatorCreateOrConnectWithoutWorkInput | CreatorCreateOrConnectWithoutWorkInput[]
    upsert?: CreatorUpsertWithWhereUniqueWithoutWorkInput | CreatorUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: CreatorCreateManyWorkInputEnvelope
    set?: CreatorWhereUniqueInput | CreatorWhereUniqueInput[]
    disconnect?: CreatorWhereUniqueInput | CreatorWhereUniqueInput[]
    delete?: CreatorWhereUniqueInput | CreatorWhereUniqueInput[]
    connect?: CreatorWhereUniqueInput | CreatorWhereUniqueInput[]
    update?: CreatorUpdateWithWhereUniqueWithoutWorkInput | CreatorUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: CreatorUpdateManyWithWhereWithoutWorkInput | CreatorUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: CreatorScalarWhereInput | CreatorScalarWhereInput[]
  }

  export type SettingBibleUncheckedUpdateOneWithoutWorkNestedInput = {
    create?: XOR<SettingBibleCreateWithoutWorkInput, SettingBibleUncheckedCreateWithoutWorkInput>
    connectOrCreate?: SettingBibleCreateOrConnectWithoutWorkInput
    upsert?: SettingBibleUpsertWithoutWorkInput
    disconnect?: SettingBibleWhereInput | boolean
    delete?: SettingBibleWhereInput | boolean
    connect?: SettingBibleWhereUniqueInput
    update?: XOR<XOR<SettingBibleUpdateToOneWithWhereWithoutWorkInput, SettingBibleUpdateWithoutWorkInput>, SettingBibleUncheckedUpdateWithoutWorkInput>
  }

  export type BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<BibleGenerationJobCreateWithoutWorkInput, BibleGenerationJobUncheckedCreateWithoutWorkInput> | BibleGenerationJobCreateWithoutWorkInput[] | BibleGenerationJobUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: BibleGenerationJobCreateOrConnectWithoutWorkInput | BibleGenerationJobCreateOrConnectWithoutWorkInput[]
    upsert?: BibleGenerationJobUpsertWithWhereUniqueWithoutWorkInput | BibleGenerationJobUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: BibleGenerationJobCreateManyWorkInputEnvelope
    set?: BibleGenerationJobWhereUniqueInput | BibleGenerationJobWhereUniqueInput[]
    disconnect?: BibleGenerationJobWhereUniqueInput | BibleGenerationJobWhereUniqueInput[]
    delete?: BibleGenerationJobWhereUniqueInput | BibleGenerationJobWhereUniqueInput[]
    connect?: BibleGenerationJobWhereUniqueInput | BibleGenerationJobWhereUniqueInput[]
    update?: BibleGenerationJobUpdateWithWhereUniqueWithoutWorkInput | BibleGenerationJobUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: BibleGenerationJobUpdateManyWithWhereWithoutWorkInput | BibleGenerationJobUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: BibleGenerationJobScalarWhereInput | BibleGenerationJobScalarWhereInput[]
  }

  export type ProjectListingUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<ProjectListingCreateWithoutWorkInput, ProjectListingUncheckedCreateWithoutWorkInput> | ProjectListingCreateWithoutWorkInput[] | ProjectListingUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ProjectListingCreateOrConnectWithoutWorkInput | ProjectListingCreateOrConnectWithoutWorkInput[]
    upsert?: ProjectListingUpsertWithWhereUniqueWithoutWorkInput | ProjectListingUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: ProjectListingCreateManyWorkInputEnvelope
    set?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    disconnect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    delete?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    connect?: ProjectListingWhereUniqueInput | ProjectListingWhereUniqueInput[]
    update?: ProjectListingUpdateWithWhereUniqueWithoutWorkInput | ProjectListingUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: ProjectListingUpdateManyWithWhereWithoutWorkInput | ProjectListingUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: ProjectListingScalarWhereInput | ProjectListingScalarWhereInput[]
  }

  export type ProjectContractUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<ProjectContractCreateWithoutWorkInput, ProjectContractUncheckedCreateWithoutWorkInput> | ProjectContractCreateWithoutWorkInput[] | ProjectContractUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: ProjectContractCreateOrConnectWithoutWorkInput | ProjectContractCreateOrConnectWithoutWorkInput[]
    upsert?: ProjectContractUpsertWithWhereUniqueWithoutWorkInput | ProjectContractUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: ProjectContractCreateManyWorkInputEnvelope
    set?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    disconnect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    delete?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    connect?: ProjectContractWhereUniqueInput | ProjectContractWhereUniqueInput[]
    update?: ProjectContractUpdateWithWhereUniqueWithoutWorkInput | ProjectContractUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: ProjectContractUpdateManyWithWhereWithoutWorkInput | ProjectContractUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: ProjectContractScalarWhereInput | ProjectContractScalarWhereInput[]
  }

  export type EditorReviewUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<EditorReviewCreateWithoutWorkInput, EditorReviewUncheckedCreateWithoutWorkInput> | EditorReviewCreateWithoutWorkInput[] | EditorReviewUncheckedCreateWithoutWorkInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutWorkInput | EditorReviewCreateOrConnectWithoutWorkInput[]
    upsert?: EditorReviewUpsertWithWhereUniqueWithoutWorkInput | EditorReviewUpsertWithWhereUniqueWithoutWorkInput[]
    createMany?: EditorReviewCreateManyWorkInputEnvelope
    set?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    disconnect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    delete?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    update?: EditorReviewUpdateWithWhereUniqueWithoutWorkInput | EditorReviewUpdateWithWhereUniqueWithoutWorkInput[]
    updateMany?: EditorReviewUpdateManyWithWhereWithoutWorkInput | EditorReviewUpdateManyWithWhereWithoutWorkInput[]
    deleteMany?: EditorReviewScalarWhereInput | EditorReviewScalarWhereInput[]
  }

  export type WorkCreateNestedOneWithoutCreatorsInput = {
    create?: XOR<WorkCreateWithoutCreatorsInput, WorkUncheckedCreateWithoutCreatorsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutCreatorsInput
    connect?: WorkWhereUniqueInput
  }

  export type WorkUpdateOneRequiredWithoutCreatorsNestedInput = {
    create?: XOR<WorkCreateWithoutCreatorsInput, WorkUncheckedCreateWithoutCreatorsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutCreatorsInput
    upsert?: WorkUpsertWithoutCreatorsInput
    connect?: WorkWhereUniqueInput
    update?: XOR<XOR<WorkUpdateToOneWithWhereWithoutCreatorsInput, WorkUpdateWithoutCreatorsInput>, WorkUncheckedUpdateWithoutCreatorsInput>
  }

  export type UserCreateNestedOneWithoutLastEditedChaptersInput = {
    create?: XOR<UserCreateWithoutLastEditedChaptersInput, UserUncheckedCreateWithoutLastEditedChaptersInput>
    connectOrCreate?: UserCreateOrConnectWithoutLastEditedChaptersInput
    connect?: UserWhereUniqueInput
  }

  export type WorkCreateNestedOneWithoutChaptersInput = {
    create?: XOR<WorkCreateWithoutChaptersInput, WorkUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: WorkCreateOrConnectWithoutChaptersInput
    connect?: WorkWhereUniqueInput
  }

  export type ChapterCommentCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterCommentCreateWithoutChapterInput, ChapterCommentUncheckedCreateWithoutChapterInput> | ChapterCommentCreateWithoutChapterInput[] | ChapterCommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutChapterInput | ChapterCommentCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterCommentCreateManyChapterInputEnvelope
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
  }

  export type ChapterSnapshotCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterSnapshotCreateWithoutChapterInput, ChapterSnapshotUncheckedCreateWithoutChapterInput> | ChapterSnapshotCreateWithoutChapterInput[] | ChapterSnapshotUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterSnapshotCreateOrConnectWithoutChapterInput | ChapterSnapshotCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterSnapshotCreateManyChapterInputEnvelope
    connect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
  }

  export type ChapterChangeCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterChangeCreateWithoutChapterInput, ChapterChangeUncheckedCreateWithoutChapterInput> | ChapterChangeCreateWithoutChapterInput[] | ChapterChangeUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutChapterInput | ChapterChangeCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterChangeCreateManyChapterInputEnvelope
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
  }

  export type ChapterActivityCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterActivityCreateWithoutChapterInput, ChapterActivityUncheckedCreateWithoutChapterInput> | ChapterActivityCreateWithoutChapterInput[] | ChapterActivityUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterActivityCreateOrConnectWithoutChapterInput | ChapterActivityCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterActivityCreateManyChapterInputEnvelope
    connect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
  }

  export type ChapterRevisionRequestCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutChapterInput, ChapterRevisionRequestUncheckedCreateWithoutChapterInput> | ChapterRevisionRequestCreateWithoutChapterInput[] | ChapterRevisionRequestUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutChapterInput | ChapterRevisionRequestCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterRevisionRequestCreateManyChapterInputEnvelope
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
  }

  export type ChapterCommentUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterCommentCreateWithoutChapterInput, ChapterCommentUncheckedCreateWithoutChapterInput> | ChapterCommentCreateWithoutChapterInput[] | ChapterCommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutChapterInput | ChapterCommentCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterCommentCreateManyChapterInputEnvelope
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
  }

  export type ChapterSnapshotUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterSnapshotCreateWithoutChapterInput, ChapterSnapshotUncheckedCreateWithoutChapterInput> | ChapterSnapshotCreateWithoutChapterInput[] | ChapterSnapshotUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterSnapshotCreateOrConnectWithoutChapterInput | ChapterSnapshotCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterSnapshotCreateManyChapterInputEnvelope
    connect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
  }

  export type ChapterChangeUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterChangeCreateWithoutChapterInput, ChapterChangeUncheckedCreateWithoutChapterInput> | ChapterChangeCreateWithoutChapterInput[] | ChapterChangeUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutChapterInput | ChapterChangeCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterChangeCreateManyChapterInputEnvelope
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
  }

  export type ChapterActivityUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterActivityCreateWithoutChapterInput, ChapterActivityUncheckedCreateWithoutChapterInput> | ChapterActivityCreateWithoutChapterInput[] | ChapterActivityUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterActivityCreateOrConnectWithoutChapterInput | ChapterActivityCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterActivityCreateManyChapterInputEnvelope
    connect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
  }

  export type ChapterRevisionRequestUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutChapterInput, ChapterRevisionRequestUncheckedCreateWithoutChapterInput> | ChapterRevisionRequestCreateWithoutChapterInput[] | ChapterRevisionRequestUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutChapterInput | ChapterRevisionRequestCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterRevisionRequestCreateManyChapterInputEnvelope
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
  }

  export type EnumChapterStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChapterStatus
  }

  export type UserUpdateOneWithoutLastEditedChaptersNestedInput = {
    create?: XOR<UserCreateWithoutLastEditedChaptersInput, UserUncheckedCreateWithoutLastEditedChaptersInput>
    connectOrCreate?: UserCreateOrConnectWithoutLastEditedChaptersInput
    upsert?: UserUpsertWithoutLastEditedChaptersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLastEditedChaptersInput, UserUpdateWithoutLastEditedChaptersInput>, UserUncheckedUpdateWithoutLastEditedChaptersInput>
  }

  export type WorkUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<WorkCreateWithoutChaptersInput, WorkUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: WorkCreateOrConnectWithoutChaptersInput
    upsert?: WorkUpsertWithoutChaptersInput
    connect?: WorkWhereUniqueInput
    update?: XOR<XOR<WorkUpdateToOneWithWhereWithoutChaptersInput, WorkUpdateWithoutChaptersInput>, WorkUncheckedUpdateWithoutChaptersInput>
  }

  export type ChapterCommentUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterCommentCreateWithoutChapterInput, ChapterCommentUncheckedCreateWithoutChapterInput> | ChapterCommentCreateWithoutChapterInput[] | ChapterCommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutChapterInput | ChapterCommentCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterCommentUpsertWithWhereUniqueWithoutChapterInput | ChapterCommentUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterCommentCreateManyChapterInputEnvelope
    set?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    disconnect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    delete?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    update?: ChapterCommentUpdateWithWhereUniqueWithoutChapterInput | ChapterCommentUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterCommentUpdateManyWithWhereWithoutChapterInput | ChapterCommentUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterCommentScalarWhereInput | ChapterCommentScalarWhereInput[]
  }

  export type ChapterSnapshotUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterSnapshotCreateWithoutChapterInput, ChapterSnapshotUncheckedCreateWithoutChapterInput> | ChapterSnapshotCreateWithoutChapterInput[] | ChapterSnapshotUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterSnapshotCreateOrConnectWithoutChapterInput | ChapterSnapshotCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterSnapshotUpsertWithWhereUniqueWithoutChapterInput | ChapterSnapshotUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterSnapshotCreateManyChapterInputEnvelope
    set?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    disconnect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    delete?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    connect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    update?: ChapterSnapshotUpdateWithWhereUniqueWithoutChapterInput | ChapterSnapshotUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterSnapshotUpdateManyWithWhereWithoutChapterInput | ChapterSnapshotUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterSnapshotScalarWhereInput | ChapterSnapshotScalarWhereInput[]
  }

  export type ChapterChangeUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterChangeCreateWithoutChapterInput, ChapterChangeUncheckedCreateWithoutChapterInput> | ChapterChangeCreateWithoutChapterInput[] | ChapterChangeUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutChapterInput | ChapterChangeCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterChangeUpsertWithWhereUniqueWithoutChapterInput | ChapterChangeUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterChangeCreateManyChapterInputEnvelope
    set?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    disconnect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    delete?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    update?: ChapterChangeUpdateWithWhereUniqueWithoutChapterInput | ChapterChangeUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterChangeUpdateManyWithWhereWithoutChapterInput | ChapterChangeUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterChangeScalarWhereInput | ChapterChangeScalarWhereInput[]
  }

  export type ChapterActivityUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterActivityCreateWithoutChapterInput, ChapterActivityUncheckedCreateWithoutChapterInput> | ChapterActivityCreateWithoutChapterInput[] | ChapterActivityUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterActivityCreateOrConnectWithoutChapterInput | ChapterActivityCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterActivityUpsertWithWhereUniqueWithoutChapterInput | ChapterActivityUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterActivityCreateManyChapterInputEnvelope
    set?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    disconnect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    delete?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    connect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    update?: ChapterActivityUpdateWithWhereUniqueWithoutChapterInput | ChapterActivityUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterActivityUpdateManyWithWhereWithoutChapterInput | ChapterActivityUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterActivityScalarWhereInput | ChapterActivityScalarWhereInput[]
  }

  export type ChapterRevisionRequestUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutChapterInput, ChapterRevisionRequestUncheckedCreateWithoutChapterInput> | ChapterRevisionRequestCreateWithoutChapterInput[] | ChapterRevisionRequestUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutChapterInput | ChapterRevisionRequestCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterRevisionRequestUpsertWithWhereUniqueWithoutChapterInput | ChapterRevisionRequestUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterRevisionRequestCreateManyChapterInputEnvelope
    set?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    disconnect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    delete?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    update?: ChapterRevisionRequestUpdateWithWhereUniqueWithoutChapterInput | ChapterRevisionRequestUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterRevisionRequestUpdateManyWithWhereWithoutChapterInput | ChapterRevisionRequestUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterRevisionRequestScalarWhereInput | ChapterRevisionRequestScalarWhereInput[]
  }

  export type ChapterCommentUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterCommentCreateWithoutChapterInput, ChapterCommentUncheckedCreateWithoutChapterInput> | ChapterCommentCreateWithoutChapterInput[] | ChapterCommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutChapterInput | ChapterCommentCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterCommentUpsertWithWhereUniqueWithoutChapterInput | ChapterCommentUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterCommentCreateManyChapterInputEnvelope
    set?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    disconnect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    delete?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    update?: ChapterCommentUpdateWithWhereUniqueWithoutChapterInput | ChapterCommentUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterCommentUpdateManyWithWhereWithoutChapterInput | ChapterCommentUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterCommentScalarWhereInput | ChapterCommentScalarWhereInput[]
  }

  export type ChapterSnapshotUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterSnapshotCreateWithoutChapterInput, ChapterSnapshotUncheckedCreateWithoutChapterInput> | ChapterSnapshotCreateWithoutChapterInput[] | ChapterSnapshotUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterSnapshotCreateOrConnectWithoutChapterInput | ChapterSnapshotCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterSnapshotUpsertWithWhereUniqueWithoutChapterInput | ChapterSnapshotUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterSnapshotCreateManyChapterInputEnvelope
    set?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    disconnect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    delete?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    connect?: ChapterSnapshotWhereUniqueInput | ChapterSnapshotWhereUniqueInput[]
    update?: ChapterSnapshotUpdateWithWhereUniqueWithoutChapterInput | ChapterSnapshotUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterSnapshotUpdateManyWithWhereWithoutChapterInput | ChapterSnapshotUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterSnapshotScalarWhereInput | ChapterSnapshotScalarWhereInput[]
  }

  export type ChapterChangeUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterChangeCreateWithoutChapterInput, ChapterChangeUncheckedCreateWithoutChapterInput> | ChapterChangeCreateWithoutChapterInput[] | ChapterChangeUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterChangeCreateOrConnectWithoutChapterInput | ChapterChangeCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterChangeUpsertWithWhereUniqueWithoutChapterInput | ChapterChangeUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterChangeCreateManyChapterInputEnvelope
    set?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    disconnect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    delete?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    connect?: ChapterChangeWhereUniqueInput | ChapterChangeWhereUniqueInput[]
    update?: ChapterChangeUpdateWithWhereUniqueWithoutChapterInput | ChapterChangeUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterChangeUpdateManyWithWhereWithoutChapterInput | ChapterChangeUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterChangeScalarWhereInput | ChapterChangeScalarWhereInput[]
  }

  export type ChapterActivityUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterActivityCreateWithoutChapterInput, ChapterActivityUncheckedCreateWithoutChapterInput> | ChapterActivityCreateWithoutChapterInput[] | ChapterActivityUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterActivityCreateOrConnectWithoutChapterInput | ChapterActivityCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterActivityUpsertWithWhereUniqueWithoutChapterInput | ChapterActivityUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterActivityCreateManyChapterInputEnvelope
    set?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    disconnect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    delete?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    connect?: ChapterActivityWhereUniqueInput | ChapterActivityWhereUniqueInput[]
    update?: ChapterActivityUpdateWithWhereUniqueWithoutChapterInput | ChapterActivityUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterActivityUpdateManyWithWhereWithoutChapterInput | ChapterActivityUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterActivityScalarWhereInput | ChapterActivityScalarWhereInput[]
  }

  export type ChapterRevisionRequestUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutChapterInput, ChapterRevisionRequestUncheckedCreateWithoutChapterInput> | ChapterRevisionRequestCreateWithoutChapterInput[] | ChapterRevisionRequestUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutChapterInput | ChapterRevisionRequestCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterRevisionRequestUpsertWithWhereUniqueWithoutChapterInput | ChapterRevisionRequestUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterRevisionRequestCreateManyChapterInputEnvelope
    set?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    disconnect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    delete?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    update?: ChapterRevisionRequestUpdateWithWhereUniqueWithoutChapterInput | ChapterRevisionRequestUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterRevisionRequestUpdateManyWithWhereWithoutChapterInput | ChapterRevisionRequestUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterRevisionRequestScalarWhereInput | ChapterRevisionRequestScalarWhereInput[]
  }

  export type WorkCreateNestedOneWithoutGlossaryInput = {
    create?: XOR<WorkCreateWithoutGlossaryInput, WorkUncheckedCreateWithoutGlossaryInput>
    connectOrCreate?: WorkCreateOrConnectWithoutGlossaryInput
    connect?: WorkWhereUniqueInput
  }

  export type WorkUpdateOneRequiredWithoutGlossaryNestedInput = {
    create?: XOR<WorkCreateWithoutGlossaryInput, WorkUncheckedCreateWithoutGlossaryInput>
    connectOrCreate?: WorkCreateOrConnectWithoutGlossaryInput
    upsert?: WorkUpsertWithoutGlossaryInput
    connect?: WorkWhereUniqueInput
    update?: XOR<XOR<WorkUpdateToOneWithWhereWithoutGlossaryInput, WorkUpdateWithoutGlossaryInput>, WorkUncheckedUpdateWithoutGlossaryInput>
  }

  export type EnumLogLevelFieldUpdateOperationsInput = {
    set?: $Enums.LogLevel
  }

  export type EnumLogCategoryFieldUpdateOperationsInput = {
    set?: $Enums.LogCategory
  }

  export type ActiveTranslationJobCreatefailedChapterNumsInput = {
    set: number[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ActiveTranslationJobUpdatefailedChapterNumsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type TranslationJobHistoryCreatefailedChapterNumsInput = {
    set: number[]
  }

  export type TranslationJobHistoryUpdatefailedChapterNumsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type WorkCreateNestedOneWithoutSettingBibleInput = {
    create?: XOR<WorkCreateWithoutSettingBibleInput, WorkUncheckedCreateWithoutSettingBibleInput>
    connectOrCreate?: WorkCreateOrConnectWithoutSettingBibleInput
    connect?: WorkWhereUniqueInput
  }

  export type CharacterCreateNestedManyWithoutBibleInput = {
    create?: XOR<CharacterCreateWithoutBibleInput, CharacterUncheckedCreateWithoutBibleInput> | CharacterCreateWithoutBibleInput[] | CharacterUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutBibleInput | CharacterCreateOrConnectWithoutBibleInput[]
    createMany?: CharacterCreateManyBibleInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type SettingTermCreateNestedManyWithoutBibleInput = {
    create?: XOR<SettingTermCreateWithoutBibleInput, SettingTermUncheckedCreateWithoutBibleInput> | SettingTermCreateWithoutBibleInput[] | SettingTermUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: SettingTermCreateOrConnectWithoutBibleInput | SettingTermCreateOrConnectWithoutBibleInput[]
    createMany?: SettingTermCreateManyBibleInputEnvelope
    connect?: SettingTermWhereUniqueInput | SettingTermWhereUniqueInput[]
  }

  export type TimelineEventCreateNestedManyWithoutBibleInput = {
    create?: XOR<TimelineEventCreateWithoutBibleInput, TimelineEventUncheckedCreateWithoutBibleInput> | TimelineEventCreateWithoutBibleInput[] | TimelineEventUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: TimelineEventCreateOrConnectWithoutBibleInput | TimelineEventCreateOrConnectWithoutBibleInput[]
    createMany?: TimelineEventCreateManyBibleInputEnvelope
    connect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutBibleInput = {
    create?: XOR<CharacterCreateWithoutBibleInput, CharacterUncheckedCreateWithoutBibleInput> | CharacterCreateWithoutBibleInput[] | CharacterUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutBibleInput | CharacterCreateOrConnectWithoutBibleInput[]
    createMany?: CharacterCreateManyBibleInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type SettingTermUncheckedCreateNestedManyWithoutBibleInput = {
    create?: XOR<SettingTermCreateWithoutBibleInput, SettingTermUncheckedCreateWithoutBibleInput> | SettingTermCreateWithoutBibleInput[] | SettingTermUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: SettingTermCreateOrConnectWithoutBibleInput | SettingTermCreateOrConnectWithoutBibleInput[]
    createMany?: SettingTermCreateManyBibleInputEnvelope
    connect?: SettingTermWhereUniqueInput | SettingTermWhereUniqueInput[]
  }

  export type TimelineEventUncheckedCreateNestedManyWithoutBibleInput = {
    create?: XOR<TimelineEventCreateWithoutBibleInput, TimelineEventUncheckedCreateWithoutBibleInput> | TimelineEventCreateWithoutBibleInput[] | TimelineEventUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: TimelineEventCreateOrConnectWithoutBibleInput | TimelineEventCreateOrConnectWithoutBibleInput[]
    createMany?: TimelineEventCreateManyBibleInputEnvelope
    connect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
  }

  export type EnumBibleStatusFieldUpdateOperationsInput = {
    set?: $Enums.BibleStatus
  }

  export type WorkUpdateOneRequiredWithoutSettingBibleNestedInput = {
    create?: XOR<WorkCreateWithoutSettingBibleInput, WorkUncheckedCreateWithoutSettingBibleInput>
    connectOrCreate?: WorkCreateOrConnectWithoutSettingBibleInput
    upsert?: WorkUpsertWithoutSettingBibleInput
    connect?: WorkWhereUniqueInput
    update?: XOR<XOR<WorkUpdateToOneWithWhereWithoutSettingBibleInput, WorkUpdateWithoutSettingBibleInput>, WorkUncheckedUpdateWithoutSettingBibleInput>
  }

  export type CharacterUpdateManyWithoutBibleNestedInput = {
    create?: XOR<CharacterCreateWithoutBibleInput, CharacterUncheckedCreateWithoutBibleInput> | CharacterCreateWithoutBibleInput[] | CharacterUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutBibleInput | CharacterCreateOrConnectWithoutBibleInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutBibleInput | CharacterUpsertWithWhereUniqueWithoutBibleInput[]
    createMany?: CharacterCreateManyBibleInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutBibleInput | CharacterUpdateWithWhereUniqueWithoutBibleInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutBibleInput | CharacterUpdateManyWithWhereWithoutBibleInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type SettingTermUpdateManyWithoutBibleNestedInput = {
    create?: XOR<SettingTermCreateWithoutBibleInput, SettingTermUncheckedCreateWithoutBibleInput> | SettingTermCreateWithoutBibleInput[] | SettingTermUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: SettingTermCreateOrConnectWithoutBibleInput | SettingTermCreateOrConnectWithoutBibleInput[]
    upsert?: SettingTermUpsertWithWhereUniqueWithoutBibleInput | SettingTermUpsertWithWhereUniqueWithoutBibleInput[]
    createMany?: SettingTermCreateManyBibleInputEnvelope
    set?: SettingTermWhereUniqueInput | SettingTermWhereUniqueInput[]
    disconnect?: SettingTermWhereUniqueInput | SettingTermWhereUniqueInput[]
    delete?: SettingTermWhereUniqueInput | SettingTermWhereUniqueInput[]
    connect?: SettingTermWhereUniqueInput | SettingTermWhereUniqueInput[]
    update?: SettingTermUpdateWithWhereUniqueWithoutBibleInput | SettingTermUpdateWithWhereUniqueWithoutBibleInput[]
    updateMany?: SettingTermUpdateManyWithWhereWithoutBibleInput | SettingTermUpdateManyWithWhereWithoutBibleInput[]
    deleteMany?: SettingTermScalarWhereInput | SettingTermScalarWhereInput[]
  }

  export type TimelineEventUpdateManyWithoutBibleNestedInput = {
    create?: XOR<TimelineEventCreateWithoutBibleInput, TimelineEventUncheckedCreateWithoutBibleInput> | TimelineEventCreateWithoutBibleInput[] | TimelineEventUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: TimelineEventCreateOrConnectWithoutBibleInput | TimelineEventCreateOrConnectWithoutBibleInput[]
    upsert?: TimelineEventUpsertWithWhereUniqueWithoutBibleInput | TimelineEventUpsertWithWhereUniqueWithoutBibleInput[]
    createMany?: TimelineEventCreateManyBibleInputEnvelope
    set?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    disconnect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    delete?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    connect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    update?: TimelineEventUpdateWithWhereUniqueWithoutBibleInput | TimelineEventUpdateWithWhereUniqueWithoutBibleInput[]
    updateMany?: TimelineEventUpdateManyWithWhereWithoutBibleInput | TimelineEventUpdateManyWithWhereWithoutBibleInput[]
    deleteMany?: TimelineEventScalarWhereInput | TimelineEventScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutBibleNestedInput = {
    create?: XOR<CharacterCreateWithoutBibleInput, CharacterUncheckedCreateWithoutBibleInput> | CharacterCreateWithoutBibleInput[] | CharacterUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutBibleInput | CharacterCreateOrConnectWithoutBibleInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutBibleInput | CharacterUpsertWithWhereUniqueWithoutBibleInput[]
    createMany?: CharacterCreateManyBibleInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutBibleInput | CharacterUpdateWithWhereUniqueWithoutBibleInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutBibleInput | CharacterUpdateManyWithWhereWithoutBibleInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type SettingTermUncheckedUpdateManyWithoutBibleNestedInput = {
    create?: XOR<SettingTermCreateWithoutBibleInput, SettingTermUncheckedCreateWithoutBibleInput> | SettingTermCreateWithoutBibleInput[] | SettingTermUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: SettingTermCreateOrConnectWithoutBibleInput | SettingTermCreateOrConnectWithoutBibleInput[]
    upsert?: SettingTermUpsertWithWhereUniqueWithoutBibleInput | SettingTermUpsertWithWhereUniqueWithoutBibleInput[]
    createMany?: SettingTermCreateManyBibleInputEnvelope
    set?: SettingTermWhereUniqueInput | SettingTermWhereUniqueInput[]
    disconnect?: SettingTermWhereUniqueInput | SettingTermWhereUniqueInput[]
    delete?: SettingTermWhereUniqueInput | SettingTermWhereUniqueInput[]
    connect?: SettingTermWhereUniqueInput | SettingTermWhereUniqueInput[]
    update?: SettingTermUpdateWithWhereUniqueWithoutBibleInput | SettingTermUpdateWithWhereUniqueWithoutBibleInput[]
    updateMany?: SettingTermUpdateManyWithWhereWithoutBibleInput | SettingTermUpdateManyWithWhereWithoutBibleInput[]
    deleteMany?: SettingTermScalarWhereInput | SettingTermScalarWhereInput[]
  }

  export type TimelineEventUncheckedUpdateManyWithoutBibleNestedInput = {
    create?: XOR<TimelineEventCreateWithoutBibleInput, TimelineEventUncheckedCreateWithoutBibleInput> | TimelineEventCreateWithoutBibleInput[] | TimelineEventUncheckedCreateWithoutBibleInput[]
    connectOrCreate?: TimelineEventCreateOrConnectWithoutBibleInput | TimelineEventCreateOrConnectWithoutBibleInput[]
    upsert?: TimelineEventUpsertWithWhereUniqueWithoutBibleInput | TimelineEventUpsertWithWhereUniqueWithoutBibleInput[]
    createMany?: TimelineEventCreateManyBibleInputEnvelope
    set?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    disconnect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    delete?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    connect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    update?: TimelineEventUpdateWithWhereUniqueWithoutBibleInput | TimelineEventUpdateWithWhereUniqueWithoutBibleInput[]
    updateMany?: TimelineEventUpdateManyWithWhereWithoutBibleInput | TimelineEventUpdateManyWithWhereWithoutBibleInput[]
    deleteMany?: TimelineEventScalarWhereInput | TimelineEventScalarWhereInput[]
  }

  export type CharacterCreatetitlesInput = {
    set: string[]
  }

  export type CharacterCreatealiasesInput = {
    set: string[]
  }

  export type SettingBibleCreateNestedOneWithoutCharactersInput = {
    create?: XOR<SettingBibleCreateWithoutCharactersInput, SettingBibleUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: SettingBibleCreateOrConnectWithoutCharactersInput
    connect?: SettingBibleWhereUniqueInput
  }

  export type CharacterUpdatetitlesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CharacterUpdatealiasesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumCharacterRoleFieldUpdateOperationsInput = {
    set?: $Enums.CharacterRole
  }

  export type SettingBibleUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<SettingBibleCreateWithoutCharactersInput, SettingBibleUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: SettingBibleCreateOrConnectWithoutCharactersInput
    upsert?: SettingBibleUpsertWithoutCharactersInput
    connect?: SettingBibleWhereUniqueInput
    update?: XOR<XOR<SettingBibleUpdateToOneWithWhereWithoutCharactersInput, SettingBibleUpdateWithoutCharactersInput>, SettingBibleUncheckedUpdateWithoutCharactersInput>
  }

  export type SettingBibleCreateNestedOneWithoutTermsInput = {
    create?: XOR<SettingBibleCreateWithoutTermsInput, SettingBibleUncheckedCreateWithoutTermsInput>
    connectOrCreate?: SettingBibleCreateOrConnectWithoutTermsInput
    connect?: SettingBibleWhereUniqueInput
  }

  export type EnumTermCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TermCategory
  }

  export type SettingBibleUpdateOneRequiredWithoutTermsNestedInput = {
    create?: XOR<SettingBibleCreateWithoutTermsInput, SettingBibleUncheckedCreateWithoutTermsInput>
    connectOrCreate?: SettingBibleCreateOrConnectWithoutTermsInput
    upsert?: SettingBibleUpsertWithoutTermsInput
    connect?: SettingBibleWhereUniqueInput
    update?: XOR<XOR<SettingBibleUpdateToOneWithWhereWithoutTermsInput, SettingBibleUpdateWithoutTermsInput>, SettingBibleUncheckedUpdateWithoutTermsInput>
  }

  export type TimelineEventCreateinvolvedCharacterIdsInput = {
    set: string[]
  }

  export type SettingBibleCreateNestedOneWithoutEventsInput = {
    create?: XOR<SettingBibleCreateWithoutEventsInput, SettingBibleUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SettingBibleCreateOrConnectWithoutEventsInput
    connect?: SettingBibleWhereUniqueInput
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type TimelineEventUpdateinvolvedCharacterIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SettingBibleUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<SettingBibleCreateWithoutEventsInput, SettingBibleUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SettingBibleCreateOrConnectWithoutEventsInput
    upsert?: SettingBibleUpsertWithoutEventsInput
    connect?: SettingBibleWhereUniqueInput
    update?: XOR<XOR<SettingBibleUpdateToOneWithWhereWithoutEventsInput, SettingBibleUpdateWithoutEventsInput>, SettingBibleUncheckedUpdateWithoutEventsInput>
  }

  export type WorkCreateNestedOneWithoutBibleJobsInput = {
    create?: XOR<WorkCreateWithoutBibleJobsInput, WorkUncheckedCreateWithoutBibleJobsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutBibleJobsInput
    connect?: WorkWhereUniqueInput
  }

  export type EnumBibleJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.BibleJobStatus
  }

  export type WorkUpdateOneRequiredWithoutBibleJobsNestedInput = {
    create?: XOR<WorkCreateWithoutBibleJobsInput, WorkUncheckedCreateWithoutBibleJobsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutBibleJobsInput
    upsert?: WorkUpsertWithoutBibleJobsInput
    connect?: WorkWhereUniqueInput
    update?: XOR<XOR<WorkUpdateToOneWithWhereWithoutBibleJobsInput, WorkUpdateWithoutBibleJobsInput>, WorkUncheckedUpdateWithoutBibleJobsInput>
  }

  export type ChapterCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutCommentsInput
    connect?: ChapterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ChapterCommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<ChapterCommentCreateWithoutRepliesInput, ChapterCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutRepliesInput
    connect?: ChapterCommentWhereUniqueInput
  }

  export type ChapterCommentCreateNestedManyWithoutParentInput = {
    create?: XOR<ChapterCommentCreateWithoutParentInput, ChapterCommentUncheckedCreateWithoutParentInput> | ChapterCommentCreateWithoutParentInput[] | ChapterCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutParentInput | ChapterCommentCreateOrConnectWithoutParentInput[]
    createMany?: ChapterCommentCreateManyParentInputEnvelope
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutResolvedCommentsInput = {
    create?: XOR<UserCreateWithoutResolvedCommentsInput, UserUncheckedCreateWithoutResolvedCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ChapterCommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ChapterCommentCreateWithoutParentInput, ChapterCommentUncheckedCreateWithoutParentInput> | ChapterCommentCreateWithoutParentInput[] | ChapterCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutParentInput | ChapterCommentCreateOrConnectWithoutParentInput[]
    createMany?: ChapterCommentCreateManyParentInputEnvelope
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
  }

  export type ChapterUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutCommentsInput
    upsert?: ChapterUpsertWithoutCommentsInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutCommentsInput, ChapterUpdateWithoutCommentsInput>, ChapterUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type ChapterCommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<ChapterCommentCreateWithoutRepliesInput, ChapterCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutRepliesInput
    upsert?: ChapterCommentUpsertWithoutRepliesInput
    disconnect?: ChapterCommentWhereInput | boolean
    delete?: ChapterCommentWhereInput | boolean
    connect?: ChapterCommentWhereUniqueInput
    update?: XOR<XOR<ChapterCommentUpdateToOneWithWhereWithoutRepliesInput, ChapterCommentUpdateWithoutRepliesInput>, ChapterCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type ChapterCommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<ChapterCommentCreateWithoutParentInput, ChapterCommentUncheckedCreateWithoutParentInput> | ChapterCommentCreateWithoutParentInput[] | ChapterCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutParentInput | ChapterCommentCreateOrConnectWithoutParentInput[]
    upsert?: ChapterCommentUpsertWithWhereUniqueWithoutParentInput | ChapterCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ChapterCommentCreateManyParentInputEnvelope
    set?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    disconnect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    delete?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    update?: ChapterCommentUpdateWithWhereUniqueWithoutParentInput | ChapterCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ChapterCommentUpdateManyWithWhereWithoutParentInput | ChapterCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ChapterCommentScalarWhereInput | ChapterCommentScalarWhereInput[]
  }

  export type UserUpdateOneWithoutResolvedCommentsNestedInput = {
    create?: XOR<UserCreateWithoutResolvedCommentsInput, UserUncheckedCreateWithoutResolvedCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedCommentsInput
    upsert?: UserUpsertWithoutResolvedCommentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResolvedCommentsInput, UserUpdateWithoutResolvedCommentsInput>, UserUncheckedUpdateWithoutResolvedCommentsInput>
  }

  export type ChapterCommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ChapterCommentCreateWithoutParentInput, ChapterCommentUncheckedCreateWithoutParentInput> | ChapterCommentCreateWithoutParentInput[] | ChapterCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChapterCommentCreateOrConnectWithoutParentInput | ChapterCommentCreateOrConnectWithoutParentInput[]
    upsert?: ChapterCommentUpsertWithWhereUniqueWithoutParentInput | ChapterCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ChapterCommentCreateManyParentInputEnvelope
    set?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    disconnect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    delete?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    connect?: ChapterCommentWhereUniqueInput | ChapterCommentWhereUniqueInput[]
    update?: ChapterCommentUpdateWithWhereUniqueWithoutParentInput | ChapterCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ChapterCommentUpdateManyWithWhereWithoutParentInput | ChapterCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ChapterCommentScalarWhereInput | ChapterCommentScalarWhereInput[]
  }

  export type ChapterCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<ChapterCreateWithoutSnapshotsInput, ChapterUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutSnapshotsInput
    connect?: ChapterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<UserCreateWithoutSnapshotsInput, UserUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSnapshotsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSnapshotTypeFieldUpdateOperationsInput = {
    set?: $Enums.SnapshotType
  }

  export type ChapterUpdateOneRequiredWithoutSnapshotsNestedInput = {
    create?: XOR<ChapterCreateWithoutSnapshotsInput, ChapterUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutSnapshotsInput
    upsert?: ChapterUpsertWithoutSnapshotsInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutSnapshotsInput, ChapterUpdateWithoutSnapshotsInput>, ChapterUncheckedUpdateWithoutSnapshotsInput>
  }

  export type UserUpdateOneRequiredWithoutSnapshotsNestedInput = {
    create?: XOR<UserCreateWithoutSnapshotsInput, UserUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSnapshotsInput
    upsert?: UserUpsertWithoutSnapshotsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSnapshotsInput, UserUpdateWithoutSnapshotsInput>, UserUncheckedUpdateWithoutSnapshotsInput>
  }

  export type ChapterCreateNestedOneWithoutChangesInput = {
    create?: XOR<ChapterCreateWithoutChangesInput, ChapterUncheckedCreateWithoutChangesInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutChangesInput
    connect?: ChapterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChangesInput = {
    create?: XOR<UserCreateWithoutChangesInput, UserUncheckedCreateWithoutChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedChangesInput = {
    create?: XOR<UserCreateWithoutReviewedChangesInput, UserUncheckedCreateWithoutReviewedChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedChangesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumChangeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChangeType
  }

  export type EnumChangeStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChangeStatus
  }

  export type ChapterUpdateOneRequiredWithoutChangesNestedInput = {
    create?: XOR<ChapterCreateWithoutChangesInput, ChapterUncheckedCreateWithoutChangesInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutChangesInput
    upsert?: ChapterUpsertWithoutChangesInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutChangesInput, ChapterUpdateWithoutChangesInput>, ChapterUncheckedUpdateWithoutChangesInput>
  }

  export type UserUpdateOneRequiredWithoutChangesNestedInput = {
    create?: XOR<UserCreateWithoutChangesInput, UserUncheckedCreateWithoutChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangesInput
    upsert?: UserUpsertWithoutChangesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChangesInput, UserUpdateWithoutChangesInput>, UserUncheckedUpdateWithoutChangesInput>
  }

  export type UserUpdateOneWithoutReviewedChangesNestedInput = {
    create?: XOR<UserCreateWithoutReviewedChangesInput, UserUncheckedCreateWithoutReviewedChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedChangesInput
    upsert?: UserUpsertWithoutReviewedChangesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedChangesInput, UserUpdateWithoutReviewedChangesInput>, UserUncheckedUpdateWithoutReviewedChangesInput>
  }

  export type ChapterCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ChapterCreateWithoutActivitiesInput, ChapterUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutActivitiesInput
    connect?: ChapterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type ChapterUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<ChapterCreateWithoutActivitiesInput, ChapterUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutActivitiesInput
    upsert?: ChapterUpsertWithoutActivitiesInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutActivitiesInput, ChapterUpdateWithoutActivitiesInput>, ChapterUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type EditorProfileCreatespecialtyGenresInput = {
    set: string[]
  }

  export type EditorProfileCreatelanguagesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutEditorProfileInput = {
    create?: XOR<UserCreateWithoutEditorProfileInput, UserUncheckedCreateWithoutEditorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEditorProfileInput
    connect?: UserWhereUniqueInput
  }

  export type PortfolioItemCreateNestedManyWithoutProfileInput = {
    create?: XOR<PortfolioItemCreateWithoutProfileInput, PortfolioItemUncheckedCreateWithoutProfileInput> | PortfolioItemCreateWithoutProfileInput[] | PortfolioItemUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutProfileInput | PortfolioItemCreateOrConnectWithoutProfileInput[]
    createMany?: PortfolioItemCreateManyProfileInputEnvelope
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
  }

  export type ProjectApplicationCreateNestedManyWithoutEditorProfileInput = {
    create?: XOR<ProjectApplicationCreateWithoutEditorProfileInput, ProjectApplicationUncheckedCreateWithoutEditorProfileInput> | ProjectApplicationCreateWithoutEditorProfileInput[] | ProjectApplicationUncheckedCreateWithoutEditorProfileInput[]
    connectOrCreate?: ProjectApplicationCreateOrConnectWithoutEditorProfileInput | ProjectApplicationCreateOrConnectWithoutEditorProfileInput[]
    createMany?: ProjectApplicationCreateManyEditorProfileInputEnvelope
    connect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
  }

  export type EditorReviewCreateNestedManyWithoutEditorProfileInput = {
    create?: XOR<EditorReviewCreateWithoutEditorProfileInput, EditorReviewUncheckedCreateWithoutEditorProfileInput> | EditorReviewCreateWithoutEditorProfileInput[] | EditorReviewUncheckedCreateWithoutEditorProfileInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutEditorProfileInput | EditorReviewCreateOrConnectWithoutEditorProfileInput[]
    createMany?: EditorReviewCreateManyEditorProfileInputEnvelope
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
  }

  export type PortfolioItemUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PortfolioItemCreateWithoutProfileInput, PortfolioItemUncheckedCreateWithoutProfileInput> | PortfolioItemCreateWithoutProfileInput[] | PortfolioItemUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutProfileInput | PortfolioItemCreateOrConnectWithoutProfileInput[]
    createMany?: PortfolioItemCreateManyProfileInputEnvelope
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
  }

  export type ProjectApplicationUncheckedCreateNestedManyWithoutEditorProfileInput = {
    create?: XOR<ProjectApplicationCreateWithoutEditorProfileInput, ProjectApplicationUncheckedCreateWithoutEditorProfileInput> | ProjectApplicationCreateWithoutEditorProfileInput[] | ProjectApplicationUncheckedCreateWithoutEditorProfileInput[]
    connectOrCreate?: ProjectApplicationCreateOrConnectWithoutEditorProfileInput | ProjectApplicationCreateOrConnectWithoutEditorProfileInput[]
    createMany?: ProjectApplicationCreateManyEditorProfileInputEnvelope
    connect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
  }

  export type EditorReviewUncheckedCreateNestedManyWithoutEditorProfileInput = {
    create?: XOR<EditorReviewCreateWithoutEditorProfileInput, EditorReviewUncheckedCreateWithoutEditorProfileInput> | EditorReviewCreateWithoutEditorProfileInput[] | EditorReviewUncheckedCreateWithoutEditorProfileInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutEditorProfileInput | EditorReviewCreateOrConnectWithoutEditorProfileInput[]
    createMany?: EditorReviewCreateManyEditorProfileInputEnvelope
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
  }

  export type EditorProfileUpdatespecialtyGenresInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EditorProfileUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumEditorAvailabilityFieldUpdateOperationsInput = {
    set?: $Enums.EditorAvailability
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutEditorProfileNestedInput = {
    create?: XOR<UserCreateWithoutEditorProfileInput, UserUncheckedCreateWithoutEditorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEditorProfileInput
    upsert?: UserUpsertWithoutEditorProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEditorProfileInput, UserUpdateWithoutEditorProfileInput>, UserUncheckedUpdateWithoutEditorProfileInput>
  }

  export type PortfolioItemUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PortfolioItemCreateWithoutProfileInput, PortfolioItemUncheckedCreateWithoutProfileInput> | PortfolioItemCreateWithoutProfileInput[] | PortfolioItemUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutProfileInput | PortfolioItemCreateOrConnectWithoutProfileInput[]
    upsert?: PortfolioItemUpsertWithWhereUniqueWithoutProfileInput | PortfolioItemUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PortfolioItemCreateManyProfileInputEnvelope
    set?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    disconnect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    delete?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    update?: PortfolioItemUpdateWithWhereUniqueWithoutProfileInput | PortfolioItemUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PortfolioItemUpdateManyWithWhereWithoutProfileInput | PortfolioItemUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
  }

  export type ProjectApplicationUpdateManyWithoutEditorProfileNestedInput = {
    create?: XOR<ProjectApplicationCreateWithoutEditorProfileInput, ProjectApplicationUncheckedCreateWithoutEditorProfileInput> | ProjectApplicationCreateWithoutEditorProfileInput[] | ProjectApplicationUncheckedCreateWithoutEditorProfileInput[]
    connectOrCreate?: ProjectApplicationCreateOrConnectWithoutEditorProfileInput | ProjectApplicationCreateOrConnectWithoutEditorProfileInput[]
    upsert?: ProjectApplicationUpsertWithWhereUniqueWithoutEditorProfileInput | ProjectApplicationUpsertWithWhereUniqueWithoutEditorProfileInput[]
    createMany?: ProjectApplicationCreateManyEditorProfileInputEnvelope
    set?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    disconnect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    delete?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    connect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    update?: ProjectApplicationUpdateWithWhereUniqueWithoutEditorProfileInput | ProjectApplicationUpdateWithWhereUniqueWithoutEditorProfileInput[]
    updateMany?: ProjectApplicationUpdateManyWithWhereWithoutEditorProfileInput | ProjectApplicationUpdateManyWithWhereWithoutEditorProfileInput[]
    deleteMany?: ProjectApplicationScalarWhereInput | ProjectApplicationScalarWhereInput[]
  }

  export type EditorReviewUpdateManyWithoutEditorProfileNestedInput = {
    create?: XOR<EditorReviewCreateWithoutEditorProfileInput, EditorReviewUncheckedCreateWithoutEditorProfileInput> | EditorReviewCreateWithoutEditorProfileInput[] | EditorReviewUncheckedCreateWithoutEditorProfileInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutEditorProfileInput | EditorReviewCreateOrConnectWithoutEditorProfileInput[]
    upsert?: EditorReviewUpsertWithWhereUniqueWithoutEditorProfileInput | EditorReviewUpsertWithWhereUniqueWithoutEditorProfileInput[]
    createMany?: EditorReviewCreateManyEditorProfileInputEnvelope
    set?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    disconnect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    delete?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    update?: EditorReviewUpdateWithWhereUniqueWithoutEditorProfileInput | EditorReviewUpdateWithWhereUniqueWithoutEditorProfileInput[]
    updateMany?: EditorReviewUpdateManyWithWhereWithoutEditorProfileInput | EditorReviewUpdateManyWithWhereWithoutEditorProfileInput[]
    deleteMany?: EditorReviewScalarWhereInput | EditorReviewScalarWhereInput[]
  }

  export type PortfolioItemUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PortfolioItemCreateWithoutProfileInput, PortfolioItemUncheckedCreateWithoutProfileInput> | PortfolioItemCreateWithoutProfileInput[] | PortfolioItemUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutProfileInput | PortfolioItemCreateOrConnectWithoutProfileInput[]
    upsert?: PortfolioItemUpsertWithWhereUniqueWithoutProfileInput | PortfolioItemUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PortfolioItemCreateManyProfileInputEnvelope
    set?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    disconnect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    delete?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    update?: PortfolioItemUpdateWithWhereUniqueWithoutProfileInput | PortfolioItemUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PortfolioItemUpdateManyWithWhereWithoutProfileInput | PortfolioItemUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
  }

  export type ProjectApplicationUncheckedUpdateManyWithoutEditorProfileNestedInput = {
    create?: XOR<ProjectApplicationCreateWithoutEditorProfileInput, ProjectApplicationUncheckedCreateWithoutEditorProfileInput> | ProjectApplicationCreateWithoutEditorProfileInput[] | ProjectApplicationUncheckedCreateWithoutEditorProfileInput[]
    connectOrCreate?: ProjectApplicationCreateOrConnectWithoutEditorProfileInput | ProjectApplicationCreateOrConnectWithoutEditorProfileInput[]
    upsert?: ProjectApplicationUpsertWithWhereUniqueWithoutEditorProfileInput | ProjectApplicationUpsertWithWhereUniqueWithoutEditorProfileInput[]
    createMany?: ProjectApplicationCreateManyEditorProfileInputEnvelope
    set?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    disconnect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    delete?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    connect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    update?: ProjectApplicationUpdateWithWhereUniqueWithoutEditorProfileInput | ProjectApplicationUpdateWithWhereUniqueWithoutEditorProfileInput[]
    updateMany?: ProjectApplicationUpdateManyWithWhereWithoutEditorProfileInput | ProjectApplicationUpdateManyWithWhereWithoutEditorProfileInput[]
    deleteMany?: ProjectApplicationScalarWhereInput | ProjectApplicationScalarWhereInput[]
  }

  export type EditorReviewUncheckedUpdateManyWithoutEditorProfileNestedInput = {
    create?: XOR<EditorReviewCreateWithoutEditorProfileInput, EditorReviewUncheckedCreateWithoutEditorProfileInput> | EditorReviewCreateWithoutEditorProfileInput[] | EditorReviewUncheckedCreateWithoutEditorProfileInput[]
    connectOrCreate?: EditorReviewCreateOrConnectWithoutEditorProfileInput | EditorReviewCreateOrConnectWithoutEditorProfileInput[]
    upsert?: EditorReviewUpsertWithWhereUniqueWithoutEditorProfileInput | EditorReviewUpsertWithWhereUniqueWithoutEditorProfileInput[]
    createMany?: EditorReviewCreateManyEditorProfileInputEnvelope
    set?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    disconnect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    delete?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    connect?: EditorReviewWhereUniqueInput | EditorReviewWhereUniqueInput[]
    update?: EditorReviewUpdateWithWhereUniqueWithoutEditorProfileInput | EditorReviewUpdateWithWhereUniqueWithoutEditorProfileInput[]
    updateMany?: EditorReviewUpdateManyWithWhereWithoutEditorProfileInput | EditorReviewUpdateManyWithWhereWithoutEditorProfileInput[]
    deleteMany?: EditorReviewScalarWhereInput | EditorReviewScalarWhereInput[]
  }

  export type EditorProfileCreateNestedOneWithoutPortfolioItemsInput = {
    create?: XOR<EditorProfileCreateWithoutPortfolioItemsInput, EditorProfileUncheckedCreateWithoutPortfolioItemsInput>
    connectOrCreate?: EditorProfileCreateOrConnectWithoutPortfolioItemsInput
    connect?: EditorProfileWhereUniqueInput
  }

  export type EditorProfileUpdateOneRequiredWithoutPortfolioItemsNestedInput = {
    create?: XOR<EditorProfileCreateWithoutPortfolioItemsInput, EditorProfileUncheckedCreateWithoutPortfolioItemsInput>
    connectOrCreate?: EditorProfileCreateOrConnectWithoutPortfolioItemsInput
    upsert?: EditorProfileUpsertWithoutPortfolioItemsInput
    connect?: EditorProfileWhereUniqueInput
    update?: XOR<XOR<EditorProfileUpdateToOneWithWhereWithoutPortfolioItemsInput, EditorProfileUpdateWithoutPortfolioItemsInput>, EditorProfileUncheckedUpdateWithoutPortfolioItemsInput>
  }

  export type WorkCreateNestedOneWithoutListingsInput = {
    create?: XOR<WorkCreateWithoutListingsInput, WorkUncheckedCreateWithoutListingsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutListingsInput
    connect?: WorkWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuthorListingsInput = {
    create?: XOR<UserCreateWithoutAuthorListingsInput, UserUncheckedCreateWithoutAuthorListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorListingsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectApplicationCreateNestedManyWithoutListingInput = {
    create?: XOR<ProjectApplicationCreateWithoutListingInput, ProjectApplicationUncheckedCreateWithoutListingInput> | ProjectApplicationCreateWithoutListingInput[] | ProjectApplicationUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ProjectApplicationCreateOrConnectWithoutListingInput | ProjectApplicationCreateOrConnectWithoutListingInput[]
    createMany?: ProjectApplicationCreateManyListingInputEnvelope
    connect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
  }

  export type ProjectContractCreateNestedOneWithoutListingInput = {
    create?: XOR<ProjectContractCreateWithoutListingInput, ProjectContractUncheckedCreateWithoutListingInput>
    connectOrCreate?: ProjectContractCreateOrConnectWithoutListingInput
    connect?: ProjectContractWhereUniqueInput
  }

  export type ProjectApplicationUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<ProjectApplicationCreateWithoutListingInput, ProjectApplicationUncheckedCreateWithoutListingInput> | ProjectApplicationCreateWithoutListingInput[] | ProjectApplicationUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ProjectApplicationCreateOrConnectWithoutListingInput | ProjectApplicationCreateOrConnectWithoutListingInput[]
    createMany?: ProjectApplicationCreateManyListingInputEnvelope
    connect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
  }

  export type ProjectContractUncheckedCreateNestedOneWithoutListingInput = {
    create?: XOR<ProjectContractCreateWithoutListingInput, ProjectContractUncheckedCreateWithoutListingInput>
    connectOrCreate?: ProjectContractCreateOrConnectWithoutListingInput
    connect?: ProjectContractWhereUniqueInput
  }

  export type EnumProjectListingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectListingStatus
  }

  export type WorkUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<WorkCreateWithoutListingsInput, WorkUncheckedCreateWithoutListingsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutListingsInput
    upsert?: WorkUpsertWithoutListingsInput
    connect?: WorkWhereUniqueInput
    update?: XOR<XOR<WorkUpdateToOneWithWhereWithoutListingsInput, WorkUpdateWithoutListingsInput>, WorkUncheckedUpdateWithoutListingsInput>
  }

  export type UserUpdateOneRequiredWithoutAuthorListingsNestedInput = {
    create?: XOR<UserCreateWithoutAuthorListingsInput, UserUncheckedCreateWithoutAuthorListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorListingsInput
    upsert?: UserUpsertWithoutAuthorListingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthorListingsInput, UserUpdateWithoutAuthorListingsInput>, UserUncheckedUpdateWithoutAuthorListingsInput>
  }

  export type ProjectApplicationUpdateManyWithoutListingNestedInput = {
    create?: XOR<ProjectApplicationCreateWithoutListingInput, ProjectApplicationUncheckedCreateWithoutListingInput> | ProjectApplicationCreateWithoutListingInput[] | ProjectApplicationUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ProjectApplicationCreateOrConnectWithoutListingInput | ProjectApplicationCreateOrConnectWithoutListingInput[]
    upsert?: ProjectApplicationUpsertWithWhereUniqueWithoutListingInput | ProjectApplicationUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: ProjectApplicationCreateManyListingInputEnvelope
    set?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    disconnect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    delete?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    connect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    update?: ProjectApplicationUpdateWithWhereUniqueWithoutListingInput | ProjectApplicationUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: ProjectApplicationUpdateManyWithWhereWithoutListingInput | ProjectApplicationUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: ProjectApplicationScalarWhereInput | ProjectApplicationScalarWhereInput[]
  }

  export type ProjectContractUpdateOneWithoutListingNestedInput = {
    create?: XOR<ProjectContractCreateWithoutListingInput, ProjectContractUncheckedCreateWithoutListingInput>
    connectOrCreate?: ProjectContractCreateOrConnectWithoutListingInput
    upsert?: ProjectContractUpsertWithoutListingInput
    disconnect?: ProjectContractWhereInput | boolean
    delete?: ProjectContractWhereInput | boolean
    connect?: ProjectContractWhereUniqueInput
    update?: XOR<XOR<ProjectContractUpdateToOneWithWhereWithoutListingInput, ProjectContractUpdateWithoutListingInput>, ProjectContractUncheckedUpdateWithoutListingInput>
  }

  export type ProjectApplicationUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<ProjectApplicationCreateWithoutListingInput, ProjectApplicationUncheckedCreateWithoutListingInput> | ProjectApplicationCreateWithoutListingInput[] | ProjectApplicationUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ProjectApplicationCreateOrConnectWithoutListingInput | ProjectApplicationCreateOrConnectWithoutListingInput[]
    upsert?: ProjectApplicationUpsertWithWhereUniqueWithoutListingInput | ProjectApplicationUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: ProjectApplicationCreateManyListingInputEnvelope
    set?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    disconnect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    delete?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    connect?: ProjectApplicationWhereUniqueInput | ProjectApplicationWhereUniqueInput[]
    update?: ProjectApplicationUpdateWithWhereUniqueWithoutListingInput | ProjectApplicationUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: ProjectApplicationUpdateManyWithWhereWithoutListingInput | ProjectApplicationUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: ProjectApplicationScalarWhereInput | ProjectApplicationScalarWhereInput[]
  }

  export type ProjectContractUncheckedUpdateOneWithoutListingNestedInput = {
    create?: XOR<ProjectContractCreateWithoutListingInput, ProjectContractUncheckedCreateWithoutListingInput>
    connectOrCreate?: ProjectContractCreateOrConnectWithoutListingInput
    upsert?: ProjectContractUpsertWithoutListingInput
    disconnect?: ProjectContractWhereInput | boolean
    delete?: ProjectContractWhereInput | boolean
    connect?: ProjectContractWhereUniqueInput
    update?: XOR<XOR<ProjectContractUpdateToOneWithWhereWithoutListingInput, ProjectContractUpdateWithoutListingInput>, ProjectContractUncheckedUpdateWithoutListingInput>
  }

  export type ProjectListingCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<ProjectListingCreateWithoutApplicationsInput, ProjectListingUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: ProjectListingCreateOrConnectWithoutApplicationsInput
    connect?: ProjectListingWhereUniqueInput
  }

  export type EditorProfileCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<EditorProfileCreateWithoutApplicationsInput, EditorProfileUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: EditorProfileCreateOrConnectWithoutApplicationsInput
    connect?: EditorProfileWhereUniqueInput
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type ProjectListingUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<ProjectListingCreateWithoutApplicationsInput, ProjectListingUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: ProjectListingCreateOrConnectWithoutApplicationsInput
    upsert?: ProjectListingUpsertWithoutApplicationsInput
    connect?: ProjectListingWhereUniqueInput
    update?: XOR<XOR<ProjectListingUpdateToOneWithWhereWithoutApplicationsInput, ProjectListingUpdateWithoutApplicationsInput>, ProjectListingUncheckedUpdateWithoutApplicationsInput>
  }

  export type EditorProfileUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<EditorProfileCreateWithoutApplicationsInput, EditorProfileUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: EditorProfileCreateOrConnectWithoutApplicationsInput
    upsert?: EditorProfileUpsertWithoutApplicationsInput
    connect?: EditorProfileWhereUniqueInput
    update?: XOR<XOR<EditorProfileUpdateToOneWithWhereWithoutApplicationsInput, EditorProfileUpdateWithoutApplicationsInput>, EditorProfileUncheckedUpdateWithoutApplicationsInput>
  }

  export type ProjectListingCreateNestedOneWithoutContractInput = {
    create?: XOR<ProjectListingCreateWithoutContractInput, ProjectListingUncheckedCreateWithoutContractInput>
    connectOrCreate?: ProjectListingCreateOrConnectWithoutContractInput
    connect?: ProjectListingWhereUniqueInput
  }

  export type WorkCreateNestedOneWithoutContractsInput = {
    create?: XOR<WorkCreateWithoutContractsInput, WorkUncheckedCreateWithoutContractsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutContractsInput
    connect?: WorkWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuthorContractsInput = {
    create?: XOR<UserCreateWithoutAuthorContractsInput, UserUncheckedCreateWithoutAuthorContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorContractsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEditorContractsInput = {
    create?: XOR<UserCreateWithoutEditorContractsInput, UserUncheckedCreateWithoutEditorContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEditorContractsInput
    connect?: UserWhereUniqueInput
  }

  export type ChapterRevisionRequestCreateNestedManyWithoutContractInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutContractInput, ChapterRevisionRequestUncheckedCreateWithoutContractInput> | ChapterRevisionRequestCreateWithoutContractInput[] | ChapterRevisionRequestUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutContractInput | ChapterRevisionRequestCreateOrConnectWithoutContractInput[]
    createMany?: ChapterRevisionRequestCreateManyContractInputEnvelope
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
  }

  export type ChapterRevisionRequestUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutContractInput, ChapterRevisionRequestUncheckedCreateWithoutContractInput> | ChapterRevisionRequestCreateWithoutContractInput[] | ChapterRevisionRequestUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutContractInput | ChapterRevisionRequestCreateOrConnectWithoutContractInput[]
    createMany?: ChapterRevisionRequestCreateManyContractInputEnvelope
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
  }

  export type ProjectListingUpdateOneRequiredWithoutContractNestedInput = {
    create?: XOR<ProjectListingCreateWithoutContractInput, ProjectListingUncheckedCreateWithoutContractInput>
    connectOrCreate?: ProjectListingCreateOrConnectWithoutContractInput
    upsert?: ProjectListingUpsertWithoutContractInput
    connect?: ProjectListingWhereUniqueInput
    update?: XOR<XOR<ProjectListingUpdateToOneWithWhereWithoutContractInput, ProjectListingUpdateWithoutContractInput>, ProjectListingUncheckedUpdateWithoutContractInput>
  }

  export type WorkUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<WorkCreateWithoutContractsInput, WorkUncheckedCreateWithoutContractsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutContractsInput
    upsert?: WorkUpsertWithoutContractsInput
    connect?: WorkWhereUniqueInput
    update?: XOR<XOR<WorkUpdateToOneWithWhereWithoutContractsInput, WorkUpdateWithoutContractsInput>, WorkUncheckedUpdateWithoutContractsInput>
  }

  export type UserUpdateOneRequiredWithoutAuthorContractsNestedInput = {
    create?: XOR<UserCreateWithoutAuthorContractsInput, UserUncheckedCreateWithoutAuthorContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorContractsInput
    upsert?: UserUpsertWithoutAuthorContractsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthorContractsInput, UserUpdateWithoutAuthorContractsInput>, UserUncheckedUpdateWithoutAuthorContractsInput>
  }

  export type UserUpdateOneRequiredWithoutEditorContractsNestedInput = {
    create?: XOR<UserCreateWithoutEditorContractsInput, UserUncheckedCreateWithoutEditorContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEditorContractsInput
    upsert?: UserUpsertWithoutEditorContractsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEditorContractsInput, UserUpdateWithoutEditorContractsInput>, UserUncheckedUpdateWithoutEditorContractsInput>
  }

  export type ChapterRevisionRequestUpdateManyWithoutContractNestedInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutContractInput, ChapterRevisionRequestUncheckedCreateWithoutContractInput> | ChapterRevisionRequestCreateWithoutContractInput[] | ChapterRevisionRequestUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutContractInput | ChapterRevisionRequestCreateOrConnectWithoutContractInput[]
    upsert?: ChapterRevisionRequestUpsertWithWhereUniqueWithoutContractInput | ChapterRevisionRequestUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ChapterRevisionRequestCreateManyContractInputEnvelope
    set?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    disconnect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    delete?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    update?: ChapterRevisionRequestUpdateWithWhereUniqueWithoutContractInput | ChapterRevisionRequestUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ChapterRevisionRequestUpdateManyWithWhereWithoutContractInput | ChapterRevisionRequestUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ChapterRevisionRequestScalarWhereInput | ChapterRevisionRequestScalarWhereInput[]
  }

  export type ChapterRevisionRequestUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ChapterRevisionRequestCreateWithoutContractInput, ChapterRevisionRequestUncheckedCreateWithoutContractInput> | ChapterRevisionRequestCreateWithoutContractInput[] | ChapterRevisionRequestUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ChapterRevisionRequestCreateOrConnectWithoutContractInput | ChapterRevisionRequestCreateOrConnectWithoutContractInput[]
    upsert?: ChapterRevisionRequestUpsertWithWhereUniqueWithoutContractInput | ChapterRevisionRequestUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ChapterRevisionRequestCreateManyContractInputEnvelope
    set?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    disconnect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    delete?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    connect?: ChapterRevisionRequestWhereUniqueInput | ChapterRevisionRequestWhereUniqueInput[]
    update?: ChapterRevisionRequestUpdateWithWhereUniqueWithoutContractInput | ChapterRevisionRequestUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ChapterRevisionRequestUpdateManyWithWhereWithoutContractInput | ChapterRevisionRequestUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ChapterRevisionRequestScalarWhereInput | ChapterRevisionRequestScalarWhereInput[]
  }

  export type ProjectContractCreateNestedOneWithoutRevisionRequestsInput = {
    create?: XOR<ProjectContractCreateWithoutRevisionRequestsInput, ProjectContractUncheckedCreateWithoutRevisionRequestsInput>
    connectOrCreate?: ProjectContractCreateOrConnectWithoutRevisionRequestsInput
    connect?: ProjectContractWhereUniqueInput
  }

  export type ChapterCreateNestedOneWithoutRevisionRequestsInput = {
    create?: XOR<ChapterCreateWithoutRevisionRequestsInput, ChapterUncheckedCreateWithoutRevisionRequestsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutRevisionRequestsInput
    connect?: ChapterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRevisionRequestsInput = {
    create?: XOR<UserCreateWithoutRevisionRequestsInput, UserUncheckedCreateWithoutRevisionRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRevisionRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRevisionRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RevisionRequestStatus
  }

  export type ProjectContractUpdateOneRequiredWithoutRevisionRequestsNestedInput = {
    create?: XOR<ProjectContractCreateWithoutRevisionRequestsInput, ProjectContractUncheckedCreateWithoutRevisionRequestsInput>
    connectOrCreate?: ProjectContractCreateOrConnectWithoutRevisionRequestsInput
    upsert?: ProjectContractUpsertWithoutRevisionRequestsInput
    connect?: ProjectContractWhereUniqueInput
    update?: XOR<XOR<ProjectContractUpdateToOneWithWhereWithoutRevisionRequestsInput, ProjectContractUpdateWithoutRevisionRequestsInput>, ProjectContractUncheckedUpdateWithoutRevisionRequestsInput>
  }

  export type ChapterUpdateOneRequiredWithoutRevisionRequestsNestedInput = {
    create?: XOR<ChapterCreateWithoutRevisionRequestsInput, ChapterUncheckedCreateWithoutRevisionRequestsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutRevisionRequestsInput
    upsert?: ChapterUpsertWithoutRevisionRequestsInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutRevisionRequestsInput, ChapterUpdateWithoutRevisionRequestsInput>, ChapterUncheckedUpdateWithoutRevisionRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutRevisionRequestsNestedInput = {
    create?: XOR<UserCreateWithoutRevisionRequestsInput, UserUncheckedCreateWithoutRevisionRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRevisionRequestsInput
    upsert?: UserUpsertWithoutRevisionRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRevisionRequestsInput, UserUpdateWithoutRevisionRequestsInput>, UserUncheckedUpdateWithoutRevisionRequestsInput>
  }

  export type EditorProfileCreateNestedOneWithoutReviewsInput = {
    create?: XOR<EditorProfileCreateWithoutReviewsInput, EditorProfileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: EditorProfileCreateOrConnectWithoutReviewsInput
    connect?: EditorProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuthorReviewsInput = {
    create?: XOR<UserCreateWithoutAuthorReviewsInput, UserUncheckedCreateWithoutAuthorReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkCreateNestedOneWithoutReviewsInput = {
    create?: XOR<WorkCreateWithoutReviewsInput, WorkUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutReviewsInput
    connect?: WorkWhereUniqueInput
  }

  export type EditorProfileUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<EditorProfileCreateWithoutReviewsInput, EditorProfileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: EditorProfileCreateOrConnectWithoutReviewsInput
    upsert?: EditorProfileUpsertWithoutReviewsInput
    connect?: EditorProfileWhereUniqueInput
    update?: XOR<XOR<EditorProfileUpdateToOneWithWhereWithoutReviewsInput, EditorProfileUpdateWithoutReviewsInput>, EditorProfileUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutAuthorReviewsNestedInput = {
    create?: XOR<UserCreateWithoutAuthorReviewsInput, UserUncheckedCreateWithoutAuthorReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorReviewsInput
    upsert?: UserUpsertWithoutAuthorReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthorReviewsInput, UserUpdateWithoutAuthorReviewsInput>, UserUncheckedUpdateWithoutAuthorReviewsInput>
  }

  export type WorkUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<WorkCreateWithoutReviewsInput, WorkUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutReviewsInput
    upsert?: WorkUpsertWithoutReviewsInput
    connect?: WorkWhereUniqueInput
    update?: XOR<XOR<WorkUpdateToOneWithWhereWithoutReviewsInput, WorkUpdateWithoutReviewsInput>, WorkUncheckedUpdateWithoutReviewsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAgeRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingFilter<$PrismaModel> | $Enums.AgeRating
  }

  export type NestedEnumWorkStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkStatus | EnumWorkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkStatus[] | ListEnumWorkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkStatus[] | ListEnumWorkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkStatusFilter<$PrismaModel> | $Enums.WorkStatus
  }

  export type NestedEnumOriginalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OriginalStatus | EnumOriginalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OriginalStatus[] | ListEnumOriginalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OriginalStatus[] | ListEnumOriginalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOriginalStatusFilter<$PrismaModel> | $Enums.OriginalStatus
  }

  export type NestedEnumSourceLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceLanguage | EnumSourceLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.SourceLanguage[] | ListEnumSourceLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceLanguage[] | ListEnumSourceLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceLanguageFilter<$PrismaModel> | $Enums.SourceLanguage
  }

  export type NestedEnumAgeRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingWithAggregatesFilter<$PrismaModel> | $Enums.AgeRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgeRatingFilter<$PrismaModel>
    _max?: NestedEnumAgeRatingFilter<$PrismaModel>
  }

  export type NestedEnumWorkStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkStatus | EnumWorkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkStatus[] | ListEnumWorkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkStatus[] | ListEnumWorkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkStatusFilter<$PrismaModel>
  }

  export type NestedEnumOriginalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OriginalStatus | EnumOriginalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OriginalStatus[] | ListEnumOriginalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OriginalStatus[] | ListEnumOriginalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOriginalStatusWithAggregatesFilter<$PrismaModel> | $Enums.OriginalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOriginalStatusFilter<$PrismaModel>
    _max?: NestedEnumOriginalStatusFilter<$PrismaModel>
  }

  export type NestedEnumSourceLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceLanguage | EnumSourceLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.SourceLanguage[] | ListEnumSourceLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceLanguage[] | ListEnumSourceLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceLanguageWithAggregatesFilter<$PrismaModel> | $Enums.SourceLanguage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceLanguageFilter<$PrismaModel>
    _max?: NestedEnumSourceLanguageFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumChapterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusFilter<$PrismaModel> | $Enums.ChapterStatus
  }

  export type NestedEnumChapterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChapterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChapterStatusFilter<$PrismaModel>
    _max?: NestedEnumChapterStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type NestedEnumLogCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryFilter<$PrismaModel> | $Enums.LogCategory
  }

  export type NestedEnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type NestedEnumLogCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryWithAggregatesFilter<$PrismaModel> | $Enums.LogCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogCategoryFilter<$PrismaModel>
    _max?: NestedEnumLogCategoryFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumBibleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BibleStatus | EnumBibleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BibleStatus[] | ListEnumBibleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BibleStatus[] | ListEnumBibleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBibleStatusFilter<$PrismaModel> | $Enums.BibleStatus
  }

  export type NestedEnumBibleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BibleStatus | EnumBibleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BibleStatus[] | ListEnumBibleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BibleStatus[] | ListEnumBibleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBibleStatusWithAggregatesFilter<$PrismaModel> | $Enums.BibleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBibleStatusFilter<$PrismaModel>
    _max?: NestedEnumBibleStatusFilter<$PrismaModel>
  }

  export type NestedEnumCharacterRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterRole | EnumCharacterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CharacterRole[] | ListEnumCharacterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CharacterRole[] | ListEnumCharacterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCharacterRoleFilter<$PrismaModel> | $Enums.CharacterRole
  }

  export type NestedEnumCharacterRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterRole | EnumCharacterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CharacterRole[] | ListEnumCharacterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CharacterRole[] | ListEnumCharacterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCharacterRoleWithAggregatesFilter<$PrismaModel> | $Enums.CharacterRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCharacterRoleFilter<$PrismaModel>
    _max?: NestedEnumCharacterRoleFilter<$PrismaModel>
  }

  export type NestedEnumTermCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TermCategory | EnumTermCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TermCategory[] | ListEnumTermCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TermCategory[] | ListEnumTermCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTermCategoryFilter<$PrismaModel> | $Enums.TermCategory
  }

  export type NestedEnumTermCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TermCategory | EnumTermCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TermCategory[] | ListEnumTermCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TermCategory[] | ListEnumTermCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTermCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TermCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTermCategoryFilter<$PrismaModel>
    _max?: NestedEnumTermCategoryFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumBibleJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BibleJobStatus | EnumBibleJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BibleJobStatus[] | ListEnumBibleJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BibleJobStatus[] | ListEnumBibleJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBibleJobStatusFilter<$PrismaModel> | $Enums.BibleJobStatus
  }

  export type NestedEnumBibleJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BibleJobStatus | EnumBibleJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BibleJobStatus[] | ListEnumBibleJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BibleJobStatus[] | ListEnumBibleJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBibleJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.BibleJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBibleJobStatusFilter<$PrismaModel>
    _max?: NestedEnumBibleJobStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSnapshotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotType | EnumSnapshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotTypeFilter<$PrismaModel> | $Enums.SnapshotType
  }

  export type NestedEnumSnapshotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotType | EnumSnapshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SnapshotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnapshotTypeFilter<$PrismaModel>
    _max?: NestedEnumSnapshotTypeFilter<$PrismaModel>
  }

  export type NestedEnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type NestedEnumChangeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeStatus | EnumChangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeStatusFilter<$PrismaModel> | $Enums.ChangeStatus
  }

  export type NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type NestedEnumChangeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeStatus | EnumChangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChangeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeStatusFilter<$PrismaModel>
    _max?: NestedEnumChangeStatusFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedEnumEditorAvailabilityFilter<$PrismaModel = never> = {
    equals?: $Enums.EditorAvailability | EnumEditorAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.EditorAvailability[] | ListEnumEditorAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.EditorAvailability[] | ListEnumEditorAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumEditorAvailabilityFilter<$PrismaModel> | $Enums.EditorAvailability
  }

  export type NestedEnumEditorAvailabilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EditorAvailability | EnumEditorAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.EditorAvailability[] | ListEnumEditorAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.EditorAvailability[] | ListEnumEditorAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumEditorAvailabilityWithAggregatesFilter<$PrismaModel> | $Enums.EditorAvailability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEditorAvailabilityFilter<$PrismaModel>
    _max?: NestedEnumEditorAvailabilityFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumProjectListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectListingStatus | EnumProjectListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectListingStatus[] | ListEnumProjectListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectListingStatus[] | ListEnumProjectListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectListingStatusFilter<$PrismaModel> | $Enums.ProjectListingStatus
  }

  export type NestedEnumProjectListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectListingStatus | EnumProjectListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectListingStatus[] | ListEnumProjectListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectListingStatus[] | ListEnumProjectListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectListingStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectListingStatusFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumRevisionRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionRequestStatus | EnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionRequestStatus[] | ListEnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionRequestStatus[] | ListEnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionRequestStatusFilter<$PrismaModel> | $Enums.RevisionRequestStatus
  }

  export type NestedEnumRevisionRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionRequestStatus | EnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionRequestStatus[] | ListEnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionRequestStatus[] | ListEnumRevisionRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RevisionRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRevisionRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRevisionRequestStatusFilter<$PrismaModel>
  }

  export type WorkCreateWithoutAuthorInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    editor?: UserCreateNestedOneWithoutEditingWorksInput
    chapters?: ChapterCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemCreateNestedManyWithoutWorkInput
    creators?: CreatorCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobCreateNestedManyWithoutWorkInput
    listings?: ProjectListingCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutAuthorInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemUncheckedCreateNestedManyWithoutWorkInput
    creators?: CreatorUncheckedCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleUncheckedCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput
    listings?: ProjectListingUncheckedCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractUncheckedCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutAuthorInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutAuthorInput, WorkUncheckedCreateWithoutAuthorInput>
  }

  export type WorkCreateManyAuthorInputEnvelope = {
    data: WorkCreateManyAuthorInput | WorkCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type WorkCreateWithoutEditorInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWorksInput
    chapters?: ChapterCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemCreateNestedManyWithoutWorkInput
    creators?: CreatorCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobCreateNestedManyWithoutWorkInput
    listings?: ProjectListingCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutEditorInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemUncheckedCreateNestedManyWithoutWorkInput
    creators?: CreatorUncheckedCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleUncheckedCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput
    listings?: ProjectListingUncheckedCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractUncheckedCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutEditorInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutEditorInput, WorkUncheckedCreateWithoutEditorInput>
  }

  export type WorkCreateManyEditorInputEnvelope = {
    data: WorkCreateManyEditorInput | WorkCreateManyEditorInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChapterCreateWithoutLastEditedByInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    work: WorkCreateNestedOneWithoutChaptersInput
    comments?: ChapterCommentCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutLastEditedByInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: Date | string | null
    workId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutLastEditedByInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutLastEditedByInput, ChapterUncheckedCreateWithoutLastEditedByInput>
  }

  export type ChapterCreateManyLastEditedByInputEnvelope = {
    data: ChapterCreateManyLastEditedByInput | ChapterCreateManyLastEditedByInput[]
    skipDuplicates?: boolean
  }

  export type ChapterCommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutCommentsInput
    parent?: ChapterCommentCreateNestedOneWithoutRepliesInput
    replies?: ChapterCommentCreateNestedManyWithoutParentInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
  }

  export type ChapterCommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    chapterId: string
    parentId?: string | null
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ChapterCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ChapterCommentCreateOrConnectWithoutAuthorInput = {
    where: ChapterCommentWhereUniqueInput
    create: XOR<ChapterCommentCreateWithoutAuthorInput, ChapterCommentUncheckedCreateWithoutAuthorInput>
  }

  export type ChapterCommentCreateManyAuthorInputEnvelope = {
    data: ChapterCommentCreateManyAuthorInput | ChapterCommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ChapterCommentCreateWithoutResolvedByInput = {
    id?: string
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    parent?: ChapterCommentCreateNestedOneWithoutRepliesInput
    replies?: ChapterCommentCreateNestedManyWithoutParentInput
  }

  export type ChapterCommentUncheckedCreateWithoutResolvedByInput = {
    id?: string
    chapterId: string
    authorId: string
    parentId?: string | null
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ChapterCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ChapterCommentCreateOrConnectWithoutResolvedByInput = {
    where: ChapterCommentWhereUniqueInput
    create: XOR<ChapterCommentCreateWithoutResolvedByInput, ChapterCommentUncheckedCreateWithoutResolvedByInput>
  }

  export type ChapterCommentCreateManyResolvedByInputEnvelope = {
    data: ChapterCommentCreateManyResolvedByInput | ChapterCommentCreateManyResolvedByInput[]
    skipDuplicates?: boolean
  }

  export type ChapterSnapshotCreateWithoutAuthorInput = {
    id?: string
    name?: string | null
    description?: string | null
    snapshotType?: $Enums.SnapshotType
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status: $Enums.ChapterStatus
    triggerEvent?: string | null
    createdAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutSnapshotsInput
  }

  export type ChapterSnapshotUncheckedCreateWithoutAuthorInput = {
    id?: string
    chapterId: string
    name?: string | null
    description?: string | null
    snapshotType?: $Enums.SnapshotType
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status: $Enums.ChapterStatus
    triggerEvent?: string | null
    createdAt?: Date | string
  }

  export type ChapterSnapshotCreateOrConnectWithoutAuthorInput = {
    where: ChapterSnapshotWhereUniqueInput
    create: XOR<ChapterSnapshotCreateWithoutAuthorInput, ChapterSnapshotUncheckedCreateWithoutAuthorInput>
  }

  export type ChapterSnapshotCreateManyAuthorInputEnvelope = {
    data: ChapterSnapshotCreateManyAuthorInput | ChapterSnapshotCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ChapterChangeCreateWithoutAuthorInput = {
    id?: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutChangesInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedChangesInput
  }

  export type ChapterChangeUncheckedCreateWithoutAuthorInput = {
    id?: string
    chapterId: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChapterChangeCreateOrConnectWithoutAuthorInput = {
    where: ChapterChangeWhereUniqueInput
    create: XOR<ChapterChangeCreateWithoutAuthorInput, ChapterChangeUncheckedCreateWithoutAuthorInput>
  }

  export type ChapterChangeCreateManyAuthorInputEnvelope = {
    data: ChapterChangeCreateManyAuthorInput | ChapterChangeCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ChapterChangeCreateWithoutReviewedByInput = {
    id?: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutChangesInput
    author: UserCreateNestedOneWithoutChangesInput
  }

  export type ChapterChangeUncheckedCreateWithoutReviewedByInput = {
    id?: string
    chapterId: string
    authorId: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChapterChangeCreateOrConnectWithoutReviewedByInput = {
    where: ChapterChangeWhereUniqueInput
    create: XOR<ChapterChangeCreateWithoutReviewedByInput, ChapterChangeUncheckedCreateWithoutReviewedByInput>
  }

  export type ChapterChangeCreateManyReviewedByInputEnvelope = {
    data: ChapterChangeCreateManyReviewedByInput | ChapterChangeCreateManyReviewedByInput[]
    skipDuplicates?: boolean
  }

  export type ChapterActivityCreateWithoutActorInput = {
    id?: string
    activityType: $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary: string
    createdAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutActivitiesInput
  }

  export type ChapterActivityUncheckedCreateWithoutActorInput = {
    id?: string
    chapterId: string
    activityType: $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary: string
    createdAt?: Date | string
  }

  export type ChapterActivityCreateOrConnectWithoutActorInput = {
    where: ChapterActivityWhereUniqueInput
    create: XOR<ChapterActivityCreateWithoutActorInput, ChapterActivityUncheckedCreateWithoutActorInput>
  }

  export type ChapterActivityCreateManyActorInputEnvelope = {
    data: ChapterActivityCreateManyActorInput | ChapterActivityCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type EditorProfileCreateWithoutUserInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioItems?: PortfolioItemCreateNestedManyWithoutProfileInput
    applications?: ProjectApplicationCreateNestedManyWithoutEditorProfileInput
    reviews?: EditorReviewCreateNestedManyWithoutEditorProfileInput
  }

  export type EditorProfileUncheckedCreateWithoutUserInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioItems?: PortfolioItemUncheckedCreateNestedManyWithoutProfileInput
    applications?: ProjectApplicationUncheckedCreateNestedManyWithoutEditorProfileInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutEditorProfileInput
  }

  export type EditorProfileCreateOrConnectWithoutUserInput = {
    where: EditorProfileWhereUniqueInput
    create: XOR<EditorProfileCreateWithoutUserInput, EditorProfileUncheckedCreateWithoutUserInput>
  }

  export type ProjectListingCreateWithoutAuthorInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    work: WorkCreateNestedOneWithoutListingsInput
    applications?: ProjectApplicationCreateNestedManyWithoutListingInput
    contract?: ProjectContractCreateNestedOneWithoutListingInput
  }

  export type ProjectListingUncheckedCreateWithoutAuthorInput = {
    id?: string
    workId: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ProjectApplicationUncheckedCreateNestedManyWithoutListingInput
    contract?: ProjectContractUncheckedCreateNestedOneWithoutListingInput
  }

  export type ProjectListingCreateOrConnectWithoutAuthorInput = {
    where: ProjectListingWhereUniqueInput
    create: XOR<ProjectListingCreateWithoutAuthorInput, ProjectListingUncheckedCreateWithoutAuthorInput>
  }

  export type ProjectListingCreateManyAuthorInputEnvelope = {
    data: ProjectListingCreateManyAuthorInput | ProjectListingCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectContractCreateWithoutAuthorInput = {
    id?: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    listing: ProjectListingCreateNestedOneWithoutContractInput
    work: WorkCreateNestedOneWithoutContractsInput
    editor: UserCreateNestedOneWithoutEditorContractsInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutContractInput
  }

  export type ProjectContractUncheckedCreateWithoutAuthorInput = {
    id?: string
    listingId: string
    workId: string
    editorId: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutContractInput
  }

  export type ProjectContractCreateOrConnectWithoutAuthorInput = {
    where: ProjectContractWhereUniqueInput
    create: XOR<ProjectContractCreateWithoutAuthorInput, ProjectContractUncheckedCreateWithoutAuthorInput>
  }

  export type ProjectContractCreateManyAuthorInputEnvelope = {
    data: ProjectContractCreateManyAuthorInput | ProjectContractCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectContractCreateWithoutEditorInput = {
    id?: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    listing: ProjectListingCreateNestedOneWithoutContractInput
    work: WorkCreateNestedOneWithoutContractsInput
    author: UserCreateNestedOneWithoutAuthorContractsInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutContractInput
  }

  export type ProjectContractUncheckedCreateWithoutEditorInput = {
    id?: string
    listingId: string
    workId: string
    authorId: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutContractInput
  }

  export type ProjectContractCreateOrConnectWithoutEditorInput = {
    where: ProjectContractWhereUniqueInput
    create: XOR<ProjectContractCreateWithoutEditorInput, ProjectContractUncheckedCreateWithoutEditorInput>
  }

  export type ProjectContractCreateManyEditorInputEnvelope = {
    data: ProjectContractCreateManyEditorInput | ProjectContractCreateManyEditorInput[]
    skipDuplicates?: boolean
  }

  export type ChapterRevisionRequestCreateWithoutRequestedByInput = {
    id?: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
    contract: ProjectContractCreateNestedOneWithoutRevisionRequestsInput
    chapter: ChapterCreateNestedOneWithoutRevisionRequestsInput
  }

  export type ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput = {
    id?: string
    contractId: string
    chapterId: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
  }

  export type ChapterRevisionRequestCreateOrConnectWithoutRequestedByInput = {
    where: ChapterRevisionRequestWhereUniqueInput
    create: XOR<ChapterRevisionRequestCreateWithoutRequestedByInput, ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput>
  }

  export type ChapterRevisionRequestCreateManyRequestedByInputEnvelope = {
    data: ChapterRevisionRequestCreateManyRequestedByInput | ChapterRevisionRequestCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type EditorReviewCreateWithoutAuthorInput = {
    id?: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    editorProfile: EditorProfileCreateNestedOneWithoutReviewsInput
    work: WorkCreateNestedOneWithoutReviewsInput
  }

  export type EditorReviewUncheckedCreateWithoutAuthorInput = {
    id?: string
    editorProfileId: string
    workId: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type EditorReviewCreateOrConnectWithoutAuthorInput = {
    where: EditorReviewWhereUniqueInput
    create: XOR<EditorReviewCreateWithoutAuthorInput, EditorReviewUncheckedCreateWithoutAuthorInput>
  }

  export type EditorReviewCreateManyAuthorInputEnvelope = {
    data: EditorReviewCreateManyAuthorInput | EditorReviewCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type WorkUpsertWithWhereUniqueWithoutAuthorInput = {
    where: WorkWhereUniqueInput
    update: XOR<WorkUpdateWithoutAuthorInput, WorkUncheckedUpdateWithoutAuthorInput>
    create: XOR<WorkCreateWithoutAuthorInput, WorkUncheckedCreateWithoutAuthorInput>
  }

  export type WorkUpdateWithWhereUniqueWithoutAuthorInput = {
    where: WorkWhereUniqueInput
    data: XOR<WorkUpdateWithoutAuthorInput, WorkUncheckedUpdateWithoutAuthorInput>
  }

  export type WorkUpdateManyWithWhereWithoutAuthorInput = {
    where: WorkScalarWhereInput
    data: XOR<WorkUpdateManyMutationInput, WorkUncheckedUpdateManyWithoutAuthorInput>
  }

  export type WorkScalarWhereInput = {
    AND?: WorkScalarWhereInput | WorkScalarWhereInput[]
    OR?: WorkScalarWhereInput[]
    NOT?: WorkScalarWhereInput | WorkScalarWhereInput[]
    id?: StringFilter<"Work"> | string
    titleKo?: StringFilter<"Work"> | string
    titleOriginal?: StringFilter<"Work"> | string
    publisher?: StringFilter<"Work"> | string
    ageRating?: EnumAgeRatingFilter<"Work"> | $Enums.AgeRating
    status?: EnumWorkStatusFilter<"Work"> | $Enums.WorkStatus
    coverImage?: StringNullableFilter<"Work"> | string | null
    synopsis?: StringFilter<"Work"> | string
    genres?: StringNullableListFilter<"Work">
    originalStatus?: EnumOriginalStatusFilter<"Work"> | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFilter<"Work"> | $Enums.SourceLanguage
    expectedChapters?: IntNullableFilter<"Work"> | number | null
    platformName?: StringNullableFilter<"Work"> | string | null
    platformUrl?: StringNullableFilter<"Work"> | string | null
    publishedAt?: DateTimeNullableFilter<"Work"> | Date | string | null
    totalChapters?: IntFilter<"Work"> | number
    authorId?: StringFilter<"Work"> | string
    editorId?: StringNullableFilter<"Work"> | string | null
    createdAt?: DateTimeFilter<"Work"> | Date | string
    updatedAt?: DateTimeFilter<"Work"> | Date | string
  }

  export type WorkUpsertWithWhereUniqueWithoutEditorInput = {
    where: WorkWhereUniqueInput
    update: XOR<WorkUpdateWithoutEditorInput, WorkUncheckedUpdateWithoutEditorInput>
    create: XOR<WorkCreateWithoutEditorInput, WorkUncheckedCreateWithoutEditorInput>
  }

  export type WorkUpdateWithWhereUniqueWithoutEditorInput = {
    where: WorkWhereUniqueInput
    data: XOR<WorkUpdateWithoutEditorInput, WorkUncheckedUpdateWithoutEditorInput>
  }

  export type WorkUpdateManyWithWhereWithoutEditorInput = {
    where: WorkScalarWhereInput
    data: XOR<WorkUpdateManyMutationInput, WorkUncheckedUpdateManyWithoutEditorInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type ChapterUpsertWithWhereUniqueWithoutLastEditedByInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutLastEditedByInput, ChapterUncheckedUpdateWithoutLastEditedByInput>
    create: XOR<ChapterCreateWithoutLastEditedByInput, ChapterUncheckedCreateWithoutLastEditedByInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutLastEditedByInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutLastEditedByInput, ChapterUncheckedUpdateWithoutLastEditedByInput>
  }

  export type ChapterUpdateManyWithWhereWithoutLastEditedByInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutLastEditedByInput>
  }

  export type ChapterScalarWhereInput = {
    AND?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    OR?: ChapterScalarWhereInput[]
    NOT?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    id?: StringFilter<"Chapter"> | string
    number?: IntFilter<"Chapter"> | number
    title?: StringNullableFilter<"Chapter"> | string | null
    originalContent?: StringFilter<"Chapter"> | string
    translatedContent?: StringNullableFilter<"Chapter"> | string | null
    editedContent?: StringNullableFilter<"Chapter"> | string | null
    status?: EnumChapterStatusFilter<"Chapter"> | $Enums.ChapterStatus
    wordCount?: IntFilter<"Chapter"> | number
    translationMeta?: JsonNullableFilter<"Chapter">
    trackChangesState?: JsonNullableFilter<"Chapter">
    lastEditedById?: StringNullableFilter<"Chapter"> | string | null
    lastEditedAt?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    workId?: StringFilter<"Chapter"> | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
  }

  export type ChapterCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ChapterCommentWhereUniqueInput
    update: XOR<ChapterCommentUpdateWithoutAuthorInput, ChapterCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<ChapterCommentCreateWithoutAuthorInput, ChapterCommentUncheckedCreateWithoutAuthorInput>
  }

  export type ChapterCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ChapterCommentWhereUniqueInput
    data: XOR<ChapterCommentUpdateWithoutAuthorInput, ChapterCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type ChapterCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: ChapterCommentScalarWhereInput
    data: XOR<ChapterCommentUpdateManyMutationInput, ChapterCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ChapterCommentScalarWhereInput = {
    AND?: ChapterCommentScalarWhereInput | ChapterCommentScalarWhereInput[]
    OR?: ChapterCommentScalarWhereInput[]
    NOT?: ChapterCommentScalarWhereInput | ChapterCommentScalarWhereInput[]
    id?: StringFilter<"ChapterComment"> | string
    chapterId?: StringFilter<"ChapterComment"> | string
    authorId?: StringFilter<"ChapterComment"> | string
    parentId?: StringNullableFilter<"ChapterComment"> | string | null
    content?: StringFilter<"ChapterComment"> | string
    textRange?: JsonNullableFilter<"ChapterComment">
    quotedText?: StringNullableFilter<"ChapterComment"> | string | null
    isResolved?: BoolFilter<"ChapterComment"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ChapterComment"> | Date | string | null
    resolvedById?: StringNullableFilter<"ChapterComment"> | string | null
    createdAt?: DateTimeFilter<"ChapterComment"> | Date | string
    updatedAt?: DateTimeFilter<"ChapterComment"> | Date | string
  }

  export type ChapterCommentUpsertWithWhereUniqueWithoutResolvedByInput = {
    where: ChapterCommentWhereUniqueInput
    update: XOR<ChapterCommentUpdateWithoutResolvedByInput, ChapterCommentUncheckedUpdateWithoutResolvedByInput>
    create: XOR<ChapterCommentCreateWithoutResolvedByInput, ChapterCommentUncheckedCreateWithoutResolvedByInput>
  }

  export type ChapterCommentUpdateWithWhereUniqueWithoutResolvedByInput = {
    where: ChapterCommentWhereUniqueInput
    data: XOR<ChapterCommentUpdateWithoutResolvedByInput, ChapterCommentUncheckedUpdateWithoutResolvedByInput>
  }

  export type ChapterCommentUpdateManyWithWhereWithoutResolvedByInput = {
    where: ChapterCommentScalarWhereInput
    data: XOR<ChapterCommentUpdateManyMutationInput, ChapterCommentUncheckedUpdateManyWithoutResolvedByInput>
  }

  export type ChapterSnapshotUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ChapterSnapshotWhereUniqueInput
    update: XOR<ChapterSnapshotUpdateWithoutAuthorInput, ChapterSnapshotUncheckedUpdateWithoutAuthorInput>
    create: XOR<ChapterSnapshotCreateWithoutAuthorInput, ChapterSnapshotUncheckedCreateWithoutAuthorInput>
  }

  export type ChapterSnapshotUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ChapterSnapshotWhereUniqueInput
    data: XOR<ChapterSnapshotUpdateWithoutAuthorInput, ChapterSnapshotUncheckedUpdateWithoutAuthorInput>
  }

  export type ChapterSnapshotUpdateManyWithWhereWithoutAuthorInput = {
    where: ChapterSnapshotScalarWhereInput
    data: XOR<ChapterSnapshotUpdateManyMutationInput, ChapterSnapshotUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ChapterSnapshotScalarWhereInput = {
    AND?: ChapterSnapshotScalarWhereInput | ChapterSnapshotScalarWhereInput[]
    OR?: ChapterSnapshotScalarWhereInput[]
    NOT?: ChapterSnapshotScalarWhereInput | ChapterSnapshotScalarWhereInput[]
    id?: StringFilter<"ChapterSnapshot"> | string
    chapterId?: StringFilter<"ChapterSnapshot"> | string
    authorId?: StringFilter<"ChapterSnapshot"> | string
    name?: StringNullableFilter<"ChapterSnapshot"> | string | null
    description?: StringNullableFilter<"ChapterSnapshot"> | string | null
    snapshotType?: EnumSnapshotTypeFilter<"ChapterSnapshot"> | $Enums.SnapshotType
    originalContent?: StringFilter<"ChapterSnapshot"> | string
    translatedContent?: StringNullableFilter<"ChapterSnapshot"> | string | null
    editedContent?: StringNullableFilter<"ChapterSnapshot"> | string | null
    status?: EnumChapterStatusFilter<"ChapterSnapshot"> | $Enums.ChapterStatus
    triggerEvent?: StringNullableFilter<"ChapterSnapshot"> | string | null
    createdAt?: DateTimeFilter<"ChapterSnapshot"> | Date | string
  }

  export type ChapterChangeUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ChapterChangeWhereUniqueInput
    update: XOR<ChapterChangeUpdateWithoutAuthorInput, ChapterChangeUncheckedUpdateWithoutAuthorInput>
    create: XOR<ChapterChangeCreateWithoutAuthorInput, ChapterChangeUncheckedCreateWithoutAuthorInput>
  }

  export type ChapterChangeUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ChapterChangeWhereUniqueInput
    data: XOR<ChapterChangeUpdateWithoutAuthorInput, ChapterChangeUncheckedUpdateWithoutAuthorInput>
  }

  export type ChapterChangeUpdateManyWithWhereWithoutAuthorInput = {
    where: ChapterChangeScalarWhereInput
    data: XOR<ChapterChangeUpdateManyMutationInput, ChapterChangeUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ChapterChangeScalarWhereInput = {
    AND?: ChapterChangeScalarWhereInput | ChapterChangeScalarWhereInput[]
    OR?: ChapterChangeScalarWhereInput[]
    NOT?: ChapterChangeScalarWhereInput | ChapterChangeScalarWhereInput[]
    id?: StringFilter<"ChapterChange"> | string
    chapterId?: StringFilter<"ChapterChange"> | string
    authorId?: StringFilter<"ChapterChange"> | string
    changeType?: EnumChangeTypeFilter<"ChapterChange"> | $Enums.ChangeType
    fromPos?: IntFilter<"ChapterChange"> | number
    toPos?: IntFilter<"ChapterChange"> | number
    oldText?: StringNullableFilter<"ChapterChange"> | string | null
    newText?: StringNullableFilter<"ChapterChange"> | string | null
    status?: EnumChangeStatusFilter<"ChapterChange"> | $Enums.ChangeStatus
    reviewedById?: StringNullableFilter<"ChapterChange"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ChapterChange"> | Date | string | null
    createdAt?: DateTimeFilter<"ChapterChange"> | Date | string
  }

  export type ChapterChangeUpsertWithWhereUniqueWithoutReviewedByInput = {
    where: ChapterChangeWhereUniqueInput
    update: XOR<ChapterChangeUpdateWithoutReviewedByInput, ChapterChangeUncheckedUpdateWithoutReviewedByInput>
    create: XOR<ChapterChangeCreateWithoutReviewedByInput, ChapterChangeUncheckedCreateWithoutReviewedByInput>
  }

  export type ChapterChangeUpdateWithWhereUniqueWithoutReviewedByInput = {
    where: ChapterChangeWhereUniqueInput
    data: XOR<ChapterChangeUpdateWithoutReviewedByInput, ChapterChangeUncheckedUpdateWithoutReviewedByInput>
  }

  export type ChapterChangeUpdateManyWithWhereWithoutReviewedByInput = {
    where: ChapterChangeScalarWhereInput
    data: XOR<ChapterChangeUpdateManyMutationInput, ChapterChangeUncheckedUpdateManyWithoutReviewedByInput>
  }

  export type ChapterActivityUpsertWithWhereUniqueWithoutActorInput = {
    where: ChapterActivityWhereUniqueInput
    update: XOR<ChapterActivityUpdateWithoutActorInput, ChapterActivityUncheckedUpdateWithoutActorInput>
    create: XOR<ChapterActivityCreateWithoutActorInput, ChapterActivityUncheckedCreateWithoutActorInput>
  }

  export type ChapterActivityUpdateWithWhereUniqueWithoutActorInput = {
    where: ChapterActivityWhereUniqueInput
    data: XOR<ChapterActivityUpdateWithoutActorInput, ChapterActivityUncheckedUpdateWithoutActorInput>
  }

  export type ChapterActivityUpdateManyWithWhereWithoutActorInput = {
    where: ChapterActivityScalarWhereInput
    data: XOR<ChapterActivityUpdateManyMutationInput, ChapterActivityUncheckedUpdateManyWithoutActorInput>
  }

  export type ChapterActivityScalarWhereInput = {
    AND?: ChapterActivityScalarWhereInput | ChapterActivityScalarWhereInput[]
    OR?: ChapterActivityScalarWhereInput[]
    NOT?: ChapterActivityScalarWhereInput | ChapterActivityScalarWhereInput[]
    id?: StringFilter<"ChapterActivity"> | string
    chapterId?: StringFilter<"ChapterActivity"> | string
    actorId?: StringFilter<"ChapterActivity"> | string
    activityType?: EnumActivityTypeFilter<"ChapterActivity"> | $Enums.ActivityType
    metadata?: JsonNullableFilter<"ChapterActivity">
    summary?: StringFilter<"ChapterActivity"> | string
    createdAt?: DateTimeFilter<"ChapterActivity"> | Date | string
  }

  export type EditorProfileUpsertWithoutUserInput = {
    update: XOR<EditorProfileUpdateWithoutUserInput, EditorProfileUncheckedUpdateWithoutUserInput>
    create: XOR<EditorProfileCreateWithoutUserInput, EditorProfileUncheckedCreateWithoutUserInput>
    where?: EditorProfileWhereInput
  }

  export type EditorProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: EditorProfileWhereInput
    data: XOR<EditorProfileUpdateWithoutUserInput, EditorProfileUncheckedUpdateWithoutUserInput>
  }

  export type EditorProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioItems?: PortfolioItemUpdateManyWithoutProfileNestedInput
    applications?: ProjectApplicationUpdateManyWithoutEditorProfileNestedInput
    reviews?: EditorReviewUpdateManyWithoutEditorProfileNestedInput
  }

  export type EditorProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioItems?: PortfolioItemUncheckedUpdateManyWithoutProfileNestedInput
    applications?: ProjectApplicationUncheckedUpdateManyWithoutEditorProfileNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutEditorProfileNestedInput
  }

  export type ProjectListingUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ProjectListingWhereUniqueInput
    update: XOR<ProjectListingUpdateWithoutAuthorInput, ProjectListingUncheckedUpdateWithoutAuthorInput>
    create: XOR<ProjectListingCreateWithoutAuthorInput, ProjectListingUncheckedCreateWithoutAuthorInput>
  }

  export type ProjectListingUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ProjectListingWhereUniqueInput
    data: XOR<ProjectListingUpdateWithoutAuthorInput, ProjectListingUncheckedUpdateWithoutAuthorInput>
  }

  export type ProjectListingUpdateManyWithWhereWithoutAuthorInput = {
    where: ProjectListingScalarWhereInput
    data: XOR<ProjectListingUpdateManyMutationInput, ProjectListingUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ProjectListingScalarWhereInput = {
    AND?: ProjectListingScalarWhereInput | ProjectListingScalarWhereInput[]
    OR?: ProjectListingScalarWhereInput[]
    NOT?: ProjectListingScalarWhereInput | ProjectListingScalarWhereInput[]
    id?: StringFilter<"ProjectListing"> | string
    workId?: StringFilter<"ProjectListing"> | string
    authorId?: StringFilter<"ProjectListing"> | string
    title?: StringFilter<"ProjectListing"> | string
    description?: StringFilter<"ProjectListing"> | string
    requirements?: StringNullableFilter<"ProjectListing"> | string | null
    status?: EnumProjectListingStatusFilter<"ProjectListing"> | $Enums.ProjectListingStatus
    budgetMin?: IntNullableFilter<"ProjectListing"> | number | null
    budgetMax?: IntNullableFilter<"ProjectListing"> | number | null
    deadline?: DateTimeNullableFilter<"ProjectListing"> | Date | string | null
    chapterStart?: IntNullableFilter<"ProjectListing"> | number | null
    chapterEnd?: IntNullableFilter<"ProjectListing"> | number | null
    viewCount?: IntFilter<"ProjectListing"> | number
    applicationCount?: IntFilter<"ProjectListing"> | number
    publishedAt?: DateTimeNullableFilter<"ProjectListing"> | Date | string | null
    createdAt?: DateTimeFilter<"ProjectListing"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectListing"> | Date | string
  }

  export type ProjectContractUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ProjectContractWhereUniqueInput
    update: XOR<ProjectContractUpdateWithoutAuthorInput, ProjectContractUncheckedUpdateWithoutAuthorInput>
    create: XOR<ProjectContractCreateWithoutAuthorInput, ProjectContractUncheckedCreateWithoutAuthorInput>
  }

  export type ProjectContractUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ProjectContractWhereUniqueInput
    data: XOR<ProjectContractUpdateWithoutAuthorInput, ProjectContractUncheckedUpdateWithoutAuthorInput>
  }

  export type ProjectContractUpdateManyWithWhereWithoutAuthorInput = {
    where: ProjectContractScalarWhereInput
    data: XOR<ProjectContractUpdateManyMutationInput, ProjectContractUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ProjectContractScalarWhereInput = {
    AND?: ProjectContractScalarWhereInput | ProjectContractScalarWhereInput[]
    OR?: ProjectContractScalarWhereInput[]
    NOT?: ProjectContractScalarWhereInput | ProjectContractScalarWhereInput[]
    id?: StringFilter<"ProjectContract"> | string
    listingId?: StringFilter<"ProjectContract"> | string
    workId?: StringFilter<"ProjectContract"> | string
    authorId?: StringFilter<"ProjectContract"> | string
    editorId?: StringFilter<"ProjectContract"> | string
    totalAmount?: IntNullableFilter<"ProjectContract"> | number | null
    startDate?: DateTimeFilter<"ProjectContract"> | Date | string
    expectedEndDate?: DateTimeNullableFilter<"ProjectContract"> | Date | string | null
    chapterStart?: IntFilter<"ProjectContract"> | number
    chapterEnd?: IntNullableFilter<"ProjectContract"> | number | null
    isActive?: BoolFilter<"ProjectContract"> | boolean
    createdAt?: DateTimeFilter<"ProjectContract"> | Date | string
  }

  export type ProjectContractUpsertWithWhereUniqueWithoutEditorInput = {
    where: ProjectContractWhereUniqueInput
    update: XOR<ProjectContractUpdateWithoutEditorInput, ProjectContractUncheckedUpdateWithoutEditorInput>
    create: XOR<ProjectContractCreateWithoutEditorInput, ProjectContractUncheckedCreateWithoutEditorInput>
  }

  export type ProjectContractUpdateWithWhereUniqueWithoutEditorInput = {
    where: ProjectContractWhereUniqueInput
    data: XOR<ProjectContractUpdateWithoutEditorInput, ProjectContractUncheckedUpdateWithoutEditorInput>
  }

  export type ProjectContractUpdateManyWithWhereWithoutEditorInput = {
    where: ProjectContractScalarWhereInput
    data: XOR<ProjectContractUpdateManyMutationInput, ProjectContractUncheckedUpdateManyWithoutEditorInput>
  }

  export type ChapterRevisionRequestUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: ChapterRevisionRequestWhereUniqueInput
    update: XOR<ChapterRevisionRequestUpdateWithoutRequestedByInput, ChapterRevisionRequestUncheckedUpdateWithoutRequestedByInput>
    create: XOR<ChapterRevisionRequestCreateWithoutRequestedByInput, ChapterRevisionRequestUncheckedCreateWithoutRequestedByInput>
  }

  export type ChapterRevisionRequestUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: ChapterRevisionRequestWhereUniqueInput
    data: XOR<ChapterRevisionRequestUpdateWithoutRequestedByInput, ChapterRevisionRequestUncheckedUpdateWithoutRequestedByInput>
  }

  export type ChapterRevisionRequestUpdateManyWithWhereWithoutRequestedByInput = {
    where: ChapterRevisionRequestScalarWhereInput
    data: XOR<ChapterRevisionRequestUpdateManyMutationInput, ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type ChapterRevisionRequestScalarWhereInput = {
    AND?: ChapterRevisionRequestScalarWhereInput | ChapterRevisionRequestScalarWhereInput[]
    OR?: ChapterRevisionRequestScalarWhereInput[]
    NOT?: ChapterRevisionRequestScalarWhereInput | ChapterRevisionRequestScalarWhereInput[]
    id?: StringFilter<"ChapterRevisionRequest"> | string
    contractId?: StringFilter<"ChapterRevisionRequest"> | string
    chapterId?: StringFilter<"ChapterRevisionRequest"> | string
    requestedById?: StringFilter<"ChapterRevisionRequest"> | string
    reason?: StringFilter<"ChapterRevisionRequest"> | string
    specificFeedback?: StringNullableFilter<"ChapterRevisionRequest"> | string | null
    status?: EnumRevisionRequestStatusFilter<"ChapterRevisionRequest"> | $Enums.RevisionRequestStatus
    response?: StringNullableFilter<"ChapterRevisionRequest"> | string | null
    requestedAt?: DateTimeFilter<"ChapterRevisionRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"ChapterRevisionRequest"> | Date | string | null
    revisionCount?: IntFilter<"ChapterRevisionRequest"> | number
  }

  export type EditorReviewUpsertWithWhereUniqueWithoutAuthorInput = {
    where: EditorReviewWhereUniqueInput
    update: XOR<EditorReviewUpdateWithoutAuthorInput, EditorReviewUncheckedUpdateWithoutAuthorInput>
    create: XOR<EditorReviewCreateWithoutAuthorInput, EditorReviewUncheckedCreateWithoutAuthorInput>
  }

  export type EditorReviewUpdateWithWhereUniqueWithoutAuthorInput = {
    where: EditorReviewWhereUniqueInput
    data: XOR<EditorReviewUpdateWithoutAuthorInput, EditorReviewUncheckedUpdateWithoutAuthorInput>
  }

  export type EditorReviewUpdateManyWithWhereWithoutAuthorInput = {
    where: EditorReviewScalarWhereInput
    data: XOR<EditorReviewUpdateManyMutationInput, EditorReviewUncheckedUpdateManyWithoutAuthorInput>
  }

  export type EditorReviewScalarWhereInput = {
    AND?: EditorReviewScalarWhereInput | EditorReviewScalarWhereInput[]
    OR?: EditorReviewScalarWhereInput[]
    NOT?: EditorReviewScalarWhereInput | EditorReviewScalarWhereInput[]
    id?: StringFilter<"EditorReview"> | string
    editorProfileId?: StringFilter<"EditorReview"> | string
    authorId?: StringFilter<"EditorReview"> | string
    workId?: StringFilter<"EditorReview"> | string
    overallRating?: IntFilter<"EditorReview"> | number
    qualityRating?: IntNullableFilter<"EditorReview"> | number | null
    speedRating?: IntNullableFilter<"EditorReview"> | number | null
    communicationRating?: IntNullableFilter<"EditorReview"> | number | null
    content?: StringNullableFilter<"EditorReview"> | string | null
    isPublic?: BoolFilter<"EditorReview"> | boolean
    createdAt?: DateTimeFilter<"EditorReview"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutWorksInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutWorksInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutWorksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorksInput, UserUncheckedCreateWithoutWorksInput>
  }

  export type UserCreateWithoutEditingWorksInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutEditingWorksInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutEditingWorksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEditingWorksInput, UserUncheckedCreateWithoutEditingWorksInput>
  }

  export type ChapterCreateWithoutWorkInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastEditedBy?: UserCreateNestedOneWithoutLastEditedChaptersInput
    comments?: ChapterCommentCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutWorkInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: string | null
    lastEditedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutWorkInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutWorkInput, ChapterUncheckedCreateWithoutWorkInput>
  }

  export type ChapterCreateManyWorkInputEnvelope = {
    data: ChapterCreateManyWorkInput | ChapterCreateManyWorkInput[]
    skipDuplicates?: boolean
  }

  export type GlossaryItemCreateWithoutWorkInput = {
    id?: string
    original: string
    translated: string
    category?: string | null
    note?: string | null
  }

  export type GlossaryItemUncheckedCreateWithoutWorkInput = {
    id?: string
    original: string
    translated: string
    category?: string | null
    note?: string | null
  }

  export type GlossaryItemCreateOrConnectWithoutWorkInput = {
    where: GlossaryItemWhereUniqueInput
    create: XOR<GlossaryItemCreateWithoutWorkInput, GlossaryItemUncheckedCreateWithoutWorkInput>
  }

  export type GlossaryItemCreateManyWorkInputEnvelope = {
    data: GlossaryItemCreateManyWorkInput | GlossaryItemCreateManyWorkInput[]
    skipDuplicates?: boolean
  }

  export type CreatorCreateWithoutWorkInput = {
    id?: string
    name: string
    role: string
  }

  export type CreatorUncheckedCreateWithoutWorkInput = {
    id?: string
    name: string
    role: string
  }

  export type CreatorCreateOrConnectWithoutWorkInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutWorkInput, CreatorUncheckedCreateWithoutWorkInput>
  }

  export type CreatorCreateManyWorkInputEnvelope = {
    data: CreatorCreateManyWorkInput | CreatorCreateManyWorkInput[]
    skipDuplicates?: boolean
  }

  export type SettingBibleCreateWithoutWorkInput = {
    id?: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutBibleInput
    terms?: SettingTermCreateNestedManyWithoutBibleInput
    events?: TimelineEventCreateNestedManyWithoutBibleInput
  }

  export type SettingBibleUncheckedCreateWithoutWorkInput = {
    id?: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutBibleInput
    terms?: SettingTermUncheckedCreateNestedManyWithoutBibleInput
    events?: TimelineEventUncheckedCreateNestedManyWithoutBibleInput
  }

  export type SettingBibleCreateOrConnectWithoutWorkInput = {
    where: SettingBibleWhereUniqueInput
    create: XOR<SettingBibleCreateWithoutWorkInput, SettingBibleUncheckedCreateWithoutWorkInput>
  }

  export type BibleGenerationJobCreateWithoutWorkInput = {
    id?: string
    userId: string
    status?: $Enums.BibleJobStatus
    batchPlan: JsonNullValueInput | InputJsonValue
    totalBatches: number
    currentBatchIndex?: number
    analyzedChapters?: number
    retryCount?: number
    maxRetries?: number
    errorMessage?: string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lockedAt?: Date | string | null
    lockedBy?: string | null
  }

  export type BibleGenerationJobUncheckedCreateWithoutWorkInput = {
    id?: string
    userId: string
    status?: $Enums.BibleJobStatus
    batchPlan: JsonNullValueInput | InputJsonValue
    totalBatches: number
    currentBatchIndex?: number
    analyzedChapters?: number
    retryCount?: number
    maxRetries?: number
    errorMessage?: string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lockedAt?: Date | string | null
    lockedBy?: string | null
  }

  export type BibleGenerationJobCreateOrConnectWithoutWorkInput = {
    where: BibleGenerationJobWhereUniqueInput
    create: XOR<BibleGenerationJobCreateWithoutWorkInput, BibleGenerationJobUncheckedCreateWithoutWorkInput>
  }

  export type BibleGenerationJobCreateManyWorkInputEnvelope = {
    data: BibleGenerationJobCreateManyWorkInput | BibleGenerationJobCreateManyWorkInput[]
    skipDuplicates?: boolean
  }

  export type ProjectListingCreateWithoutWorkInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutAuthorListingsInput
    applications?: ProjectApplicationCreateNestedManyWithoutListingInput
    contract?: ProjectContractCreateNestedOneWithoutListingInput
  }

  export type ProjectListingUncheckedCreateWithoutWorkInput = {
    id?: string
    authorId: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ProjectApplicationUncheckedCreateNestedManyWithoutListingInput
    contract?: ProjectContractUncheckedCreateNestedOneWithoutListingInput
  }

  export type ProjectListingCreateOrConnectWithoutWorkInput = {
    where: ProjectListingWhereUniqueInput
    create: XOR<ProjectListingCreateWithoutWorkInput, ProjectListingUncheckedCreateWithoutWorkInput>
  }

  export type ProjectListingCreateManyWorkInputEnvelope = {
    data: ProjectListingCreateManyWorkInput | ProjectListingCreateManyWorkInput[]
    skipDuplicates?: boolean
  }

  export type ProjectContractCreateWithoutWorkInput = {
    id?: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    listing: ProjectListingCreateNestedOneWithoutContractInput
    author: UserCreateNestedOneWithoutAuthorContractsInput
    editor: UserCreateNestedOneWithoutEditorContractsInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutContractInput
  }

  export type ProjectContractUncheckedCreateWithoutWorkInput = {
    id?: string
    listingId: string
    authorId: string
    editorId: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutContractInput
  }

  export type ProjectContractCreateOrConnectWithoutWorkInput = {
    where: ProjectContractWhereUniqueInput
    create: XOR<ProjectContractCreateWithoutWorkInput, ProjectContractUncheckedCreateWithoutWorkInput>
  }

  export type ProjectContractCreateManyWorkInputEnvelope = {
    data: ProjectContractCreateManyWorkInput | ProjectContractCreateManyWorkInput[]
    skipDuplicates?: boolean
  }

  export type EditorReviewCreateWithoutWorkInput = {
    id?: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    editorProfile: EditorProfileCreateNestedOneWithoutReviewsInput
    author: UserCreateNestedOneWithoutAuthorReviewsInput
  }

  export type EditorReviewUncheckedCreateWithoutWorkInput = {
    id?: string
    editorProfileId: string
    authorId: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type EditorReviewCreateOrConnectWithoutWorkInput = {
    where: EditorReviewWhereUniqueInput
    create: XOR<EditorReviewCreateWithoutWorkInput, EditorReviewUncheckedCreateWithoutWorkInput>
  }

  export type EditorReviewCreateManyWorkInputEnvelope = {
    data: EditorReviewCreateManyWorkInput | EditorReviewCreateManyWorkInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorksInput = {
    update: XOR<UserUpdateWithoutWorksInput, UserUncheckedUpdateWithoutWorksInput>
    create: XOR<UserCreateWithoutWorksInput, UserUncheckedCreateWithoutWorksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorksInput, UserUncheckedUpdateWithoutWorksInput>
  }

  export type UserUpdateWithoutWorksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutWorksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUpsertWithoutEditingWorksInput = {
    update: XOR<UserUpdateWithoutEditingWorksInput, UserUncheckedUpdateWithoutEditingWorksInput>
    create: XOR<UserCreateWithoutEditingWorksInput, UserUncheckedCreateWithoutEditingWorksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEditingWorksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEditingWorksInput, UserUncheckedUpdateWithoutEditingWorksInput>
  }

  export type UserUpdateWithoutEditingWorksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutEditingWorksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ChapterUpsertWithWhereUniqueWithoutWorkInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutWorkInput, ChapterUncheckedUpdateWithoutWorkInput>
    create: XOR<ChapterCreateWithoutWorkInput, ChapterUncheckedCreateWithoutWorkInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutWorkInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutWorkInput, ChapterUncheckedUpdateWithoutWorkInput>
  }

  export type ChapterUpdateManyWithWhereWithoutWorkInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutWorkInput>
  }

  export type GlossaryItemUpsertWithWhereUniqueWithoutWorkInput = {
    where: GlossaryItemWhereUniqueInput
    update: XOR<GlossaryItemUpdateWithoutWorkInput, GlossaryItemUncheckedUpdateWithoutWorkInput>
    create: XOR<GlossaryItemCreateWithoutWorkInput, GlossaryItemUncheckedCreateWithoutWorkInput>
  }

  export type GlossaryItemUpdateWithWhereUniqueWithoutWorkInput = {
    where: GlossaryItemWhereUniqueInput
    data: XOR<GlossaryItemUpdateWithoutWorkInput, GlossaryItemUncheckedUpdateWithoutWorkInput>
  }

  export type GlossaryItemUpdateManyWithWhereWithoutWorkInput = {
    where: GlossaryItemScalarWhereInput
    data: XOR<GlossaryItemUpdateManyMutationInput, GlossaryItemUncheckedUpdateManyWithoutWorkInput>
  }

  export type GlossaryItemScalarWhereInput = {
    AND?: GlossaryItemScalarWhereInput | GlossaryItemScalarWhereInput[]
    OR?: GlossaryItemScalarWhereInput[]
    NOT?: GlossaryItemScalarWhereInput | GlossaryItemScalarWhereInput[]
    id?: StringFilter<"GlossaryItem"> | string
    original?: StringFilter<"GlossaryItem"> | string
    translated?: StringFilter<"GlossaryItem"> | string
    category?: StringNullableFilter<"GlossaryItem"> | string | null
    note?: StringNullableFilter<"GlossaryItem"> | string | null
    workId?: StringFilter<"GlossaryItem"> | string
  }

  export type CreatorUpsertWithWhereUniqueWithoutWorkInput = {
    where: CreatorWhereUniqueInput
    update: XOR<CreatorUpdateWithoutWorkInput, CreatorUncheckedUpdateWithoutWorkInput>
    create: XOR<CreatorCreateWithoutWorkInput, CreatorUncheckedCreateWithoutWorkInput>
  }

  export type CreatorUpdateWithWhereUniqueWithoutWorkInput = {
    where: CreatorWhereUniqueInput
    data: XOR<CreatorUpdateWithoutWorkInput, CreatorUncheckedUpdateWithoutWorkInput>
  }

  export type CreatorUpdateManyWithWhereWithoutWorkInput = {
    where: CreatorScalarWhereInput
    data: XOR<CreatorUpdateManyMutationInput, CreatorUncheckedUpdateManyWithoutWorkInput>
  }

  export type CreatorScalarWhereInput = {
    AND?: CreatorScalarWhereInput | CreatorScalarWhereInput[]
    OR?: CreatorScalarWhereInput[]
    NOT?: CreatorScalarWhereInput | CreatorScalarWhereInput[]
    id?: StringFilter<"Creator"> | string
    name?: StringFilter<"Creator"> | string
    role?: StringFilter<"Creator"> | string
    workId?: StringFilter<"Creator"> | string
  }

  export type SettingBibleUpsertWithoutWorkInput = {
    update: XOR<SettingBibleUpdateWithoutWorkInput, SettingBibleUncheckedUpdateWithoutWorkInput>
    create: XOR<SettingBibleCreateWithoutWorkInput, SettingBibleUncheckedCreateWithoutWorkInput>
    where?: SettingBibleWhereInput
  }

  export type SettingBibleUpdateToOneWithWhereWithoutWorkInput = {
    where?: SettingBibleWhereInput
    data: XOR<SettingBibleUpdateWithoutWorkInput, SettingBibleUncheckedUpdateWithoutWorkInput>
  }

  export type SettingBibleUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutBibleNestedInput
    terms?: SettingTermUpdateManyWithoutBibleNestedInput
    events?: TimelineEventUpdateManyWithoutBibleNestedInput
  }

  export type SettingBibleUncheckedUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutBibleNestedInput
    terms?: SettingTermUncheckedUpdateManyWithoutBibleNestedInput
    events?: TimelineEventUncheckedUpdateManyWithoutBibleNestedInput
  }

  export type BibleGenerationJobUpsertWithWhereUniqueWithoutWorkInput = {
    where: BibleGenerationJobWhereUniqueInput
    update: XOR<BibleGenerationJobUpdateWithoutWorkInput, BibleGenerationJobUncheckedUpdateWithoutWorkInput>
    create: XOR<BibleGenerationJobCreateWithoutWorkInput, BibleGenerationJobUncheckedCreateWithoutWorkInput>
  }

  export type BibleGenerationJobUpdateWithWhereUniqueWithoutWorkInput = {
    where: BibleGenerationJobWhereUniqueInput
    data: XOR<BibleGenerationJobUpdateWithoutWorkInput, BibleGenerationJobUncheckedUpdateWithoutWorkInput>
  }

  export type BibleGenerationJobUpdateManyWithWhereWithoutWorkInput = {
    where: BibleGenerationJobScalarWhereInput
    data: XOR<BibleGenerationJobUpdateManyMutationInput, BibleGenerationJobUncheckedUpdateManyWithoutWorkInput>
  }

  export type BibleGenerationJobScalarWhereInput = {
    AND?: BibleGenerationJobScalarWhereInput | BibleGenerationJobScalarWhereInput[]
    OR?: BibleGenerationJobScalarWhereInput[]
    NOT?: BibleGenerationJobScalarWhereInput | BibleGenerationJobScalarWhereInput[]
    id?: StringFilter<"BibleGenerationJob"> | string
    workId?: StringFilter<"BibleGenerationJob"> | string
    userId?: StringFilter<"BibleGenerationJob"> | string
    status?: EnumBibleJobStatusFilter<"BibleGenerationJob"> | $Enums.BibleJobStatus
    batchPlan?: JsonFilter<"BibleGenerationJob">
    totalBatches?: IntFilter<"BibleGenerationJob"> | number
    currentBatchIndex?: IntFilter<"BibleGenerationJob"> | number
    analyzedChapters?: IntFilter<"BibleGenerationJob"> | number
    retryCount?: IntFilter<"BibleGenerationJob"> | number
    maxRetries?: IntFilter<"BibleGenerationJob"> | number
    errorMessage?: StringNullableFilter<"BibleGenerationJob"> | string | null
    lastError?: StringNullableFilter<"BibleGenerationJob"> | string | null
    createdAt?: DateTimeFilter<"BibleGenerationJob"> | Date | string
    updatedAt?: DateTimeFilter<"BibleGenerationJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"BibleGenerationJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"BibleGenerationJob"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"BibleGenerationJob"> | Date | string | null
    lockedBy?: StringNullableFilter<"BibleGenerationJob"> | string | null
  }

  export type ProjectListingUpsertWithWhereUniqueWithoutWorkInput = {
    where: ProjectListingWhereUniqueInput
    update: XOR<ProjectListingUpdateWithoutWorkInput, ProjectListingUncheckedUpdateWithoutWorkInput>
    create: XOR<ProjectListingCreateWithoutWorkInput, ProjectListingUncheckedCreateWithoutWorkInput>
  }

  export type ProjectListingUpdateWithWhereUniqueWithoutWorkInput = {
    where: ProjectListingWhereUniqueInput
    data: XOR<ProjectListingUpdateWithoutWorkInput, ProjectListingUncheckedUpdateWithoutWorkInput>
  }

  export type ProjectListingUpdateManyWithWhereWithoutWorkInput = {
    where: ProjectListingScalarWhereInput
    data: XOR<ProjectListingUpdateManyMutationInput, ProjectListingUncheckedUpdateManyWithoutWorkInput>
  }

  export type ProjectContractUpsertWithWhereUniqueWithoutWorkInput = {
    where: ProjectContractWhereUniqueInput
    update: XOR<ProjectContractUpdateWithoutWorkInput, ProjectContractUncheckedUpdateWithoutWorkInput>
    create: XOR<ProjectContractCreateWithoutWorkInput, ProjectContractUncheckedCreateWithoutWorkInput>
  }

  export type ProjectContractUpdateWithWhereUniqueWithoutWorkInput = {
    where: ProjectContractWhereUniqueInput
    data: XOR<ProjectContractUpdateWithoutWorkInput, ProjectContractUncheckedUpdateWithoutWorkInput>
  }

  export type ProjectContractUpdateManyWithWhereWithoutWorkInput = {
    where: ProjectContractScalarWhereInput
    data: XOR<ProjectContractUpdateManyMutationInput, ProjectContractUncheckedUpdateManyWithoutWorkInput>
  }

  export type EditorReviewUpsertWithWhereUniqueWithoutWorkInput = {
    where: EditorReviewWhereUniqueInput
    update: XOR<EditorReviewUpdateWithoutWorkInput, EditorReviewUncheckedUpdateWithoutWorkInput>
    create: XOR<EditorReviewCreateWithoutWorkInput, EditorReviewUncheckedCreateWithoutWorkInput>
  }

  export type EditorReviewUpdateWithWhereUniqueWithoutWorkInput = {
    where: EditorReviewWhereUniqueInput
    data: XOR<EditorReviewUpdateWithoutWorkInput, EditorReviewUncheckedUpdateWithoutWorkInput>
  }

  export type EditorReviewUpdateManyWithWhereWithoutWorkInput = {
    where: EditorReviewScalarWhereInput
    data: XOR<EditorReviewUpdateManyMutationInput, EditorReviewUncheckedUpdateManyWithoutWorkInput>
  }

  export type WorkCreateWithoutCreatorsInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWorksInput
    editor?: UserCreateNestedOneWithoutEditingWorksInput
    chapters?: ChapterCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobCreateNestedManyWithoutWorkInput
    listings?: ProjectListingCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutCreatorsInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemUncheckedCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleUncheckedCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput
    listings?: ProjectListingUncheckedCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractUncheckedCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutCreatorsInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutCreatorsInput, WorkUncheckedCreateWithoutCreatorsInput>
  }

  export type WorkUpsertWithoutCreatorsInput = {
    update: XOR<WorkUpdateWithoutCreatorsInput, WorkUncheckedUpdateWithoutCreatorsInput>
    create: XOR<WorkCreateWithoutCreatorsInput, WorkUncheckedCreateWithoutCreatorsInput>
    where?: WorkWhereInput
  }

  export type WorkUpdateToOneWithWhereWithoutCreatorsInput = {
    where?: WorkWhereInput
    data: XOR<WorkUpdateWithoutCreatorsInput, WorkUncheckedUpdateWithoutCreatorsInput>
  }

  export type WorkUpdateWithoutCreatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWorksNestedInput
    editor?: UserUpdateOneWithoutEditingWorksNestedInput
    chapters?: ChapterUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutCreatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUncheckedUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUncheckedUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUncheckedUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type UserCreateWithoutLastEditedChaptersInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutLastEditedChaptersInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutLastEditedChaptersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLastEditedChaptersInput, UserUncheckedCreateWithoutLastEditedChaptersInput>
  }

  export type WorkCreateWithoutChaptersInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWorksInput
    editor?: UserCreateNestedOneWithoutEditingWorksInput
    glossary?: GlossaryItemCreateNestedManyWithoutWorkInput
    creators?: CreatorCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobCreateNestedManyWithoutWorkInput
    listings?: ProjectListingCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutChaptersInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    glossary?: GlossaryItemUncheckedCreateNestedManyWithoutWorkInput
    creators?: CreatorUncheckedCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleUncheckedCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput
    listings?: ProjectListingUncheckedCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractUncheckedCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutChaptersInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutChaptersInput, WorkUncheckedCreateWithoutChaptersInput>
  }

  export type ChapterCommentCreateWithoutChapterInput = {
    id?: string
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    parent?: ChapterCommentCreateNestedOneWithoutRepliesInput
    replies?: ChapterCommentCreateNestedManyWithoutParentInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
  }

  export type ChapterCommentUncheckedCreateWithoutChapterInput = {
    id?: string
    authorId: string
    parentId?: string | null
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ChapterCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ChapterCommentCreateOrConnectWithoutChapterInput = {
    where: ChapterCommentWhereUniqueInput
    create: XOR<ChapterCommentCreateWithoutChapterInput, ChapterCommentUncheckedCreateWithoutChapterInput>
  }

  export type ChapterCommentCreateManyChapterInputEnvelope = {
    data: ChapterCommentCreateManyChapterInput | ChapterCommentCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type ChapterSnapshotCreateWithoutChapterInput = {
    id?: string
    name?: string | null
    description?: string | null
    snapshotType?: $Enums.SnapshotType
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status: $Enums.ChapterStatus
    triggerEvent?: string | null
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutSnapshotsInput
  }

  export type ChapterSnapshotUncheckedCreateWithoutChapterInput = {
    id?: string
    authorId: string
    name?: string | null
    description?: string | null
    snapshotType?: $Enums.SnapshotType
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status: $Enums.ChapterStatus
    triggerEvent?: string | null
    createdAt?: Date | string
  }

  export type ChapterSnapshotCreateOrConnectWithoutChapterInput = {
    where: ChapterSnapshotWhereUniqueInput
    create: XOR<ChapterSnapshotCreateWithoutChapterInput, ChapterSnapshotUncheckedCreateWithoutChapterInput>
  }

  export type ChapterSnapshotCreateManyChapterInputEnvelope = {
    data: ChapterSnapshotCreateManyChapterInput | ChapterSnapshotCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type ChapterChangeCreateWithoutChapterInput = {
    id?: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutChangesInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedChangesInput
  }

  export type ChapterChangeUncheckedCreateWithoutChapterInput = {
    id?: string
    authorId: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChapterChangeCreateOrConnectWithoutChapterInput = {
    where: ChapterChangeWhereUniqueInput
    create: XOR<ChapterChangeCreateWithoutChapterInput, ChapterChangeUncheckedCreateWithoutChapterInput>
  }

  export type ChapterChangeCreateManyChapterInputEnvelope = {
    data: ChapterChangeCreateManyChapterInput | ChapterChangeCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type ChapterActivityCreateWithoutChapterInput = {
    id?: string
    activityType: $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary: string
    createdAt?: Date | string
    actor: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ChapterActivityUncheckedCreateWithoutChapterInput = {
    id?: string
    actorId: string
    activityType: $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary: string
    createdAt?: Date | string
  }

  export type ChapterActivityCreateOrConnectWithoutChapterInput = {
    where: ChapterActivityWhereUniqueInput
    create: XOR<ChapterActivityCreateWithoutChapterInput, ChapterActivityUncheckedCreateWithoutChapterInput>
  }

  export type ChapterActivityCreateManyChapterInputEnvelope = {
    data: ChapterActivityCreateManyChapterInput | ChapterActivityCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type ChapterRevisionRequestCreateWithoutChapterInput = {
    id?: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
    contract: ProjectContractCreateNestedOneWithoutRevisionRequestsInput
    requestedBy: UserCreateNestedOneWithoutRevisionRequestsInput
  }

  export type ChapterRevisionRequestUncheckedCreateWithoutChapterInput = {
    id?: string
    contractId: string
    requestedById: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
  }

  export type ChapterRevisionRequestCreateOrConnectWithoutChapterInput = {
    where: ChapterRevisionRequestWhereUniqueInput
    create: XOR<ChapterRevisionRequestCreateWithoutChapterInput, ChapterRevisionRequestUncheckedCreateWithoutChapterInput>
  }

  export type ChapterRevisionRequestCreateManyChapterInputEnvelope = {
    data: ChapterRevisionRequestCreateManyChapterInput | ChapterRevisionRequestCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLastEditedChaptersInput = {
    update: XOR<UserUpdateWithoutLastEditedChaptersInput, UserUncheckedUpdateWithoutLastEditedChaptersInput>
    create: XOR<UserCreateWithoutLastEditedChaptersInput, UserUncheckedCreateWithoutLastEditedChaptersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLastEditedChaptersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLastEditedChaptersInput, UserUncheckedUpdateWithoutLastEditedChaptersInput>
  }

  export type UserUpdateWithoutLastEditedChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutLastEditedChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type WorkUpsertWithoutChaptersInput = {
    update: XOR<WorkUpdateWithoutChaptersInput, WorkUncheckedUpdateWithoutChaptersInput>
    create: XOR<WorkCreateWithoutChaptersInput, WorkUncheckedCreateWithoutChaptersInput>
    where?: WorkWhereInput
  }

  export type WorkUpdateToOneWithWhereWithoutChaptersInput = {
    where?: WorkWhereInput
    data: XOR<WorkUpdateWithoutChaptersInput, WorkUncheckedUpdateWithoutChaptersInput>
  }

  export type WorkUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWorksNestedInput
    editor?: UserUpdateOneWithoutEditingWorksNestedInput
    glossary?: GlossaryItemUpdateManyWithoutWorkNestedInput
    creators?: CreatorUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    glossary?: GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput
    creators?: CreatorUncheckedUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUncheckedUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUncheckedUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUncheckedUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type ChapterCommentUpsertWithWhereUniqueWithoutChapterInput = {
    where: ChapterCommentWhereUniqueInput
    update: XOR<ChapterCommentUpdateWithoutChapterInput, ChapterCommentUncheckedUpdateWithoutChapterInput>
    create: XOR<ChapterCommentCreateWithoutChapterInput, ChapterCommentUncheckedCreateWithoutChapterInput>
  }

  export type ChapterCommentUpdateWithWhereUniqueWithoutChapterInput = {
    where: ChapterCommentWhereUniqueInput
    data: XOR<ChapterCommentUpdateWithoutChapterInput, ChapterCommentUncheckedUpdateWithoutChapterInput>
  }

  export type ChapterCommentUpdateManyWithWhereWithoutChapterInput = {
    where: ChapterCommentScalarWhereInput
    data: XOR<ChapterCommentUpdateManyMutationInput, ChapterCommentUncheckedUpdateManyWithoutChapterInput>
  }

  export type ChapterSnapshotUpsertWithWhereUniqueWithoutChapterInput = {
    where: ChapterSnapshotWhereUniqueInput
    update: XOR<ChapterSnapshotUpdateWithoutChapterInput, ChapterSnapshotUncheckedUpdateWithoutChapterInput>
    create: XOR<ChapterSnapshotCreateWithoutChapterInput, ChapterSnapshotUncheckedCreateWithoutChapterInput>
  }

  export type ChapterSnapshotUpdateWithWhereUniqueWithoutChapterInput = {
    where: ChapterSnapshotWhereUniqueInput
    data: XOR<ChapterSnapshotUpdateWithoutChapterInput, ChapterSnapshotUncheckedUpdateWithoutChapterInput>
  }

  export type ChapterSnapshotUpdateManyWithWhereWithoutChapterInput = {
    where: ChapterSnapshotScalarWhereInput
    data: XOR<ChapterSnapshotUpdateManyMutationInput, ChapterSnapshotUncheckedUpdateManyWithoutChapterInput>
  }

  export type ChapterChangeUpsertWithWhereUniqueWithoutChapterInput = {
    where: ChapterChangeWhereUniqueInput
    update: XOR<ChapterChangeUpdateWithoutChapterInput, ChapterChangeUncheckedUpdateWithoutChapterInput>
    create: XOR<ChapterChangeCreateWithoutChapterInput, ChapterChangeUncheckedCreateWithoutChapterInput>
  }

  export type ChapterChangeUpdateWithWhereUniqueWithoutChapterInput = {
    where: ChapterChangeWhereUniqueInput
    data: XOR<ChapterChangeUpdateWithoutChapterInput, ChapterChangeUncheckedUpdateWithoutChapterInput>
  }

  export type ChapterChangeUpdateManyWithWhereWithoutChapterInput = {
    where: ChapterChangeScalarWhereInput
    data: XOR<ChapterChangeUpdateManyMutationInput, ChapterChangeUncheckedUpdateManyWithoutChapterInput>
  }

  export type ChapterActivityUpsertWithWhereUniqueWithoutChapterInput = {
    where: ChapterActivityWhereUniqueInput
    update: XOR<ChapterActivityUpdateWithoutChapterInput, ChapterActivityUncheckedUpdateWithoutChapterInput>
    create: XOR<ChapterActivityCreateWithoutChapterInput, ChapterActivityUncheckedCreateWithoutChapterInput>
  }

  export type ChapterActivityUpdateWithWhereUniqueWithoutChapterInput = {
    where: ChapterActivityWhereUniqueInput
    data: XOR<ChapterActivityUpdateWithoutChapterInput, ChapterActivityUncheckedUpdateWithoutChapterInput>
  }

  export type ChapterActivityUpdateManyWithWhereWithoutChapterInput = {
    where: ChapterActivityScalarWhereInput
    data: XOR<ChapterActivityUpdateManyMutationInput, ChapterActivityUncheckedUpdateManyWithoutChapterInput>
  }

  export type ChapterRevisionRequestUpsertWithWhereUniqueWithoutChapterInput = {
    where: ChapterRevisionRequestWhereUniqueInput
    update: XOR<ChapterRevisionRequestUpdateWithoutChapterInput, ChapterRevisionRequestUncheckedUpdateWithoutChapterInput>
    create: XOR<ChapterRevisionRequestCreateWithoutChapterInput, ChapterRevisionRequestUncheckedCreateWithoutChapterInput>
  }

  export type ChapterRevisionRequestUpdateWithWhereUniqueWithoutChapterInput = {
    where: ChapterRevisionRequestWhereUniqueInput
    data: XOR<ChapterRevisionRequestUpdateWithoutChapterInput, ChapterRevisionRequestUncheckedUpdateWithoutChapterInput>
  }

  export type ChapterRevisionRequestUpdateManyWithWhereWithoutChapterInput = {
    where: ChapterRevisionRequestScalarWhereInput
    data: XOR<ChapterRevisionRequestUpdateManyMutationInput, ChapterRevisionRequestUncheckedUpdateManyWithoutChapterInput>
  }

  export type WorkCreateWithoutGlossaryInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWorksInput
    editor?: UserCreateNestedOneWithoutEditingWorksInput
    chapters?: ChapterCreateNestedManyWithoutWorkInput
    creators?: CreatorCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobCreateNestedManyWithoutWorkInput
    listings?: ProjectListingCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutGlossaryInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutWorkInput
    creators?: CreatorUncheckedCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleUncheckedCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput
    listings?: ProjectListingUncheckedCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractUncheckedCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutGlossaryInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutGlossaryInput, WorkUncheckedCreateWithoutGlossaryInput>
  }

  export type WorkUpsertWithoutGlossaryInput = {
    update: XOR<WorkUpdateWithoutGlossaryInput, WorkUncheckedUpdateWithoutGlossaryInput>
    create: XOR<WorkCreateWithoutGlossaryInput, WorkUncheckedCreateWithoutGlossaryInput>
    where?: WorkWhereInput
  }

  export type WorkUpdateToOneWithWhereWithoutGlossaryInput = {
    where?: WorkWhereInput
    data: XOR<WorkUpdateWithoutGlossaryInput, WorkUncheckedUpdateWithoutGlossaryInput>
  }

  export type WorkUpdateWithoutGlossaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWorksNestedInput
    editor?: UserUpdateOneWithoutEditingWorksNestedInput
    chapters?: ChapterUpdateManyWithoutWorkNestedInput
    creators?: CreatorUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutGlossaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutWorkNestedInput
    creators?: CreatorUncheckedUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUncheckedUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUncheckedUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUncheckedUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type WorkCreateWithoutSettingBibleInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWorksInput
    editor?: UserCreateNestedOneWithoutEditingWorksInput
    chapters?: ChapterCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemCreateNestedManyWithoutWorkInput
    creators?: CreatorCreateNestedManyWithoutWorkInput
    bibleJobs?: BibleGenerationJobCreateNestedManyWithoutWorkInput
    listings?: ProjectListingCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutSettingBibleInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemUncheckedCreateNestedManyWithoutWorkInput
    creators?: CreatorUncheckedCreateNestedManyWithoutWorkInput
    bibleJobs?: BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput
    listings?: ProjectListingUncheckedCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractUncheckedCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutSettingBibleInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutSettingBibleInput, WorkUncheckedCreateWithoutSettingBibleInput>
  }

  export type CharacterCreateWithoutBibleInput = {
    id?: string
    nameOriginal: string
    nameKorean: string
    nameHanja?: string | null
    titles?: CharacterCreatetitlesInput | string[]
    aliases?: CharacterCreatealiasesInput | string[]
    personality?: string | null
    speechStyle?: string | null
    role?: $Enums.CharacterRole
    description?: string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: number | null
    sortOrder?: number
    isConfirmed?: boolean
  }

  export type CharacterUncheckedCreateWithoutBibleInput = {
    id?: string
    nameOriginal: string
    nameKorean: string
    nameHanja?: string | null
    titles?: CharacterCreatetitlesInput | string[]
    aliases?: CharacterCreatealiasesInput | string[]
    personality?: string | null
    speechStyle?: string | null
    role?: $Enums.CharacterRole
    description?: string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: number | null
    sortOrder?: number
    isConfirmed?: boolean
  }

  export type CharacterCreateOrConnectWithoutBibleInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutBibleInput, CharacterUncheckedCreateWithoutBibleInput>
  }

  export type CharacterCreateManyBibleInputEnvelope = {
    data: CharacterCreateManyBibleInput | CharacterCreateManyBibleInput[]
    skipDuplicates?: boolean
  }

  export type SettingTermCreateWithoutBibleInput = {
    id?: string
    original: string
    translated: string
    category: $Enums.TermCategory
    note?: string | null
    context?: string | null
    firstAppearance?: number | null
    frequency?: number
    isConfirmed?: boolean
  }

  export type SettingTermUncheckedCreateWithoutBibleInput = {
    id?: string
    original: string
    translated: string
    category: $Enums.TermCategory
    note?: string | null
    context?: string | null
    firstAppearance?: number | null
    frequency?: number
    isConfirmed?: boolean
  }

  export type SettingTermCreateOrConnectWithoutBibleInput = {
    where: SettingTermWhereUniqueInput
    create: XOR<SettingTermCreateWithoutBibleInput, SettingTermUncheckedCreateWithoutBibleInput>
  }

  export type SettingTermCreateManyBibleInputEnvelope = {
    data: SettingTermCreateManyBibleInput | SettingTermCreateManyBibleInput[]
    skipDuplicates?: boolean
  }

  export type TimelineEventCreateWithoutBibleInput = {
    id?: string
    title: string
    description: string
    chapterStart: number
    chapterEnd?: number | null
    eventType?: $Enums.EventType
    importance?: number
    isForeshadowing?: boolean
    foreshadowNote?: string | null
    involvedCharacterIds?: TimelineEventCreateinvolvedCharacterIdsInput | string[]
  }

  export type TimelineEventUncheckedCreateWithoutBibleInput = {
    id?: string
    title: string
    description: string
    chapterStart: number
    chapterEnd?: number | null
    eventType?: $Enums.EventType
    importance?: number
    isForeshadowing?: boolean
    foreshadowNote?: string | null
    involvedCharacterIds?: TimelineEventCreateinvolvedCharacterIdsInput | string[]
  }

  export type TimelineEventCreateOrConnectWithoutBibleInput = {
    where: TimelineEventWhereUniqueInput
    create: XOR<TimelineEventCreateWithoutBibleInput, TimelineEventUncheckedCreateWithoutBibleInput>
  }

  export type TimelineEventCreateManyBibleInputEnvelope = {
    data: TimelineEventCreateManyBibleInput | TimelineEventCreateManyBibleInput[]
    skipDuplicates?: boolean
  }

  export type WorkUpsertWithoutSettingBibleInput = {
    update: XOR<WorkUpdateWithoutSettingBibleInput, WorkUncheckedUpdateWithoutSettingBibleInput>
    create: XOR<WorkCreateWithoutSettingBibleInput, WorkUncheckedCreateWithoutSettingBibleInput>
    where?: WorkWhereInput
  }

  export type WorkUpdateToOneWithWhereWithoutSettingBibleInput = {
    where?: WorkWhereInput
    data: XOR<WorkUpdateWithoutSettingBibleInput, WorkUncheckedUpdateWithoutSettingBibleInput>
  }

  export type WorkUpdateWithoutSettingBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWorksNestedInput
    editor?: UserUpdateOneWithoutEditingWorksNestedInput
    chapters?: ChapterUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUpdateManyWithoutWorkNestedInput
    creators?: CreatorUpdateManyWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutSettingBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput
    creators?: CreatorUncheckedUpdateManyWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUncheckedUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUncheckedUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type CharacterUpsertWithWhereUniqueWithoutBibleInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutBibleInput, CharacterUncheckedUpdateWithoutBibleInput>
    create: XOR<CharacterCreateWithoutBibleInput, CharacterUncheckedCreateWithoutBibleInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutBibleInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutBibleInput, CharacterUncheckedUpdateWithoutBibleInput>
  }

  export type CharacterUpdateManyWithWhereWithoutBibleInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutBibleInput>
  }

  export type CharacterScalarWhereInput = {
    AND?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    OR?: CharacterScalarWhereInput[]
    NOT?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    id?: StringFilter<"Character"> | string
    bibleId?: StringFilter<"Character"> | string
    nameOriginal?: StringFilter<"Character"> | string
    nameKorean?: StringFilter<"Character"> | string
    nameHanja?: StringNullableFilter<"Character"> | string | null
    titles?: StringNullableListFilter<"Character">
    aliases?: StringNullableListFilter<"Character">
    personality?: StringNullableFilter<"Character"> | string | null
    speechStyle?: StringNullableFilter<"Character"> | string | null
    role?: EnumCharacterRoleFilter<"Character"> | $Enums.CharacterRole
    description?: StringNullableFilter<"Character"> | string | null
    relationships?: JsonNullableFilter<"Character">
    firstAppearance?: IntNullableFilter<"Character"> | number | null
    sortOrder?: IntFilter<"Character"> | number
    isConfirmed?: BoolFilter<"Character"> | boolean
  }

  export type SettingTermUpsertWithWhereUniqueWithoutBibleInput = {
    where: SettingTermWhereUniqueInput
    update: XOR<SettingTermUpdateWithoutBibleInput, SettingTermUncheckedUpdateWithoutBibleInput>
    create: XOR<SettingTermCreateWithoutBibleInput, SettingTermUncheckedCreateWithoutBibleInput>
  }

  export type SettingTermUpdateWithWhereUniqueWithoutBibleInput = {
    where: SettingTermWhereUniqueInput
    data: XOR<SettingTermUpdateWithoutBibleInput, SettingTermUncheckedUpdateWithoutBibleInput>
  }

  export type SettingTermUpdateManyWithWhereWithoutBibleInput = {
    where: SettingTermScalarWhereInput
    data: XOR<SettingTermUpdateManyMutationInput, SettingTermUncheckedUpdateManyWithoutBibleInput>
  }

  export type SettingTermScalarWhereInput = {
    AND?: SettingTermScalarWhereInput | SettingTermScalarWhereInput[]
    OR?: SettingTermScalarWhereInput[]
    NOT?: SettingTermScalarWhereInput | SettingTermScalarWhereInput[]
    id?: StringFilter<"SettingTerm"> | string
    bibleId?: StringFilter<"SettingTerm"> | string
    original?: StringFilter<"SettingTerm"> | string
    translated?: StringFilter<"SettingTerm"> | string
    category?: EnumTermCategoryFilter<"SettingTerm"> | $Enums.TermCategory
    note?: StringNullableFilter<"SettingTerm"> | string | null
    context?: StringNullableFilter<"SettingTerm"> | string | null
    firstAppearance?: IntNullableFilter<"SettingTerm"> | number | null
    frequency?: IntFilter<"SettingTerm"> | number
    isConfirmed?: BoolFilter<"SettingTerm"> | boolean
  }

  export type TimelineEventUpsertWithWhereUniqueWithoutBibleInput = {
    where: TimelineEventWhereUniqueInput
    update: XOR<TimelineEventUpdateWithoutBibleInput, TimelineEventUncheckedUpdateWithoutBibleInput>
    create: XOR<TimelineEventCreateWithoutBibleInput, TimelineEventUncheckedCreateWithoutBibleInput>
  }

  export type TimelineEventUpdateWithWhereUniqueWithoutBibleInput = {
    where: TimelineEventWhereUniqueInput
    data: XOR<TimelineEventUpdateWithoutBibleInput, TimelineEventUncheckedUpdateWithoutBibleInput>
  }

  export type TimelineEventUpdateManyWithWhereWithoutBibleInput = {
    where: TimelineEventScalarWhereInput
    data: XOR<TimelineEventUpdateManyMutationInput, TimelineEventUncheckedUpdateManyWithoutBibleInput>
  }

  export type TimelineEventScalarWhereInput = {
    AND?: TimelineEventScalarWhereInput | TimelineEventScalarWhereInput[]
    OR?: TimelineEventScalarWhereInput[]
    NOT?: TimelineEventScalarWhereInput | TimelineEventScalarWhereInput[]
    id?: StringFilter<"TimelineEvent"> | string
    bibleId?: StringFilter<"TimelineEvent"> | string
    title?: StringFilter<"TimelineEvent"> | string
    description?: StringFilter<"TimelineEvent"> | string
    chapterStart?: IntFilter<"TimelineEvent"> | number
    chapterEnd?: IntNullableFilter<"TimelineEvent"> | number | null
    eventType?: EnumEventTypeFilter<"TimelineEvent"> | $Enums.EventType
    importance?: IntFilter<"TimelineEvent"> | number
    isForeshadowing?: BoolFilter<"TimelineEvent"> | boolean
    foreshadowNote?: StringNullableFilter<"TimelineEvent"> | string | null
    involvedCharacterIds?: StringNullableListFilter<"TimelineEvent">
  }

  export type SettingBibleCreateWithoutCharactersInput = {
    id?: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    work: WorkCreateNestedOneWithoutSettingBibleInput
    terms?: SettingTermCreateNestedManyWithoutBibleInput
    events?: TimelineEventCreateNestedManyWithoutBibleInput
  }

  export type SettingBibleUncheckedCreateWithoutCharactersInput = {
    id?: string
    workId: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    terms?: SettingTermUncheckedCreateNestedManyWithoutBibleInput
    events?: TimelineEventUncheckedCreateNestedManyWithoutBibleInput
  }

  export type SettingBibleCreateOrConnectWithoutCharactersInput = {
    where: SettingBibleWhereUniqueInput
    create: XOR<SettingBibleCreateWithoutCharactersInput, SettingBibleUncheckedCreateWithoutCharactersInput>
  }

  export type SettingBibleUpsertWithoutCharactersInput = {
    update: XOR<SettingBibleUpdateWithoutCharactersInput, SettingBibleUncheckedUpdateWithoutCharactersInput>
    create: XOR<SettingBibleCreateWithoutCharactersInput, SettingBibleUncheckedCreateWithoutCharactersInput>
    where?: SettingBibleWhereInput
  }

  export type SettingBibleUpdateToOneWithWhereWithoutCharactersInput = {
    where?: SettingBibleWhereInput
    data: XOR<SettingBibleUpdateWithoutCharactersInput, SettingBibleUncheckedUpdateWithoutCharactersInput>
  }

  export type SettingBibleUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    work?: WorkUpdateOneRequiredWithoutSettingBibleNestedInput
    terms?: SettingTermUpdateManyWithoutBibleNestedInput
    events?: TimelineEventUpdateManyWithoutBibleNestedInput
  }

  export type SettingBibleUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    terms?: SettingTermUncheckedUpdateManyWithoutBibleNestedInput
    events?: TimelineEventUncheckedUpdateManyWithoutBibleNestedInput
  }

  export type SettingBibleCreateWithoutTermsInput = {
    id?: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    work: WorkCreateNestedOneWithoutSettingBibleInput
    characters?: CharacterCreateNestedManyWithoutBibleInput
    events?: TimelineEventCreateNestedManyWithoutBibleInput
  }

  export type SettingBibleUncheckedCreateWithoutTermsInput = {
    id?: string
    workId: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutBibleInput
    events?: TimelineEventUncheckedCreateNestedManyWithoutBibleInput
  }

  export type SettingBibleCreateOrConnectWithoutTermsInput = {
    where: SettingBibleWhereUniqueInput
    create: XOR<SettingBibleCreateWithoutTermsInput, SettingBibleUncheckedCreateWithoutTermsInput>
  }

  export type SettingBibleUpsertWithoutTermsInput = {
    update: XOR<SettingBibleUpdateWithoutTermsInput, SettingBibleUncheckedUpdateWithoutTermsInput>
    create: XOR<SettingBibleCreateWithoutTermsInput, SettingBibleUncheckedCreateWithoutTermsInput>
    where?: SettingBibleWhereInput
  }

  export type SettingBibleUpdateToOneWithWhereWithoutTermsInput = {
    where?: SettingBibleWhereInput
    data: XOR<SettingBibleUpdateWithoutTermsInput, SettingBibleUncheckedUpdateWithoutTermsInput>
  }

  export type SettingBibleUpdateWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    work?: WorkUpdateOneRequiredWithoutSettingBibleNestedInput
    characters?: CharacterUpdateManyWithoutBibleNestedInput
    events?: TimelineEventUpdateManyWithoutBibleNestedInput
  }

  export type SettingBibleUncheckedUpdateWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutBibleNestedInput
    events?: TimelineEventUncheckedUpdateManyWithoutBibleNestedInput
  }

  export type SettingBibleCreateWithoutEventsInput = {
    id?: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    work: WorkCreateNestedOneWithoutSettingBibleInput
    characters?: CharacterCreateNestedManyWithoutBibleInput
    terms?: SettingTermCreateNestedManyWithoutBibleInput
  }

  export type SettingBibleUncheckedCreateWithoutEventsInput = {
    id?: string
    workId: string
    status?: $Enums.BibleStatus
    version?: number
    translationGuide?: string | null
    analyzedChapters?: number
    generatedAt?: Date | string | null
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutBibleInput
    terms?: SettingTermUncheckedCreateNestedManyWithoutBibleInput
  }

  export type SettingBibleCreateOrConnectWithoutEventsInput = {
    where: SettingBibleWhereUniqueInput
    create: XOR<SettingBibleCreateWithoutEventsInput, SettingBibleUncheckedCreateWithoutEventsInput>
  }

  export type SettingBibleUpsertWithoutEventsInput = {
    update: XOR<SettingBibleUpdateWithoutEventsInput, SettingBibleUncheckedUpdateWithoutEventsInput>
    create: XOR<SettingBibleCreateWithoutEventsInput, SettingBibleUncheckedCreateWithoutEventsInput>
    where?: SettingBibleWhereInput
  }

  export type SettingBibleUpdateToOneWithWhereWithoutEventsInput = {
    where?: SettingBibleWhereInput
    data: XOR<SettingBibleUpdateWithoutEventsInput, SettingBibleUncheckedUpdateWithoutEventsInput>
  }

  export type SettingBibleUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    work?: WorkUpdateOneRequiredWithoutSettingBibleNestedInput
    characters?: CharacterUpdateManyWithoutBibleNestedInput
    terms?: SettingTermUpdateManyWithoutBibleNestedInput
  }

  export type SettingBibleUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleStatusFieldUpdateOperationsInput | $Enums.BibleStatus
    version?: IntFieldUpdateOperationsInput | number
    translationGuide?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutBibleNestedInput
    terms?: SettingTermUncheckedUpdateManyWithoutBibleNestedInput
  }

  export type WorkCreateWithoutBibleJobsInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWorksInput
    editor?: UserCreateNestedOneWithoutEditingWorksInput
    chapters?: ChapterCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemCreateNestedManyWithoutWorkInput
    creators?: CreatorCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleCreateNestedOneWithoutWorkInput
    listings?: ProjectListingCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutBibleJobsInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemUncheckedCreateNestedManyWithoutWorkInput
    creators?: CreatorUncheckedCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleUncheckedCreateNestedOneWithoutWorkInput
    listings?: ProjectListingUncheckedCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractUncheckedCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutBibleJobsInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutBibleJobsInput, WorkUncheckedCreateWithoutBibleJobsInput>
  }

  export type WorkUpsertWithoutBibleJobsInput = {
    update: XOR<WorkUpdateWithoutBibleJobsInput, WorkUncheckedUpdateWithoutBibleJobsInput>
    create: XOR<WorkCreateWithoutBibleJobsInput, WorkUncheckedCreateWithoutBibleJobsInput>
    where?: WorkWhereInput
  }

  export type WorkUpdateToOneWithWhereWithoutBibleJobsInput = {
    where?: WorkWhereInput
    data: XOR<WorkUpdateWithoutBibleJobsInput, WorkUncheckedUpdateWithoutBibleJobsInput>
  }

  export type WorkUpdateWithoutBibleJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWorksNestedInput
    editor?: UserUpdateOneWithoutEditingWorksNestedInput
    chapters?: ChapterUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUpdateManyWithoutWorkNestedInput
    creators?: CreatorUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUpdateOneWithoutWorkNestedInput
    listings?: ProjectListingUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutBibleJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput
    creators?: CreatorUncheckedUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUncheckedUpdateOneWithoutWorkNestedInput
    listings?: ProjectListingUncheckedUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUncheckedUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type ChapterCreateWithoutCommentsInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastEditedBy?: UserCreateNestedOneWithoutLastEditedChaptersInput
    work: WorkCreateNestedOneWithoutChaptersInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutCommentsInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: string | null
    lastEditedAt?: Date | string | null
    workId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutCommentsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type ChapterCommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    parent?: ChapterCommentCreateNestedOneWithoutRepliesInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
  }

  export type ChapterCommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    chapterId: string
    authorId: string
    parentId?: string | null
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterCommentCreateOrConnectWithoutRepliesInput = {
    where: ChapterCommentWhereUniqueInput
    create: XOR<ChapterCommentCreateWithoutRepliesInput, ChapterCommentUncheckedCreateWithoutRepliesInput>
  }

  export type ChapterCommentCreateWithoutParentInput = {
    id?: string
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    replies?: ChapterCommentCreateNestedManyWithoutParentInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
  }

  export type ChapterCommentUncheckedCreateWithoutParentInput = {
    id?: string
    chapterId: string
    authorId: string
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ChapterCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ChapterCommentCreateOrConnectWithoutParentInput = {
    where: ChapterCommentWhereUniqueInput
    create: XOR<ChapterCommentCreateWithoutParentInput, ChapterCommentUncheckedCreateWithoutParentInput>
  }

  export type ChapterCommentCreateManyParentInputEnvelope = {
    data: ChapterCommentCreateManyParentInput | ChapterCommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutResolvedCommentsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutResolvedCommentsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutResolvedCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResolvedCommentsInput, UserUncheckedCreateWithoutResolvedCommentsInput>
  }

  export type ChapterUpsertWithoutCommentsInput = {
    update: XOR<ChapterUpdateWithoutCommentsInput, ChapterUncheckedUpdateWithoutCommentsInput>
    create: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutCommentsInput, ChapterUncheckedUpdateWithoutCommentsInput>
  }

  export type ChapterUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditedBy?: UserUpdateOneWithoutLastEditedChaptersNestedInput
    work?: WorkUpdateOneRequiredWithoutChaptersNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ChapterCommentUpsertWithoutRepliesInput = {
    update: XOR<ChapterCommentUpdateWithoutRepliesInput, ChapterCommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<ChapterCommentCreateWithoutRepliesInput, ChapterCommentUncheckedCreateWithoutRepliesInput>
    where?: ChapterCommentWhereInput
  }

  export type ChapterCommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: ChapterCommentWhereInput
    data: XOR<ChapterCommentUpdateWithoutRepliesInput, ChapterCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type ChapterCommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: ChapterCommentUpdateOneWithoutRepliesNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
  }

  export type ChapterCommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCommentUpsertWithWhereUniqueWithoutParentInput = {
    where: ChapterCommentWhereUniqueInput
    update: XOR<ChapterCommentUpdateWithoutParentInput, ChapterCommentUncheckedUpdateWithoutParentInput>
    create: XOR<ChapterCommentCreateWithoutParentInput, ChapterCommentUncheckedCreateWithoutParentInput>
  }

  export type ChapterCommentUpdateWithWhereUniqueWithoutParentInput = {
    where: ChapterCommentWhereUniqueInput
    data: XOR<ChapterCommentUpdateWithoutParentInput, ChapterCommentUncheckedUpdateWithoutParentInput>
  }

  export type ChapterCommentUpdateManyWithWhereWithoutParentInput = {
    where: ChapterCommentScalarWhereInput
    data: XOR<ChapterCommentUpdateManyMutationInput, ChapterCommentUncheckedUpdateManyWithoutParentInput>
  }

  export type UserUpsertWithoutResolvedCommentsInput = {
    update: XOR<UserUpdateWithoutResolvedCommentsInput, UserUncheckedUpdateWithoutResolvedCommentsInput>
    create: XOR<UserCreateWithoutResolvedCommentsInput, UserUncheckedCreateWithoutResolvedCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResolvedCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResolvedCommentsInput, UserUncheckedUpdateWithoutResolvedCommentsInput>
  }

  export type UserUpdateWithoutResolvedCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutResolvedCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ChapterCreateWithoutSnapshotsInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastEditedBy?: UserCreateNestedOneWithoutLastEditedChaptersInput
    work: WorkCreateNestedOneWithoutChaptersInput
    comments?: ChapterCommentCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: string | null
    lastEditedAt?: Date | string | null
    workId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutSnapshotsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutSnapshotsInput, ChapterUncheckedCreateWithoutSnapshotsInput>
  }

  export type UserCreateWithoutSnapshotsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSnapshotsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSnapshotsInput, UserUncheckedCreateWithoutSnapshotsInput>
  }

  export type ChapterUpsertWithoutSnapshotsInput = {
    update: XOR<ChapterUpdateWithoutSnapshotsInput, ChapterUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<ChapterCreateWithoutSnapshotsInput, ChapterUncheckedCreateWithoutSnapshotsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutSnapshotsInput, ChapterUncheckedUpdateWithoutSnapshotsInput>
  }

  export type ChapterUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditedBy?: UserUpdateOneWithoutLastEditedChaptersNestedInput
    work?: WorkUpdateOneRequiredWithoutChaptersNestedInput
    comments?: ChapterCommentUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ChapterCommentUncheckedUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UserUpsertWithoutSnapshotsInput = {
    update: XOR<UserUpdateWithoutSnapshotsInput, UserUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<UserCreateWithoutSnapshotsInput, UserUncheckedCreateWithoutSnapshotsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSnapshotsInput, UserUncheckedUpdateWithoutSnapshotsInput>
  }

  export type UserUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ChapterCreateWithoutChangesInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastEditedBy?: UserCreateNestedOneWithoutLastEditedChaptersInput
    work: WorkCreateNestedOneWithoutChaptersInput
    comments?: ChapterCommentCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutChangesInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: string | null
    lastEditedAt?: Date | string | null
    workId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutChangesInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutChangesInput, ChapterUncheckedCreateWithoutChangesInput>
  }

  export type UserCreateWithoutChangesInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutChangesInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChangesInput, UserUncheckedCreateWithoutChangesInput>
  }

  export type UserCreateWithoutReviewedChangesInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutReviewedChangesInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutReviewedChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedChangesInput, UserUncheckedCreateWithoutReviewedChangesInput>
  }

  export type ChapterUpsertWithoutChangesInput = {
    update: XOR<ChapterUpdateWithoutChangesInput, ChapterUncheckedUpdateWithoutChangesInput>
    create: XOR<ChapterCreateWithoutChangesInput, ChapterUncheckedCreateWithoutChangesInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutChangesInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutChangesInput, ChapterUncheckedUpdateWithoutChangesInput>
  }

  export type ChapterUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditedBy?: UserUpdateOneWithoutLastEditedChaptersNestedInput
    work?: WorkUpdateOneRequiredWithoutChaptersNestedInput
    comments?: ChapterCommentUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ChapterCommentUncheckedUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UserUpsertWithoutChangesInput = {
    update: XOR<UserUpdateWithoutChangesInput, UserUncheckedUpdateWithoutChangesInput>
    create: XOR<UserCreateWithoutChangesInput, UserUncheckedCreateWithoutChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChangesInput, UserUncheckedUpdateWithoutChangesInput>
  }

  export type UserUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUpsertWithoutReviewedChangesInput = {
    update: XOR<UserUpdateWithoutReviewedChangesInput, UserUncheckedUpdateWithoutReviewedChangesInput>
    create: XOR<UserCreateWithoutReviewedChangesInput, UserUncheckedCreateWithoutReviewedChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedChangesInput, UserUncheckedUpdateWithoutReviewedChangesInput>
  }

  export type UserUpdateWithoutReviewedChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ChapterCreateWithoutActivitiesInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastEditedBy?: UserCreateNestedOneWithoutLastEditedChaptersInput
    work: WorkCreateNestedOneWithoutChaptersInput
    comments?: ChapterCommentCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutActivitiesInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: string | null
    lastEditedAt?: Date | string | null
    workId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutChapterInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutActivitiesInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutActivitiesInput, ChapterUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type ChapterUpsertWithoutActivitiesInput = {
    update: XOR<ChapterUpdateWithoutActivitiesInput, ChapterUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ChapterCreateWithoutActivitiesInput, ChapterUncheckedCreateWithoutActivitiesInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutActivitiesInput, ChapterUncheckedUpdateWithoutActivitiesInput>
  }

  export type ChapterUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditedBy?: UserUpdateOneWithoutLastEditedChaptersNestedInput
    work?: WorkUpdateOneRequiredWithoutChaptersNestedInput
    comments?: ChapterCommentUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ChapterCommentUncheckedUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutEditorProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutEditorProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutEditorProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEditorProfileInput, UserUncheckedCreateWithoutEditorProfileInput>
  }

  export type PortfolioItemCreateWithoutProfileInput = {
    id?: string
    title: string
    description?: string | null
    genre?: string | null
    sampleText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type PortfolioItemUncheckedCreateWithoutProfileInput = {
    id?: string
    title: string
    description?: string | null
    genre?: string | null
    sampleText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type PortfolioItemCreateOrConnectWithoutProfileInput = {
    where: PortfolioItemWhereUniqueInput
    create: XOR<PortfolioItemCreateWithoutProfileInput, PortfolioItemUncheckedCreateWithoutProfileInput>
  }

  export type PortfolioItemCreateManyProfileInputEnvelope = {
    data: PortfolioItemCreateManyProfileInput | PortfolioItemCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProjectApplicationCreateWithoutEditorProfileInput = {
    id?: string
    proposalMessage: string
    priceQuote?: number | null
    estimatedDays?: number | null
    status?: $Enums.ApplicationStatus
    authorNote?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    listing: ProjectListingCreateNestedOneWithoutApplicationsInput
  }

  export type ProjectApplicationUncheckedCreateWithoutEditorProfileInput = {
    id?: string
    listingId: string
    proposalMessage: string
    priceQuote?: number | null
    estimatedDays?: number | null
    status?: $Enums.ApplicationStatus
    authorNote?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type ProjectApplicationCreateOrConnectWithoutEditorProfileInput = {
    where: ProjectApplicationWhereUniqueInput
    create: XOR<ProjectApplicationCreateWithoutEditorProfileInput, ProjectApplicationUncheckedCreateWithoutEditorProfileInput>
  }

  export type ProjectApplicationCreateManyEditorProfileInputEnvelope = {
    data: ProjectApplicationCreateManyEditorProfileInput | ProjectApplicationCreateManyEditorProfileInput[]
    skipDuplicates?: boolean
  }

  export type EditorReviewCreateWithoutEditorProfileInput = {
    id?: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutAuthorReviewsInput
    work: WorkCreateNestedOneWithoutReviewsInput
  }

  export type EditorReviewUncheckedCreateWithoutEditorProfileInput = {
    id?: string
    authorId: string
    workId: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type EditorReviewCreateOrConnectWithoutEditorProfileInput = {
    where: EditorReviewWhereUniqueInput
    create: XOR<EditorReviewCreateWithoutEditorProfileInput, EditorReviewUncheckedCreateWithoutEditorProfileInput>
  }

  export type EditorReviewCreateManyEditorProfileInputEnvelope = {
    data: EditorReviewCreateManyEditorProfileInput | EditorReviewCreateManyEditorProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEditorProfileInput = {
    update: XOR<UserUpdateWithoutEditorProfileInput, UserUncheckedUpdateWithoutEditorProfileInput>
    create: XOR<UserCreateWithoutEditorProfileInput, UserUncheckedCreateWithoutEditorProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEditorProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEditorProfileInput, UserUncheckedUpdateWithoutEditorProfileInput>
  }

  export type UserUpdateWithoutEditorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutEditorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type PortfolioItemUpsertWithWhereUniqueWithoutProfileInput = {
    where: PortfolioItemWhereUniqueInput
    update: XOR<PortfolioItemUpdateWithoutProfileInput, PortfolioItemUncheckedUpdateWithoutProfileInput>
    create: XOR<PortfolioItemCreateWithoutProfileInput, PortfolioItemUncheckedCreateWithoutProfileInput>
  }

  export type PortfolioItemUpdateWithWhereUniqueWithoutProfileInput = {
    where: PortfolioItemWhereUniqueInput
    data: XOR<PortfolioItemUpdateWithoutProfileInput, PortfolioItemUncheckedUpdateWithoutProfileInput>
  }

  export type PortfolioItemUpdateManyWithWhereWithoutProfileInput = {
    where: PortfolioItemScalarWhereInput
    data: XOR<PortfolioItemUpdateManyMutationInput, PortfolioItemUncheckedUpdateManyWithoutProfileInput>
  }

  export type PortfolioItemScalarWhereInput = {
    AND?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
    OR?: PortfolioItemScalarWhereInput[]
    NOT?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
    id?: StringFilter<"PortfolioItem"> | string
    profileId?: StringFilter<"PortfolioItem"> | string
    title?: StringFilter<"PortfolioItem"> | string
    description?: StringNullableFilter<"PortfolioItem"> | string | null
    genre?: StringNullableFilter<"PortfolioItem"> | string | null
    sampleText?: StringNullableFilter<"PortfolioItem"> | string | null
    sortOrder?: IntFilter<"PortfolioItem"> | number
    createdAt?: DateTimeFilter<"PortfolioItem"> | Date | string
  }

  export type ProjectApplicationUpsertWithWhereUniqueWithoutEditorProfileInput = {
    where: ProjectApplicationWhereUniqueInput
    update: XOR<ProjectApplicationUpdateWithoutEditorProfileInput, ProjectApplicationUncheckedUpdateWithoutEditorProfileInput>
    create: XOR<ProjectApplicationCreateWithoutEditorProfileInput, ProjectApplicationUncheckedCreateWithoutEditorProfileInput>
  }

  export type ProjectApplicationUpdateWithWhereUniqueWithoutEditorProfileInput = {
    where: ProjectApplicationWhereUniqueInput
    data: XOR<ProjectApplicationUpdateWithoutEditorProfileInput, ProjectApplicationUncheckedUpdateWithoutEditorProfileInput>
  }

  export type ProjectApplicationUpdateManyWithWhereWithoutEditorProfileInput = {
    where: ProjectApplicationScalarWhereInput
    data: XOR<ProjectApplicationUpdateManyMutationInput, ProjectApplicationUncheckedUpdateManyWithoutEditorProfileInput>
  }

  export type ProjectApplicationScalarWhereInput = {
    AND?: ProjectApplicationScalarWhereInput | ProjectApplicationScalarWhereInput[]
    OR?: ProjectApplicationScalarWhereInput[]
    NOT?: ProjectApplicationScalarWhereInput | ProjectApplicationScalarWhereInput[]
    id?: StringFilter<"ProjectApplication"> | string
    listingId?: StringFilter<"ProjectApplication"> | string
    editorProfileId?: StringFilter<"ProjectApplication"> | string
    proposalMessage?: StringFilter<"ProjectApplication"> | string
    priceQuote?: IntNullableFilter<"ProjectApplication"> | number | null
    estimatedDays?: IntNullableFilter<"ProjectApplication"> | number | null
    status?: EnumApplicationStatusFilter<"ProjectApplication"> | $Enums.ApplicationStatus
    authorNote?: StringNullableFilter<"ProjectApplication"> | string | null
    submittedAt?: DateTimeFilter<"ProjectApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"ProjectApplication"> | Date | string | null
  }

  export type EditorReviewUpsertWithWhereUniqueWithoutEditorProfileInput = {
    where: EditorReviewWhereUniqueInput
    update: XOR<EditorReviewUpdateWithoutEditorProfileInput, EditorReviewUncheckedUpdateWithoutEditorProfileInput>
    create: XOR<EditorReviewCreateWithoutEditorProfileInput, EditorReviewUncheckedCreateWithoutEditorProfileInput>
  }

  export type EditorReviewUpdateWithWhereUniqueWithoutEditorProfileInput = {
    where: EditorReviewWhereUniqueInput
    data: XOR<EditorReviewUpdateWithoutEditorProfileInput, EditorReviewUncheckedUpdateWithoutEditorProfileInput>
  }

  export type EditorReviewUpdateManyWithWhereWithoutEditorProfileInput = {
    where: EditorReviewScalarWhereInput
    data: XOR<EditorReviewUpdateManyMutationInput, EditorReviewUncheckedUpdateManyWithoutEditorProfileInput>
  }

  export type EditorProfileCreateWithoutPortfolioItemsInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEditorProfileInput
    applications?: ProjectApplicationCreateNestedManyWithoutEditorProfileInput
    reviews?: EditorReviewCreateNestedManyWithoutEditorProfileInput
  }

  export type EditorProfileUncheckedCreateWithoutPortfolioItemsInput = {
    id?: string
    userId: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ProjectApplicationUncheckedCreateNestedManyWithoutEditorProfileInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutEditorProfileInput
  }

  export type EditorProfileCreateOrConnectWithoutPortfolioItemsInput = {
    where: EditorProfileWhereUniqueInput
    create: XOR<EditorProfileCreateWithoutPortfolioItemsInput, EditorProfileUncheckedCreateWithoutPortfolioItemsInput>
  }

  export type EditorProfileUpsertWithoutPortfolioItemsInput = {
    update: XOR<EditorProfileUpdateWithoutPortfolioItemsInput, EditorProfileUncheckedUpdateWithoutPortfolioItemsInput>
    create: XOR<EditorProfileCreateWithoutPortfolioItemsInput, EditorProfileUncheckedCreateWithoutPortfolioItemsInput>
    where?: EditorProfileWhereInput
  }

  export type EditorProfileUpdateToOneWithWhereWithoutPortfolioItemsInput = {
    where?: EditorProfileWhereInput
    data: XOR<EditorProfileUpdateWithoutPortfolioItemsInput, EditorProfileUncheckedUpdateWithoutPortfolioItemsInput>
  }

  export type EditorProfileUpdateWithoutPortfolioItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEditorProfileNestedInput
    applications?: ProjectApplicationUpdateManyWithoutEditorProfileNestedInput
    reviews?: EditorReviewUpdateManyWithoutEditorProfileNestedInput
  }

  export type EditorProfileUncheckedUpdateWithoutPortfolioItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ProjectApplicationUncheckedUpdateManyWithoutEditorProfileNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutEditorProfileNestedInput
  }

  export type WorkCreateWithoutListingsInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWorksInput
    editor?: UserCreateNestedOneWithoutEditingWorksInput
    chapters?: ChapterCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemCreateNestedManyWithoutWorkInput
    creators?: CreatorCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutListingsInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemUncheckedCreateNestedManyWithoutWorkInput
    creators?: CreatorUncheckedCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleUncheckedCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractUncheckedCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutListingsInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutListingsInput, WorkUncheckedCreateWithoutListingsInput>
  }

  export type UserCreateWithoutAuthorListingsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAuthorListingsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAuthorListingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthorListingsInput, UserUncheckedCreateWithoutAuthorListingsInput>
  }

  export type ProjectApplicationCreateWithoutListingInput = {
    id?: string
    proposalMessage: string
    priceQuote?: number | null
    estimatedDays?: number | null
    status?: $Enums.ApplicationStatus
    authorNote?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    editorProfile: EditorProfileCreateNestedOneWithoutApplicationsInput
  }

  export type ProjectApplicationUncheckedCreateWithoutListingInput = {
    id?: string
    editorProfileId: string
    proposalMessage: string
    priceQuote?: number | null
    estimatedDays?: number | null
    status?: $Enums.ApplicationStatus
    authorNote?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type ProjectApplicationCreateOrConnectWithoutListingInput = {
    where: ProjectApplicationWhereUniqueInput
    create: XOR<ProjectApplicationCreateWithoutListingInput, ProjectApplicationUncheckedCreateWithoutListingInput>
  }

  export type ProjectApplicationCreateManyListingInputEnvelope = {
    data: ProjectApplicationCreateManyListingInput | ProjectApplicationCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type ProjectContractCreateWithoutListingInput = {
    id?: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    work: WorkCreateNestedOneWithoutContractsInput
    author: UserCreateNestedOneWithoutAuthorContractsInput
    editor: UserCreateNestedOneWithoutEditorContractsInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutContractInput
  }

  export type ProjectContractUncheckedCreateWithoutListingInput = {
    id?: string
    workId: string
    authorId: string
    editorId: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutContractInput
  }

  export type ProjectContractCreateOrConnectWithoutListingInput = {
    where: ProjectContractWhereUniqueInput
    create: XOR<ProjectContractCreateWithoutListingInput, ProjectContractUncheckedCreateWithoutListingInput>
  }

  export type WorkUpsertWithoutListingsInput = {
    update: XOR<WorkUpdateWithoutListingsInput, WorkUncheckedUpdateWithoutListingsInput>
    create: XOR<WorkCreateWithoutListingsInput, WorkUncheckedCreateWithoutListingsInput>
    where?: WorkWhereInput
  }

  export type WorkUpdateToOneWithWhereWithoutListingsInput = {
    where?: WorkWhereInput
    data: XOR<WorkUpdateWithoutListingsInput, WorkUncheckedUpdateWithoutListingsInput>
  }

  export type WorkUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWorksNestedInput
    editor?: UserUpdateOneWithoutEditingWorksNestedInput
    chapters?: ChapterUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUpdateManyWithoutWorkNestedInput
    creators?: CreatorUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput
    creators?: CreatorUncheckedUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUncheckedUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUncheckedUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type UserUpsertWithoutAuthorListingsInput = {
    update: XOR<UserUpdateWithoutAuthorListingsInput, UserUncheckedUpdateWithoutAuthorListingsInput>
    create: XOR<UserCreateWithoutAuthorListingsInput, UserUncheckedCreateWithoutAuthorListingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthorListingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthorListingsInput, UserUncheckedUpdateWithoutAuthorListingsInput>
  }

  export type UserUpdateWithoutAuthorListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthorListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ProjectApplicationUpsertWithWhereUniqueWithoutListingInput = {
    where: ProjectApplicationWhereUniqueInput
    update: XOR<ProjectApplicationUpdateWithoutListingInput, ProjectApplicationUncheckedUpdateWithoutListingInput>
    create: XOR<ProjectApplicationCreateWithoutListingInput, ProjectApplicationUncheckedCreateWithoutListingInput>
  }

  export type ProjectApplicationUpdateWithWhereUniqueWithoutListingInput = {
    where: ProjectApplicationWhereUniqueInput
    data: XOR<ProjectApplicationUpdateWithoutListingInput, ProjectApplicationUncheckedUpdateWithoutListingInput>
  }

  export type ProjectApplicationUpdateManyWithWhereWithoutListingInput = {
    where: ProjectApplicationScalarWhereInput
    data: XOR<ProjectApplicationUpdateManyMutationInput, ProjectApplicationUncheckedUpdateManyWithoutListingInput>
  }

  export type ProjectContractUpsertWithoutListingInput = {
    update: XOR<ProjectContractUpdateWithoutListingInput, ProjectContractUncheckedUpdateWithoutListingInput>
    create: XOR<ProjectContractCreateWithoutListingInput, ProjectContractUncheckedCreateWithoutListingInput>
    where?: ProjectContractWhereInput
  }

  export type ProjectContractUpdateToOneWithWhereWithoutListingInput = {
    where?: ProjectContractWhereInput
    data: XOR<ProjectContractUpdateWithoutListingInput, ProjectContractUncheckedUpdateWithoutListingInput>
  }

  export type ProjectContractUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    work?: WorkUpdateOneRequiredWithoutContractsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthorContractsNestedInput
    editor?: UserUpdateOneRequiredWithoutEditorContractsNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutContractNestedInput
  }

  export type ProjectContractUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ProjectListingCreateWithoutApplicationsInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    work: WorkCreateNestedOneWithoutListingsInput
    author: UserCreateNestedOneWithoutAuthorListingsInput
    contract?: ProjectContractCreateNestedOneWithoutListingInput
  }

  export type ProjectListingUncheckedCreateWithoutApplicationsInput = {
    id?: string
    workId: string
    authorId: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ProjectContractUncheckedCreateNestedOneWithoutListingInput
  }

  export type ProjectListingCreateOrConnectWithoutApplicationsInput = {
    where: ProjectListingWhereUniqueInput
    create: XOR<ProjectListingCreateWithoutApplicationsInput, ProjectListingUncheckedCreateWithoutApplicationsInput>
  }

  export type EditorProfileCreateWithoutApplicationsInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEditorProfileInput
    portfolioItems?: PortfolioItemCreateNestedManyWithoutProfileInput
    reviews?: EditorReviewCreateNestedManyWithoutEditorProfileInput
  }

  export type EditorProfileUncheckedCreateWithoutApplicationsInput = {
    id?: string
    userId: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioItems?: PortfolioItemUncheckedCreateNestedManyWithoutProfileInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutEditorProfileInput
  }

  export type EditorProfileCreateOrConnectWithoutApplicationsInput = {
    where: EditorProfileWhereUniqueInput
    create: XOR<EditorProfileCreateWithoutApplicationsInput, EditorProfileUncheckedCreateWithoutApplicationsInput>
  }

  export type ProjectListingUpsertWithoutApplicationsInput = {
    update: XOR<ProjectListingUpdateWithoutApplicationsInput, ProjectListingUncheckedUpdateWithoutApplicationsInput>
    create: XOR<ProjectListingCreateWithoutApplicationsInput, ProjectListingUncheckedCreateWithoutApplicationsInput>
    where?: ProjectListingWhereInput
  }

  export type ProjectListingUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: ProjectListingWhereInput
    data: XOR<ProjectListingUpdateWithoutApplicationsInput, ProjectListingUncheckedUpdateWithoutApplicationsInput>
  }

  export type ProjectListingUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    work?: WorkUpdateOneRequiredWithoutListingsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthorListingsNestedInput
    contract?: ProjectContractUpdateOneWithoutListingNestedInput
  }

  export type ProjectListingUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ProjectContractUncheckedUpdateOneWithoutListingNestedInput
  }

  export type EditorProfileUpsertWithoutApplicationsInput = {
    update: XOR<EditorProfileUpdateWithoutApplicationsInput, EditorProfileUncheckedUpdateWithoutApplicationsInput>
    create: XOR<EditorProfileCreateWithoutApplicationsInput, EditorProfileUncheckedCreateWithoutApplicationsInput>
    where?: EditorProfileWhereInput
  }

  export type EditorProfileUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: EditorProfileWhereInput
    data: XOR<EditorProfileUpdateWithoutApplicationsInput, EditorProfileUncheckedUpdateWithoutApplicationsInput>
  }

  export type EditorProfileUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEditorProfileNestedInput
    portfolioItems?: PortfolioItemUpdateManyWithoutProfileNestedInput
    reviews?: EditorReviewUpdateManyWithoutEditorProfileNestedInput
  }

  export type EditorProfileUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioItems?: PortfolioItemUncheckedUpdateManyWithoutProfileNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutEditorProfileNestedInput
  }

  export type ProjectListingCreateWithoutContractInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    work: WorkCreateNestedOneWithoutListingsInput
    author: UserCreateNestedOneWithoutAuthorListingsInput
    applications?: ProjectApplicationCreateNestedManyWithoutListingInput
  }

  export type ProjectListingUncheckedCreateWithoutContractInput = {
    id?: string
    workId: string
    authorId: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ProjectApplicationUncheckedCreateNestedManyWithoutListingInput
  }

  export type ProjectListingCreateOrConnectWithoutContractInput = {
    where: ProjectListingWhereUniqueInput
    create: XOR<ProjectListingCreateWithoutContractInput, ProjectListingUncheckedCreateWithoutContractInput>
  }

  export type WorkCreateWithoutContractsInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWorksInput
    editor?: UserCreateNestedOneWithoutEditingWorksInput
    chapters?: ChapterCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemCreateNestedManyWithoutWorkInput
    creators?: CreatorCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobCreateNestedManyWithoutWorkInput
    listings?: ProjectListingCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutContractsInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemUncheckedCreateNestedManyWithoutWorkInput
    creators?: CreatorUncheckedCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleUncheckedCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput
    listings?: ProjectListingUncheckedCreateNestedManyWithoutWorkInput
    reviews?: EditorReviewUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutContractsInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutContractsInput, WorkUncheckedCreateWithoutContractsInput>
  }

  export type UserCreateWithoutAuthorContractsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAuthorContractsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAuthorContractsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthorContractsInput, UserUncheckedCreateWithoutAuthorContractsInput>
  }

  export type UserCreateWithoutEditorContractsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutEditorContractsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutEditorContractsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEditorContractsInput, UserUncheckedCreateWithoutEditorContractsInput>
  }

  export type ChapterRevisionRequestCreateWithoutContractInput = {
    id?: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
    chapter: ChapterCreateNestedOneWithoutRevisionRequestsInput
    requestedBy: UserCreateNestedOneWithoutRevisionRequestsInput
  }

  export type ChapterRevisionRequestUncheckedCreateWithoutContractInput = {
    id?: string
    chapterId: string
    requestedById: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
  }

  export type ChapterRevisionRequestCreateOrConnectWithoutContractInput = {
    where: ChapterRevisionRequestWhereUniqueInput
    create: XOR<ChapterRevisionRequestCreateWithoutContractInput, ChapterRevisionRequestUncheckedCreateWithoutContractInput>
  }

  export type ChapterRevisionRequestCreateManyContractInputEnvelope = {
    data: ChapterRevisionRequestCreateManyContractInput | ChapterRevisionRequestCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type ProjectListingUpsertWithoutContractInput = {
    update: XOR<ProjectListingUpdateWithoutContractInput, ProjectListingUncheckedUpdateWithoutContractInput>
    create: XOR<ProjectListingCreateWithoutContractInput, ProjectListingUncheckedCreateWithoutContractInput>
    where?: ProjectListingWhereInput
  }

  export type ProjectListingUpdateToOneWithWhereWithoutContractInput = {
    where?: ProjectListingWhereInput
    data: XOR<ProjectListingUpdateWithoutContractInput, ProjectListingUncheckedUpdateWithoutContractInput>
  }

  export type ProjectListingUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    work?: WorkUpdateOneRequiredWithoutListingsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthorListingsNestedInput
    applications?: ProjectApplicationUpdateManyWithoutListingNestedInput
  }

  export type ProjectListingUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ProjectApplicationUncheckedUpdateManyWithoutListingNestedInput
  }

  export type WorkUpsertWithoutContractsInput = {
    update: XOR<WorkUpdateWithoutContractsInput, WorkUncheckedUpdateWithoutContractsInput>
    create: XOR<WorkCreateWithoutContractsInput, WorkUncheckedCreateWithoutContractsInput>
    where?: WorkWhereInput
  }

  export type WorkUpdateToOneWithWhereWithoutContractsInput = {
    where?: WorkWhereInput
    data: XOR<WorkUpdateWithoutContractsInput, WorkUncheckedUpdateWithoutContractsInput>
  }

  export type WorkUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWorksNestedInput
    editor?: UserUpdateOneWithoutEditingWorksNestedInput
    chapters?: ChapterUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUpdateManyWithoutWorkNestedInput
    creators?: CreatorUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput
    creators?: CreatorUncheckedUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUncheckedUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUncheckedUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type UserUpsertWithoutAuthorContractsInput = {
    update: XOR<UserUpdateWithoutAuthorContractsInput, UserUncheckedUpdateWithoutAuthorContractsInput>
    create: XOR<UserCreateWithoutAuthorContractsInput, UserUncheckedCreateWithoutAuthorContractsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthorContractsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthorContractsInput, UserUncheckedUpdateWithoutAuthorContractsInput>
  }

  export type UserUpdateWithoutAuthorContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthorContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUpsertWithoutEditorContractsInput = {
    update: XOR<UserUpdateWithoutEditorContractsInput, UserUncheckedUpdateWithoutEditorContractsInput>
    create: XOR<UserCreateWithoutEditorContractsInput, UserUncheckedCreateWithoutEditorContractsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEditorContractsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEditorContractsInput, UserUncheckedUpdateWithoutEditorContractsInput>
  }

  export type UserUpdateWithoutEditorContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutEditorContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ChapterRevisionRequestUpsertWithWhereUniqueWithoutContractInput = {
    where: ChapterRevisionRequestWhereUniqueInput
    update: XOR<ChapterRevisionRequestUpdateWithoutContractInput, ChapterRevisionRequestUncheckedUpdateWithoutContractInput>
    create: XOR<ChapterRevisionRequestCreateWithoutContractInput, ChapterRevisionRequestUncheckedCreateWithoutContractInput>
  }

  export type ChapterRevisionRequestUpdateWithWhereUniqueWithoutContractInput = {
    where: ChapterRevisionRequestWhereUniqueInput
    data: XOR<ChapterRevisionRequestUpdateWithoutContractInput, ChapterRevisionRequestUncheckedUpdateWithoutContractInput>
  }

  export type ChapterRevisionRequestUpdateManyWithWhereWithoutContractInput = {
    where: ChapterRevisionRequestScalarWhereInput
    data: XOR<ChapterRevisionRequestUpdateManyMutationInput, ChapterRevisionRequestUncheckedUpdateManyWithoutContractInput>
  }

  export type ProjectContractCreateWithoutRevisionRequestsInput = {
    id?: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
    listing: ProjectListingCreateNestedOneWithoutContractInput
    work: WorkCreateNestedOneWithoutContractsInput
    author: UserCreateNestedOneWithoutAuthorContractsInput
    editor: UserCreateNestedOneWithoutEditorContractsInput
  }

  export type ProjectContractUncheckedCreateWithoutRevisionRequestsInput = {
    id?: string
    listingId: string
    workId: string
    authorId: string
    editorId: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ProjectContractCreateOrConnectWithoutRevisionRequestsInput = {
    where: ProjectContractWhereUniqueInput
    create: XOR<ProjectContractCreateWithoutRevisionRequestsInput, ProjectContractUncheckedCreateWithoutRevisionRequestsInput>
  }

  export type ChapterCreateWithoutRevisionRequestsInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastEditedBy?: UserCreateNestedOneWithoutLastEditedChaptersInput
    work: WorkCreateNestedOneWithoutChaptersInput
    comments?: ChapterCommentCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutRevisionRequestsInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: string | null
    lastEditedAt?: Date | string | null
    workId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutChapterInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutChapterInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutChapterInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutRevisionRequestsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutRevisionRequestsInput, ChapterUncheckedCreateWithoutRevisionRequestsInput>
  }

  export type UserCreateWithoutRevisionRequestsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    authorReviews?: EditorReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutRevisionRequestsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    authorReviews?: EditorReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutRevisionRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRevisionRequestsInput, UserUncheckedCreateWithoutRevisionRequestsInput>
  }

  export type ProjectContractUpsertWithoutRevisionRequestsInput = {
    update: XOR<ProjectContractUpdateWithoutRevisionRequestsInput, ProjectContractUncheckedUpdateWithoutRevisionRequestsInput>
    create: XOR<ProjectContractCreateWithoutRevisionRequestsInput, ProjectContractUncheckedCreateWithoutRevisionRequestsInput>
    where?: ProjectContractWhereInput
  }

  export type ProjectContractUpdateToOneWithWhereWithoutRevisionRequestsInput = {
    where?: ProjectContractWhereInput
    data: XOR<ProjectContractUpdateWithoutRevisionRequestsInput, ProjectContractUncheckedUpdateWithoutRevisionRequestsInput>
  }

  export type ProjectContractUpdateWithoutRevisionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ProjectListingUpdateOneRequiredWithoutContractNestedInput
    work?: WorkUpdateOneRequiredWithoutContractsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthorContractsNestedInput
    editor?: UserUpdateOneRequiredWithoutEditorContractsNestedInput
  }

  export type ProjectContractUncheckedUpdateWithoutRevisionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUpsertWithoutRevisionRequestsInput = {
    update: XOR<ChapterUpdateWithoutRevisionRequestsInput, ChapterUncheckedUpdateWithoutRevisionRequestsInput>
    create: XOR<ChapterCreateWithoutRevisionRequestsInput, ChapterUncheckedCreateWithoutRevisionRequestsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutRevisionRequestsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutRevisionRequestsInput, ChapterUncheckedUpdateWithoutRevisionRequestsInput>
  }

  export type ChapterUpdateWithoutRevisionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditedBy?: UserUpdateOneWithoutLastEditedChaptersNestedInput
    work?: WorkUpdateOneRequiredWithoutChaptersNestedInput
    comments?: ChapterCommentUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutRevisionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ChapterCommentUncheckedUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UserUpsertWithoutRevisionRequestsInput = {
    update: XOR<UserUpdateWithoutRevisionRequestsInput, UserUncheckedUpdateWithoutRevisionRequestsInput>
    create: XOR<UserCreateWithoutRevisionRequestsInput, UserUncheckedCreateWithoutRevisionRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRevisionRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRevisionRequestsInput, UserUncheckedUpdateWithoutRevisionRequestsInput>
  }

  export type UserUpdateWithoutRevisionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    authorReviews?: EditorReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutRevisionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    authorReviews?: EditorReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type EditorProfileCreateWithoutReviewsInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEditorProfileInput
    portfolioItems?: PortfolioItemCreateNestedManyWithoutProfileInput
    applications?: ProjectApplicationCreateNestedManyWithoutEditorProfileInput
  }

  export type EditorProfileUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    displayName?: string | null
    bio?: string | null
    portfolioUrl?: string | null
    specialtyGenres?: EditorProfileCreatespecialtyGenresInput | string[]
    languages?: EditorProfileCreatelanguagesInput | string[]
    availability?: $Enums.EditorAvailability
    maxConcurrent?: number
    completedProjects?: number
    averageRating?: number | null
    totalReviews?: number
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioItems?: PortfolioItemUncheckedCreateNestedManyWithoutProfileInput
    applications?: ProjectApplicationUncheckedCreateNestedManyWithoutEditorProfileInput
  }

  export type EditorProfileCreateOrConnectWithoutReviewsInput = {
    where: EditorProfileWhereUniqueInput
    create: XOR<EditorProfileCreateWithoutReviewsInput, EditorProfileUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutAuthorReviewsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkCreateNestedManyWithoutEditorInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutAuthorReviewsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    role?: $Enums.UserRole
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: WorkUncheckedCreateNestedManyWithoutAuthorInput
    editingWorks?: WorkUncheckedCreateNestedManyWithoutEditorInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    lastEditedChapters?: ChapterUncheckedCreateNestedManyWithoutLastEditedByInput
    comments?: ChapterCommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: ChapterCommentUncheckedCreateNestedManyWithoutResolvedByInput
    snapshots?: ChapterSnapshotUncheckedCreateNestedManyWithoutAuthorInput
    changes?: ChapterChangeUncheckedCreateNestedManyWithoutAuthorInput
    reviewedChanges?: ChapterChangeUncheckedCreateNestedManyWithoutReviewedByInput
    activities?: ChapterActivityUncheckedCreateNestedManyWithoutActorInput
    editorProfile?: EditorProfileUncheckedCreateNestedOneWithoutUserInput
    authorListings?: ProjectListingUncheckedCreateNestedManyWithoutAuthorInput
    authorContracts?: ProjectContractUncheckedCreateNestedManyWithoutAuthorInput
    editorContracts?: ProjectContractUncheckedCreateNestedManyWithoutEditorInput
    revisionRequests?: ChapterRevisionRequestUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutAuthorReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthorReviewsInput, UserUncheckedCreateWithoutAuthorReviewsInput>
  }

  export type WorkCreateWithoutReviewsInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutWorksInput
    editor?: UserCreateNestedOneWithoutEditingWorksInput
    chapters?: ChapterCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemCreateNestedManyWithoutWorkInput
    creators?: CreatorCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobCreateNestedManyWithoutWorkInput
    listings?: ProjectListingCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutReviewsInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutWorkInput
    glossary?: GlossaryItemUncheckedCreateNestedManyWithoutWorkInput
    creators?: CreatorUncheckedCreateNestedManyWithoutWorkInput
    settingBible?: SettingBibleUncheckedCreateNestedOneWithoutWorkInput
    bibleJobs?: BibleGenerationJobUncheckedCreateNestedManyWithoutWorkInput
    listings?: ProjectListingUncheckedCreateNestedManyWithoutWorkInput
    contracts?: ProjectContractUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutReviewsInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutReviewsInput, WorkUncheckedCreateWithoutReviewsInput>
  }

  export type EditorProfileUpsertWithoutReviewsInput = {
    update: XOR<EditorProfileUpdateWithoutReviewsInput, EditorProfileUncheckedUpdateWithoutReviewsInput>
    create: XOR<EditorProfileCreateWithoutReviewsInput, EditorProfileUncheckedCreateWithoutReviewsInput>
    where?: EditorProfileWhereInput
  }

  export type EditorProfileUpdateToOneWithWhereWithoutReviewsInput = {
    where?: EditorProfileWhereInput
    data: XOR<EditorProfileUpdateWithoutReviewsInput, EditorProfileUncheckedUpdateWithoutReviewsInput>
  }

  export type EditorProfileUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEditorProfileNestedInput
    portfolioItems?: PortfolioItemUpdateManyWithoutProfileNestedInput
    applications?: ProjectApplicationUpdateManyWithoutEditorProfileNestedInput
  }

  export type EditorProfileUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyGenres?: EditorProfileUpdatespecialtyGenresInput | string[]
    languages?: EditorProfileUpdatelanguagesInput | string[]
    availability?: EnumEditorAvailabilityFieldUpdateOperationsInput | $Enums.EditorAvailability
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    completedProjects?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioItems?: PortfolioItemUncheckedUpdateManyWithoutProfileNestedInput
    applications?: ProjectApplicationUncheckedUpdateManyWithoutEditorProfileNestedInput
  }

  export type UserUpsertWithoutAuthorReviewsInput = {
    update: XOR<UserUpdateWithoutAuthorReviewsInput, UserUncheckedUpdateWithoutAuthorReviewsInput>
    create: XOR<UserCreateWithoutAuthorReviewsInput, UserUncheckedCreateWithoutAuthorReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthorReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthorReviewsInput, UserUncheckedUpdateWithoutAuthorReviewsInput>
  }

  export type UserUpdateWithoutAuthorReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUpdateManyWithoutEditorNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthorReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: WorkUncheckedUpdateManyWithoutAuthorNestedInput
    editingWorks?: WorkUncheckedUpdateManyWithoutEditorNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    lastEditedChapters?: ChapterUncheckedUpdateManyWithoutLastEditedByNestedInput
    comments?: ChapterCommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: ChapterCommentUncheckedUpdateManyWithoutResolvedByNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutAuthorNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutAuthorNestedInput
    reviewedChanges?: ChapterChangeUncheckedUpdateManyWithoutReviewedByNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutActorNestedInput
    editorProfile?: EditorProfileUncheckedUpdateOneWithoutUserNestedInput
    authorListings?: ProjectListingUncheckedUpdateManyWithoutAuthorNestedInput
    authorContracts?: ProjectContractUncheckedUpdateManyWithoutAuthorNestedInput
    editorContracts?: ProjectContractUncheckedUpdateManyWithoutEditorNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type WorkUpsertWithoutReviewsInput = {
    update: XOR<WorkUpdateWithoutReviewsInput, WorkUncheckedUpdateWithoutReviewsInput>
    create: XOR<WorkCreateWithoutReviewsInput, WorkUncheckedCreateWithoutReviewsInput>
    where?: WorkWhereInput
  }

  export type WorkUpdateToOneWithWhereWithoutReviewsInput = {
    where?: WorkWhereInput
    data: XOR<WorkUpdateWithoutReviewsInput, WorkUncheckedUpdateWithoutReviewsInput>
  }

  export type WorkUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWorksNestedInput
    editor?: UserUpdateOneWithoutEditingWorksNestedInput
    chapters?: ChapterUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUpdateManyWithoutWorkNestedInput
    creators?: CreatorUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput
    creators?: CreatorUncheckedUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUncheckedUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUncheckedUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type WorkCreateManyAuthorInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    editorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkCreateManyEditorInput = {
    id?: string
    titleKo: string
    titleOriginal: string
    publisher: string
    ageRating?: $Enums.AgeRating
    status?: $Enums.WorkStatus
    coverImage?: string | null
    synopsis: string
    genres?: WorkCreategenresInput | string[]
    originalStatus?: $Enums.OriginalStatus
    sourceLanguage?: $Enums.SourceLanguage
    expectedChapters?: number | null
    platformName?: string | null
    platformUrl?: string | null
    publishedAt?: Date | string | null
    totalChapters?: number
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type ChapterCreateManyLastEditedByInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: Date | string | null
    workId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterCommentCreateManyAuthorInput = {
    id?: string
    chapterId: string
    parentId?: string | null
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterCommentCreateManyResolvedByInput = {
    id?: string
    chapterId: string
    authorId: string
    parentId?: string | null
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterSnapshotCreateManyAuthorInput = {
    id?: string
    chapterId: string
    name?: string | null
    description?: string | null
    snapshotType?: $Enums.SnapshotType
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status: $Enums.ChapterStatus
    triggerEvent?: string | null
    createdAt?: Date | string
  }

  export type ChapterChangeCreateManyAuthorInput = {
    id?: string
    chapterId: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChapterChangeCreateManyReviewedByInput = {
    id?: string
    chapterId: string
    authorId: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChapterActivityCreateManyActorInput = {
    id?: string
    chapterId: string
    activityType: $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary: string
    createdAt?: Date | string
  }

  export type ProjectListingCreateManyAuthorInput = {
    id?: string
    workId: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectContractCreateManyAuthorInput = {
    id?: string
    listingId: string
    workId: string
    editorId: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ProjectContractCreateManyEditorInput = {
    id?: string
    listingId: string
    workId: string
    authorId: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ChapterRevisionRequestCreateManyRequestedByInput = {
    id?: string
    contractId: string
    chapterId: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
  }

  export type EditorReviewCreateManyAuthorInput = {
    id?: string
    editorProfileId: string
    workId: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type WorkUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editor?: UserUpdateOneWithoutEditingWorksNestedInput
    chapters?: ChapterUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUpdateManyWithoutWorkNestedInput
    creators?: CreatorUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput
    creators?: CreatorUncheckedUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUncheckedUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUncheckedUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUncheckedUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkUpdateWithoutEditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutWorksNestedInput
    chapters?: ChapterUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUpdateManyWithoutWorkNestedInput
    creators?: CreatorUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutEditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutWorkNestedInput
    glossary?: GlossaryItemUncheckedUpdateManyWithoutWorkNestedInput
    creators?: CreatorUncheckedUpdateManyWithoutWorkNestedInput
    settingBible?: SettingBibleUncheckedUpdateOneWithoutWorkNestedInput
    bibleJobs?: BibleGenerationJobUncheckedUpdateManyWithoutWorkNestedInput
    listings?: ProjectListingUncheckedUpdateManyWithoutWorkNestedInput
    contracts?: ProjectContractUncheckedUpdateManyWithoutWorkNestedInput
    reviews?: EditorReviewUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateManyWithoutEditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleKo?: StringFieldUpdateOperationsInput | string
    titleOriginal?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    status?: EnumWorkStatusFieldUpdateOperationsInput | $Enums.WorkStatus
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    synopsis?: StringFieldUpdateOperationsInput | string
    genres?: WorkUpdategenresInput | string[]
    originalStatus?: EnumOriginalStatusFieldUpdateOperationsInput | $Enums.OriginalStatus
    sourceLanguage?: EnumSourceLanguageFieldUpdateOperationsInput | $Enums.SourceLanguage
    expectedChapters?: NullableIntFieldUpdateOperationsInput | number | null
    platformName?: NullableStringFieldUpdateOperationsInput | string | null
    platformUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalChapters?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUpdateWithoutLastEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    work?: WorkUpdateOneRequiredWithoutChaptersNestedInput
    comments?: ChapterCommentUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutLastEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ChapterCommentUncheckedUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateManyWithoutLastEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutCommentsNestedInput
    parent?: ChapterCommentUpdateOneWithoutRepliesNestedInput
    replies?: ChapterCommentUpdateManyWithoutParentNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
  }

  export type ChapterCommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ChapterCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ChapterCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCommentUpdateWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: ChapterCommentUpdateOneWithoutRepliesNestedInput
    replies?: ChapterCommentUpdateManyWithoutParentNestedInput
  }

  export type ChapterCommentUncheckedUpdateWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ChapterCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ChapterCommentUncheckedUpdateManyWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterSnapshotUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    triggerEvent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type ChapterSnapshotUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    triggerEvent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterSnapshotUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    triggerEvent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChangeUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutChangesNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedChangesNestedInput
  }

  export type ChapterChangeUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChangeUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChangeUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutChangesNestedInput
    author?: UserUpdateOneRequiredWithoutChangesNestedInput
  }

  export type ChapterChangeUncheckedUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChangeUncheckedUpdateManyWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterActivityUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ChapterActivityUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterActivityUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectListingUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    work?: WorkUpdateOneRequiredWithoutListingsNestedInput
    applications?: ProjectApplicationUpdateManyWithoutListingNestedInput
    contract?: ProjectContractUpdateOneWithoutListingNestedInput
  }

  export type ProjectListingUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ProjectApplicationUncheckedUpdateManyWithoutListingNestedInput
    contract?: ProjectContractUncheckedUpdateOneWithoutListingNestedInput
  }

  export type ProjectListingUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectContractUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ProjectListingUpdateOneRequiredWithoutContractNestedInput
    work?: WorkUpdateOneRequiredWithoutContractsNestedInput
    editor?: UserUpdateOneRequiredWithoutEditorContractsNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutContractNestedInput
  }

  export type ProjectContractUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ProjectContractUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectContractUpdateWithoutEditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ProjectListingUpdateOneRequiredWithoutContractNestedInput
    work?: WorkUpdateOneRequiredWithoutContractsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthorContractsNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutContractNestedInput
  }

  export type ProjectContractUncheckedUpdateWithoutEditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ProjectContractUncheckedUpdateManyWithoutEditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterRevisionRequestUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
    contract?: ProjectContractUpdateOneRequiredWithoutRevisionRequestsNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutRevisionRequestsNestedInput
  }

  export type ChapterRevisionRequestUncheckedUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
  }

  export type ChapterRevisionRequestUncheckedUpdateManyWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
  }

  export type EditorReviewUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editorProfile?: EditorProfileUpdateOneRequiredWithoutReviewsNestedInput
    work?: WorkUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type EditorReviewUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    editorProfileId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditorReviewUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    editorProfileId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateManyWorkInput = {
    id?: string
    number: number
    title?: string | null
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status?: $Enums.ChapterStatus
    wordCount?: number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: string | null
    lastEditedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlossaryItemCreateManyWorkInput = {
    id?: string
    original: string
    translated: string
    category?: string | null
    note?: string | null
  }

  export type CreatorCreateManyWorkInput = {
    id?: string
    name: string
    role: string
  }

  export type BibleGenerationJobCreateManyWorkInput = {
    id?: string
    userId: string
    status?: $Enums.BibleJobStatus
    batchPlan: JsonNullValueInput | InputJsonValue
    totalBatches: number
    currentBatchIndex?: number
    analyzedChapters?: number
    retryCount?: number
    maxRetries?: number
    errorMessage?: string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    lockedAt?: Date | string | null
    lockedBy?: string | null
  }

  export type ProjectListingCreateManyWorkInput = {
    id?: string
    authorId: string
    title: string
    description: string
    requirements?: string | null
    status?: $Enums.ProjectListingStatus
    budgetMin?: number | null
    budgetMax?: number | null
    deadline?: Date | string | null
    chapterStart?: number | null
    chapterEnd?: number | null
    viewCount?: number
    applicationCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectContractCreateManyWorkInput = {
    id?: string
    listingId: string
    authorId: string
    editorId: string
    totalAmount?: number | null
    startDate: Date | string
    expectedEndDate?: Date | string | null
    chapterStart: number
    chapterEnd?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type EditorReviewCreateManyWorkInput = {
    id?: string
    editorProfileId: string
    authorId: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type ChapterUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEditedBy?: UserUpdateOneWithoutLastEditedChaptersNestedInput
    comments?: ChapterCommentUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ChapterCommentUncheckedUpdateManyWithoutChapterNestedInput
    snapshots?: ChapterSnapshotUncheckedUpdateManyWithoutChapterNestedInput
    changes?: ChapterChangeUncheckedUpdateManyWithoutChapterNestedInput
    activities?: ChapterActivityUncheckedUpdateManyWithoutChapterNestedInput
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateManyWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    wordCount?: IntFieldUpdateOperationsInput | number
    translationMeta?: NullableJsonNullValueInput | InputJsonValue
    trackChangesState?: NullableJsonNullValueInput | InputJsonValue
    lastEditedById?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlossaryItemUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GlossaryItemUncheckedUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GlossaryItemUncheckedUpdateManyWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatorUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type CreatorUncheckedUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type CreatorUncheckedUpdateManyWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type BibleGenerationJobUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleJobStatusFieldUpdateOperationsInput | $Enums.BibleJobStatus
    batchPlan?: JsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BibleGenerationJobUncheckedUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleJobStatusFieldUpdateOperationsInput | $Enums.BibleJobStatus
    batchPlan?: JsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BibleGenerationJobUncheckedUpdateManyWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBibleJobStatusFieldUpdateOperationsInput | $Enums.BibleJobStatus
    batchPlan?: JsonNullValueInput | InputJsonValue
    totalBatches?: IntFieldUpdateOperationsInput | number
    currentBatchIndex?: IntFieldUpdateOperationsInput | number
    analyzedChapters?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectListingUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAuthorListingsNestedInput
    applications?: ProjectApplicationUpdateManyWithoutListingNestedInput
    contract?: ProjectContractUpdateOneWithoutListingNestedInput
  }

  export type ProjectListingUncheckedUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ProjectApplicationUncheckedUpdateManyWithoutListingNestedInput
    contract?: ProjectContractUncheckedUpdateOneWithoutListingNestedInput
  }

  export type ProjectListingUncheckedUpdateManyWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectListingStatusFieldUpdateOperationsInput | $Enums.ProjectListingStatus
    budgetMin?: NullableIntFieldUpdateOperationsInput | number | null
    budgetMax?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: NullableIntFieldUpdateOperationsInput | number | null
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    applicationCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectContractUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ProjectListingUpdateOneRequiredWithoutContractNestedInput
    author?: UserUpdateOneRequiredWithoutAuthorContractsNestedInput
    editor?: UserUpdateOneRequiredWithoutEditorContractsNestedInput
    revisionRequests?: ChapterRevisionRequestUpdateManyWithoutContractNestedInput
  }

  export type ProjectContractUncheckedUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisionRequests?: ChapterRevisionRequestUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ProjectContractUncheckedUpdateManyWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditorReviewUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editorProfile?: EditorProfileUpdateOneRequiredWithoutReviewsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthorReviewsNestedInput
  }

  export type EditorReviewUncheckedUpdateWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    editorProfileId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditorReviewUncheckedUpdateManyWithoutWorkInput = {
    id?: StringFieldUpdateOperationsInput | string
    editorProfileId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCommentCreateManyChapterInput = {
    id?: string
    authorId: string
    parentId?: string | null
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterSnapshotCreateManyChapterInput = {
    id?: string
    authorId: string
    name?: string | null
    description?: string | null
    snapshotType?: $Enums.SnapshotType
    originalContent: string
    translatedContent?: string | null
    editedContent?: string | null
    status: $Enums.ChapterStatus
    triggerEvent?: string | null
    createdAt?: Date | string
  }

  export type ChapterChangeCreateManyChapterInput = {
    id?: string
    authorId: string
    changeType: $Enums.ChangeType
    fromPos: number
    toPos: number
    oldText?: string | null
    newText?: string | null
    status?: $Enums.ChangeStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChapterActivityCreateManyChapterInput = {
    id?: string
    actorId: string
    activityType: $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary: string
    createdAt?: Date | string
  }

  export type ChapterRevisionRequestCreateManyChapterInput = {
    id?: string
    contractId: string
    requestedById: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
  }

  export type ChapterCommentUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: ChapterCommentUpdateOneWithoutRepliesNestedInput
    replies?: ChapterCommentUpdateManyWithoutParentNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
  }

  export type ChapterCommentUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ChapterCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ChapterCommentUncheckedUpdateManyWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterSnapshotUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    triggerEvent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type ChapterSnapshotUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    triggerEvent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterSnapshotUncheckedUpdateManyWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    originalContent?: StringFieldUpdateOperationsInput | string
    translatedContent?: NullableStringFieldUpdateOperationsInput | string | null
    editedContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    triggerEvent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChangeUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutChangesNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedChangesNestedInput
  }

  export type ChapterChangeUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChangeUncheckedUpdateManyWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    fromPos?: IntFieldUpdateOperationsInput | number
    toPos?: IntFieldUpdateOperationsInput | number
    oldText?: NullableStringFieldUpdateOperationsInput | string | null
    newText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterActivityUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ChapterActivityUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterActivityUncheckedUpdateManyWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    activityType?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterRevisionRequestUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
    contract?: ProjectContractUpdateOneRequiredWithoutRevisionRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRevisionRequestsNestedInput
  }

  export type ChapterRevisionRequestUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
  }

  export type ChapterRevisionRequestUncheckedUpdateManyWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterCreateManyBibleInput = {
    id?: string
    nameOriginal: string
    nameKorean: string
    nameHanja?: string | null
    titles?: CharacterCreatetitlesInput | string[]
    aliases?: CharacterCreatealiasesInput | string[]
    personality?: string | null
    speechStyle?: string | null
    role?: $Enums.CharacterRole
    description?: string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: number | null
    sortOrder?: number
    isConfirmed?: boolean
  }

  export type SettingTermCreateManyBibleInput = {
    id?: string
    original: string
    translated: string
    category: $Enums.TermCategory
    note?: string | null
    context?: string | null
    firstAppearance?: number | null
    frequency?: number
    isConfirmed?: boolean
  }

  export type TimelineEventCreateManyBibleInput = {
    id?: string
    title: string
    description: string
    chapterStart: number
    chapterEnd?: number | null
    eventType?: $Enums.EventType
    importance?: number
    isForeshadowing?: boolean
    foreshadowNote?: string | null
    involvedCharacterIds?: TimelineEventCreateinvolvedCharacterIdsInput | string[]
  }

  export type CharacterUpdateWithoutBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameOriginal?: StringFieldUpdateOperationsInput | string
    nameKorean?: StringFieldUpdateOperationsInput | string
    nameHanja?: NullableStringFieldUpdateOperationsInput | string | null
    titles?: CharacterUpdatetitlesInput | string[]
    aliases?: CharacterUpdatealiasesInput | string[]
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    speechStyle?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumCharacterRoleFieldUpdateOperationsInput | $Enums.CharacterRole
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CharacterUncheckedUpdateWithoutBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameOriginal?: StringFieldUpdateOperationsInput | string
    nameKorean?: StringFieldUpdateOperationsInput | string
    nameHanja?: NullableStringFieldUpdateOperationsInput | string | null
    titles?: CharacterUpdatetitlesInput | string[]
    aliases?: CharacterUpdatealiasesInput | string[]
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    speechStyle?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumCharacterRoleFieldUpdateOperationsInput | $Enums.CharacterRole
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CharacterUncheckedUpdateManyWithoutBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameOriginal?: StringFieldUpdateOperationsInput | string
    nameKorean?: StringFieldUpdateOperationsInput | string
    nameHanja?: NullableStringFieldUpdateOperationsInput | string | null
    titles?: CharacterUpdatetitlesInput | string[]
    aliases?: CharacterUpdatealiasesInput | string[]
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    speechStyle?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumCharacterRoleFieldUpdateOperationsInput | $Enums.CharacterRole
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relationships?: NullableJsonNullValueInput | InputJsonValue
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingTermUpdateWithoutBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: EnumTermCategoryFieldUpdateOperationsInput | $Enums.TermCategory
    note?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingTermUncheckedUpdateWithoutBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: EnumTermCategoryFieldUpdateOperationsInput | $Enums.TermCategory
    note?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingTermUncheckedUpdateManyWithoutBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    translated?: StringFieldUpdateOperationsInput | string
    category?: EnumTermCategoryFieldUpdateOperationsInput | $Enums.TermCategory
    note?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    firstAppearance?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TimelineEventUpdateWithoutBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    importance?: IntFieldUpdateOperationsInput | number
    isForeshadowing?: BoolFieldUpdateOperationsInput | boolean
    foreshadowNote?: NullableStringFieldUpdateOperationsInput | string | null
    involvedCharacterIds?: TimelineEventUpdateinvolvedCharacterIdsInput | string[]
  }

  export type TimelineEventUncheckedUpdateWithoutBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    importance?: IntFieldUpdateOperationsInput | number
    isForeshadowing?: BoolFieldUpdateOperationsInput | boolean
    foreshadowNote?: NullableStringFieldUpdateOperationsInput | string | null
    involvedCharacterIds?: TimelineEventUpdateinvolvedCharacterIdsInput | string[]
  }

  export type TimelineEventUncheckedUpdateManyWithoutBibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    chapterStart?: IntFieldUpdateOperationsInput | number
    chapterEnd?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    importance?: IntFieldUpdateOperationsInput | number
    isForeshadowing?: BoolFieldUpdateOperationsInput | boolean
    foreshadowNote?: NullableStringFieldUpdateOperationsInput | string | null
    involvedCharacterIds?: TimelineEventUpdateinvolvedCharacterIdsInput | string[]
  }

  export type ChapterCommentCreateManyParentInput = {
    id?: string
    chapterId: string
    authorId: string
    content: string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterCommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    replies?: ChapterCommentUpdateManyWithoutParentNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
  }

  export type ChapterCommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ChapterCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ChapterCommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textRange?: NullableJsonNullValueInput | InputJsonValue
    quotedText?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemCreateManyProfileInput = {
    id?: string
    title: string
    description?: string | null
    genre?: string | null
    sampleText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ProjectApplicationCreateManyEditorProfileInput = {
    id?: string
    listingId: string
    proposalMessage: string
    priceQuote?: number | null
    estimatedDays?: number | null
    status?: $Enums.ApplicationStatus
    authorNote?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type EditorReviewCreateManyEditorProfileInput = {
    id?: string
    authorId: string
    workId: string
    overallRating: number
    qualityRating?: number | null
    speedRating?: number | null
    communicationRating?: number | null
    content?: string | null
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type PortfolioItemUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    sampleText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    sampleText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioItemUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    sampleText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectApplicationUpdateWithoutEditorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalMessage?: StringFieldUpdateOperationsInput | string
    priceQuote?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    authorNote?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ProjectListingUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type ProjectApplicationUncheckedUpdateWithoutEditorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    proposalMessage?: StringFieldUpdateOperationsInput | string
    priceQuote?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    authorNote?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectApplicationUncheckedUpdateManyWithoutEditorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    proposalMessage?: StringFieldUpdateOperationsInput | string
    priceQuote?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    authorNote?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EditorReviewUpdateWithoutEditorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAuthorReviewsNestedInput
    work?: WorkUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type EditorReviewUncheckedUpdateWithoutEditorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditorReviewUncheckedUpdateManyWithoutEditorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    speedRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectApplicationCreateManyListingInput = {
    id?: string
    editorProfileId: string
    proposalMessage: string
    priceQuote?: number | null
    estimatedDays?: number | null
    status?: $Enums.ApplicationStatus
    authorNote?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type ProjectApplicationUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalMessage?: StringFieldUpdateOperationsInput | string
    priceQuote?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    authorNote?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editorProfile?: EditorProfileUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type ProjectApplicationUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    editorProfileId?: StringFieldUpdateOperationsInput | string
    proposalMessage?: StringFieldUpdateOperationsInput | string
    priceQuote?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    authorNote?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectApplicationUncheckedUpdateManyWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    editorProfileId?: StringFieldUpdateOperationsInput | string
    proposalMessage?: StringFieldUpdateOperationsInput | string
    priceQuote?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    authorNote?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChapterRevisionRequestCreateManyContractInput = {
    id?: string
    chapterId: string
    requestedById: string
    reason: string
    specificFeedback?: string | null
    status?: $Enums.RevisionRequestStatus
    response?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    revisionCount?: number
  }

  export type ChapterRevisionRequestUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
    chapter?: ChapterUpdateOneRequiredWithoutRevisionRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRevisionRequestsNestedInput
  }

  export type ChapterRevisionRequestUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
  }

  export type ChapterRevisionRequestUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    specificFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRevisionRequestStatusFieldUpdateOperationsInput | $Enums.RevisionRequestStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisionCount?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkCountOutputTypeDefaultArgs instead
     */
    export type WorkCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChapterCountOutputTypeDefaultArgs instead
     */
    export type ChapterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChapterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingBibleCountOutputTypeDefaultArgs instead
     */
    export type SettingBibleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingBibleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChapterCommentCountOutputTypeDefaultArgs instead
     */
    export type ChapterCommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChapterCommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EditorProfileCountOutputTypeDefaultArgs instead
     */
    export type EditorProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EditorProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectListingCountOutputTypeDefaultArgs instead
     */
    export type ProjectListingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectListingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectContractCountOutputTypeDefaultArgs instead
     */
    export type ProjectContractCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectContractCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkDefaultArgs instead
     */
    export type WorkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreatorDefaultArgs instead
     */
    export type CreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChapterDefaultArgs instead
     */
    export type ChapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChapterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GlossaryItemDefaultArgs instead
     */
    export type GlossaryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GlossaryItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranslationLogDefaultArgs instead
     */
    export type TranslationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranslationLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActiveTranslationJobDefaultArgs instead
     */
    export type ActiveTranslationJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActiveTranslationJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranslationJobHistoryDefaultArgs instead
     */
    export type TranslationJobHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranslationJobHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingBibleDefaultArgs instead
     */
    export type SettingBibleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingBibleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterDefaultArgs instead
     */
    export type CharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingTermDefaultArgs instead
     */
    export type SettingTermArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingTermDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimelineEventDefaultArgs instead
     */
    export type TimelineEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimelineEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BibleGenerationJobDefaultArgs instead
     */
    export type BibleGenerationJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BibleGenerationJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChapterCommentDefaultArgs instead
     */
    export type ChapterCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChapterCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChapterSnapshotDefaultArgs instead
     */
    export type ChapterSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChapterSnapshotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChapterChangeDefaultArgs instead
     */
    export type ChapterChangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChapterChangeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChapterActivityDefaultArgs instead
     */
    export type ChapterActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChapterActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EditorProfileDefaultArgs instead
     */
    export type EditorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EditorProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PortfolioItemDefaultArgs instead
     */
    export type PortfolioItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PortfolioItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectListingDefaultArgs instead
     */
    export type ProjectListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectListingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectApplicationDefaultArgs instead
     */
    export type ProjectApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectContractDefaultArgs instead
     */
    export type ProjectContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChapterRevisionRequestDefaultArgs instead
     */
    export type ChapterRevisionRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChapterRevisionRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EditorReviewDefaultArgs instead
     */
    export type EditorReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EditorReviewDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}